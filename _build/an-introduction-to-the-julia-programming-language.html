<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Yu-Sheng Zhao" />
  <meta name="author" content="Yi-Dai Zhang" />
  <meta name="author" content="Jin-Guo Liu" />
  <title>An Introduction to the Julia programming language - Scientific Computing for Physicist</title>
  <link rel="shortcut icon" type="image/png" href="/favicon.png"/>
  <link rel="stylesheet" href="/style.css"/>
    <script src="/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/github.min.css">
<script src="/highlight.min.js"></script>
<script src="/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/">Scientific Computing for Physicist</a>
</div><br />
<span class="books-subtitle">
with Julia programming language
</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/open-source-dev-toolchains.html"><b>1</b> Becoming an Open-Source De..</a></li>
<li><a class="menu-level-2" href="/get-a-terminal.html"><b>1.1</b> Get a Terminal!</a></li>
<li><a class="menu-level-2" href="/version-control.html"><b>1.2</b> Code MUST be Maintained:..</a></li>
<li><a class="menu-level-2" href="/ci-cd.html"><b>1.3</b> Code MUST be Tested!</a></li>
<li><a class="menu-level-2" href="/learn-to-collaborate.html"><b>1.4</b> Learn to Collaborate</a></li>
<li><a class="menu-level-2" href="/share-your-code.html"><b>1.5</b> Share Your Code</a></li>
<li><a class="menu-level-1" href="/julia.html"><b>2</b> Julia</a></li>
<li><a class="menu-level-2" href="/setup.html"><b>2.1</b> Setup Julia</a></li>
<li><a class="menu-level-2" href="/an-introduction-to-the-julia-programming-language.html"><b>2.2</b> An Introduction to the J..</a></li>
<li><a class="menu-level-1" href="/appendix.html"><b></b> Appendix</a></li>
<li><a class="menu-level-1" href="/references.html"><b>3</b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="2.2" id="an-introduction-to-the-julia-programming-language"><span class="header-section-number">2.2</span> An Introduction to the Julia programming language</h2>
<h3 data-number="2.2.1" id="a-survey"><span class="header-section-number">2.2.1</span> A survey</h3>
<p>What programming language do you use? Do you have any pain point about this language?</p>
<h3 data-number="2.2.2" id="what-is-julialang"><span class="header-section-number">2.2.2</span> What is JuliaLang?</h3>
<p><strong>A modern, open-source, high performance programming lanaguage</strong></p>
<p>JuliaLang was born in 2012 in MIT, now is maintained by Julia Computing Inc. located in Boston, US. Founders are Jeff Bezanson, Alan Edelman, Stefan Karpinski, Viral B. Shah.</p>
<p>JuliaLang is open-source, its code is maintained on <a href="https://github.com/JuliaLang/julia">Github</a>(https://github.com/JuliaLang/julia) and it open source LICENSE is MIT. Julia packages can be found on <a href="https://juliahub.com/ui/Packages">JuliaHub</a>, most of them are open-source.</p>
<p>It is designed for speed.</p>
<p><img src="./assets/images/benchmark.png" alt="image" width="500" height="auto"></p>
<h3 data-number="2.2.3" id="reference"><span class="header-section-number">2.2.3</span> Reference</h3>
<p><a href="https://arxiv.org/abs/1209.5145">arXiv:1209.5145</a></p>
<p><strong>Julia: A Fast Dynamic Language for Technical Computing</strong></p>
<p>– Jeff Bezanson, Stefan Karpinski, Viral B. Shah, Alan Edelman</p>
<p><strong>Dynamic</strong> languages have become popular for scientific computing. They are generally considered highly productive, but lacking in performance. This paper presents Julia, a new dynamic language for technical computing, designed for performance from the beginning by adapting and extending modern programming language techniques. A design based on generic functions and a rich type system simultaneously enables an expressive programming model and successful type inference, leading to good performance for a wide range of programs. This makes it possible for much of the Julia library to be written in Julia itself, while also incorporating best-of-breed C and Fortran libraries.</p>
<h3 data-number="2.2.4" id="terms-explained"><span class="header-section-number">2.2.4</span> Terms explained</h3>
<ul>
<li>dynamic programming language: In computer science, a dynamic programming language is a class of high-level programming languages, which at runtime execute many common programming behaviours that static programming languages perform during compilation. These behaviors could include an extension of the program, by adding new code, by extending objects and definitions, or by modifying the type system.</li>
<li>type: In a programming language, a type is a description of a set of values and a set of allowed operations on those values.</li>
<li>generic function: In computer programming, a generic function is a function defined for polymorphism.</li>
<li>type inference: Type inference refers to the automatic detection of the type of an expression in a formal language.</li>
</ul>
<h3 data-number="2.2.5" id="the-two-language-problem"><span class="header-section-number">2.2.5</span> The two language problem</h3>
<p><strong>Executing a C program</strong></p>
<ul>
<li><p>C code is typed.</p></li>
<li><p>C code needs to be compiled</p></li>
</ul>
<p><strong>One can use <code>Libdl</code> package to open a shared library</strong></p>
<pre class="language-julia"><code>using Libdl</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>c_factorial(x) = Libdl.@ccall &quot;clib/demo&quot;.c_factorial(x::Csize_t)::Int</code></pre>
<pre class="output"><code>c_factorial (generic function with 1 method)</code></pre>
<p><strong>Typed code may overflow, but is fast!</strong></p>
<pre class="language-julia"><code>using BenchmarkTools</code></pre>
<pre class="output"><code>nothing</code></pre>
<p><a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/">learn more about calling C code in Julia</a></p>
<p>Discussion: not all type specifications are nessesary.</p>
<p><strong>Executing a Pyhton Program</strong></p>
<p><strong>Dynamic programming language does not require compiling”</strong></p>
<p><strong>Dynamic typed language is more flexible, but slow!</strong></p>
<pre class="language-julia"><code>typemax(Int)</code></pre>
<p>9223372036854775807</p>
<p><strong>The reason why dynamic typed language is slow is related to caching.</strong></p>
<p>Dynamic typed language uses <code>Box(type, *data)</code> to represent an object.</p>
<p><img src="./assets/images/data.png" alt="image" width="300" height="auto"></p>
<p>Cache miss!</p>
<h3 data-number="2.2.6" id="two-languages-e.g.-python-cc"><span class="header-section-number">2.2.6</span> Two languages, e.g. Python &amp; C/C++?</h3>
<p><strong>From the maintainance’s perspective</strong></p>
<ul>
<li>Requires a build system and configuration files,</li>
<li>Not easy to train new developers.</li>
</ul>
<p><strong>There are many problems can not be vectorized</strong> - Monte Carlo method and simulated annealing method, - Generic Tensor Network method: the tensor elements has tropical algebra or finite field algebra, - Branching and bound. <img src="./assets/images/pythonc.png" alt="image" width="500" height="auto"></p>
<h3 data-number="2.2.7" id="julias-solution"><span class="header-section-number">2.2.7</span> Julia’s solution</h3>
<p>NOTE: I should open a Julia REPL now!</p>
<p><strong>1. Your computer gets a Julia program</strong></p>
<pre class="language-julia"><code>function jlfactorial(n)
    x = 1
    for i in 1:n
        x = x * i
    end
    return x
end</code></pre>
<pre class="output"><code>jlfactorial (generic function with 1 method)</code></pre>
<p>Method instance is a compiled binary of a function for specific input types. When the function is written, the binary is not yet generated.</p>
<pre class="language-julia"><code>using MethodAnalysis</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>methodinstances(jlfactorial)</code></pre>
<pre class="output"><code>MethodInstance for jlfactorial(::UInt32)</code></pre>
<p><strong>2. When calling a function, the Julia compiler infers types of variables on an intermediate representation (IR)</strong></p>
<p><img src="./assets/images/calling function.png" alt="image" width="500" height="auto"></p>
<p><strong>3. The typed program is then compiled to LLVM IR</strong> <img src="./assets/images/dragon.png" alt="image" width="300" height="auto"></p>
<p>LLVM is a set of compiler and toolchain technologies that can be used to develop a front end for any programming language and a back end for any instruction set architecture. LLVM is the backend of multiple languages, including Julia, Rust, Swift and Kotlin.</p>
<p><strong>4. LLVM IR does some optimization, and then compiled to binary code.</strong></p>
<pre><code>with_terminal() do
    @code_native jlfactorial(10)
end</code></pre>
<p><strong>Aftering calling a function, a method instance will be generated.</strong></p>
<p><strong>A new method will be generatd whenever there is a new type as the input.</strong></p>
<pre class="language-julia"><code>jlfactorial(UInt32(10))</code></pre>
<p>3628800</p>
<pre class="language-julia"><code>methodinstances(jlfactorial)</code></pre>
<pre class="output"><code>MethodInstance for jlfactorial(::UInt32)</code></pre>
<p>Dynamically generating method instances is also called Just-in-time compiling (JIT), the secret why Julia is fast!</p>
<p><strong>The key ingredients of performance</strong> - Rich type information, provided naturally by multiple dispatch; - aggressive code specialization against run-time types; - JIT compilation using the LLVM compiler framework.</p>
<h3 data-number="2.2.8" id="julias-type-system"><span class="header-section-number">2.2.8</span> Julia’s type system</h3>
<ol type="1">
<li>Abstract types, which may have declared subtypes and supertypes (a subtype relation is declared using the notation Sub &lt;: Super)</li>
<li>Composite types (similar to C structs), which have named fields and declared supertypes</li>
<li>Bits types, whose values are represented as bit strings, and which have declared supertypes</li>
<li>Tuples, immutable ordered collections of values</li>
<li>Union types, abstract types constructed from other types via set union</li>
</ol>
<p><strong>Numbers</strong> <strong>Type hierachy in Julia is a tree (without multiple inheritance)</strong></p>
<pre class="language-julia"><code>AbstractFloat &lt;: Real</code></pre>
<p>true</p>
<p><strong>Abstract types does not have fields, while composite types have</strong></p>
<pre class="language-julia"><code>Base.isabstracttype(Number)</code></pre>
<p>true</p>
<pre class="language-julia"><code>Base.isconcretetype(Complex{Float64})</code></pre>
<p>true</p>
<pre class="language-julia"><code>fieldnames(Complex)</code></pre>
<pre class="output"><code>(:re, :im)</code></pre>
<p><strong>We have only finite primitive types on a machine, they are those supported natively by computer instruction.</strong></p>
<pre class="language-julia"><code>Base.isprimitivetype(Float64)</code></pre>
<p>true</p>
<p><strong><code>Any</code> is a super type of any other type</strong></p>
<pre class="language-julia"><code>Number &lt;: Any</code></pre>
<p>true</p>
<p><strong>A type contains two parts: type name and type parameters</strong></p>
<pre class="language-julia"><code>Complex{Float64}</code></pre>
<pre class="output"><code>ComplexF64 (alias for Complex{Float64})</code></pre>
<p><strong>ComplexF64 is a bits type, it has fixed size</strong></p>
<pre class="language-julia"><code>sizeof(Complex{Float32})</code></pre>
<p>8</p>
<pre class="language-julia"><code>sizeof(Complex{Float64})</code></pre>
<p>16</p>
<p>But Complex{BigFloat} is not</p>
<pre class="language-julia"><code>sizeof(Complex{BigFloat})</code></pre>
<p>16</p>
<pre class="language-julia"><code>isbitstype(Complex{BigFloat})</code></pre>
<p>false</p>
<pre class="language-julia"><code>Complex{Float64}</code></pre>
<pre class="output"><code>ComplexF64 (alias for Complex{Float64})</code></pre>
<p>The size of Complex{BigFloat} is not true! It returns the pointer size!</p>
<p><strong>A type can be neither abstract nor concrete.</strong></p>
<p>To represent a complex number with its real and imaginary parts being floating point numbers</p>
<pre class="language-julia"><code>Complex{&lt;:AbstractFloat}</code></pre>
<pre class="output"><code>Complex{&lt;:AbstractFloat}</code></pre>
<pre class="language-julia"><code>Complex{Float64} &lt;: Complex{&lt;:AbstractFloat}</code></pre>
<p>true</p>
<pre class="language-julia"><code>Base.isabstracttype(Complex{&lt;:AbstractFloat})</code></pre>
<p>false</p>
<pre class="language-julia"><code>Base.isconcretetype(Complex{&lt;:AbstractFloat})</code></pre>
<p>false</p>
<p><strong>We use Union to represent the union of two types</strong></p>
<pre class="language-julia"><code>Union{AbstractFloat, Complex} &lt;: Number</code></pre>
<p>true</p>
<pre class="language-julia"><code>Union{AbstractFloat, Complex} &lt;: Real</code></pre>
<p>false</p>
<p>NOTE: it is similar to multiple inheritance, but Union can not have subtype!</p>
<p><strong>You can make an alias for a type name if you think it is too long</strong></p>
<pre class="language-julia"><code>FloatAndComplex{T} = Union{T, Complex{T}} where T&lt;:AbstractFloat</code></pre>
<pre class="output"><code>Union{Complex{T}, T} where T&lt;:AbstractFloat</code></pre>
<h3 data-number="2.2.9" id="case-study-vector-element-type-and-speed"><span class="header-section-number">2.2.9</span> Case study: Vector element type and speed</h3>
<p><strong>Any type vector is flexible. You can add any element into it.</strong></p>
<pre class="language-julia"><code>vany = Any[]  # same as vany = []</code></pre>
<pre class="language-julia"><code>typeof(vany)</code></pre>
<pre class="output"><code>Vector{Any} (alias for Array{Any, 1})</code></pre>
<pre class="language-julia"><code>push!(vany, &quot;a&quot;)</code></pre>
<p>a</p>
<pre class="language-julia"><code>push!(vany, 1)</code></pre>
<p>a</p>
<p>1</p>
<p><strong>Fixed typed vector is more restrictive.</strong></p>
<pre class="language-julia"><code>vfloat64 = Float64[]</code></pre>
<pre class="output"><code>Float64[]</code></pre>
<pre class="language-julia"><code>vfloat64 |&gt; typeof</code></pre>
<pre class="output"><code>Vector{Float64} (alias for Array{Float64, 1})</code></pre>
<h3 data-number="2.2.10" id="multiple-dispatch"><span class="header-section-number">2.2.10</span> Multiple dispatch</h3>
<pre class="language-julia"><code>abstract type AbstractAnimal{L} end</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>struct Dog &lt;: AbstractAnimal{4}
    color::String
end</code></pre>
<pre class="output"><code>nothing</code></pre>
<p>&lt;: is the symbol for sybtyping， A &lt;: B means A is a subtype of B.</p>
<pre class="language-julia"><code>struct Cat &lt;: AbstractAnimal{4}
    color::String
end</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>abstract type AbstractAnimal{L} end</code></pre>
<pre class="output"><code>nothing</code></pre>
<p><strong>One can implement the same function on different types</strong></p>
<p>The most general one as the fall back method</p>
<pre class="language-julia"><code>fight(a::AbstractAnimal, b::AbstractAnimal) = &quot;draw&quot;</code></pre>
<pre class="output"><code>fight (generic function with 1 method)</code></pre>
<p><strong>The most concrete method is called</strong></p>
<pre class="language-julia"><code>fight(dog::Dog, cat::Cat) = &quot;win&quot;</code></pre>
<pre class="output"><code>fight (generic function with 2 methods)</code></pre>
<pre class="language-julia"><code>fight(Dog(&quot;blue&quot;), Cat(&quot;white&quot;))</code></pre>
<p>win</p>
<p><strong>A final comment: do not abuse the type system, otherwise the main memory might explode for generating too many functions.</strong></p>
<pre class="language-julia"><code>fib(x::Int) = x &lt;= 2 ? 1 : fib(x-1) + fib(x-2)</code></pre>
<pre class="output"><code>fib (generic function with 1 method)</code></pre>
<p><strong>A “zero” cost implementation</strong></p>
<pre class="language-julia"><code>Val(3.0)</code></pre>
<pre class="output"><code>Val{3.0}()</code></pre>
<pre class="language-julia"><code>addup(::Val{x}, ::Val{y}) where {x, y} = Val(x + y)</code></pre>
<pre class="output"><code>addup (generic function with 1 method)</code></pre>
<pre class="language-julia"><code>f(::Val{x}) where x = addup(f(Val(x-1)), f(Val(x-2)))</code></pre>
<pre class="output"><code>f (generic function with 1 method)</code></pre>
<pre class="language-julia"><code>f(::Val{1}) = Val(1)</code></pre>
<pre class="output"><code>f (generic function with 2 methods)</code></pre>
<pre class="language-julia"><code>f(::Val{2}) = Val(1)</code></pre>
<pre class="output"><code>f (generic function with 3 methods)</code></pre>
<p>However, this violates the Performance Tips, since it transfers the run-time to compile time.</p>
<h3 data-number="2.2.11" id="multiple-dispatch-is-more-powerful-than-object-oriented-programming"><span class="header-section-number">2.2.11</span> Multiple dispatch is more powerful than object-oriented programming!</h3>
<p>Implement addition in Python.</p>
<pre><code>class X:
  def __init__(self, num):
    self.num = num

  def __add__(self, other_obj):
    return X(self.num+other_obj.num)

  def __radd__(self, other_obj):
    return X(other_obj.num + self.num)

  def __str__(self):
    return &quot;X = &quot; + str(self.num)

class Y:
  def __init__(self, num):
    self.num = num

  def __radd__(self, other_obj):
    return Y(self.num+other_obj.num)

  def __str__(self):
    return &quot;Y = &quot; + str(self.num)

print(X(3) + Y(5))


print(Y(3) + X(5))</code></pre>
<p>Implement addition in Julia</p>
<pre class="language-julia"><code>struct X{T}
    num::T
end</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>struct Y{T}
    num::T
end</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::X, b::Y) = X(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::Y, b::X) = X(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::X, b::X) = X(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::Y, b::Y) = Y(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<p><strong>Multiple dispatch is easier to extend!</strong></p>
<p>If C wants to extend this method to a new type Z.</p>
<pre><code>class Z:
  def __init__(self, num):
    self.num = num

  def __add__(self, other_obj):
    return Z(self.num+other_obj.num)

  def __radd__(self, other_obj):
    return Z(other_obj.num + self.num)

  def __str__(self):
    return &quot;Z = &quot; + str(self.num)

print(X(3) + Z(5))

print(Z(3) + X(5))</code></pre>
<pre class="language-julia"><code>struct Z{T}
    num::T
end</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::X, b::Z) = Z(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::Z, b::X) = Z(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::Y, b::Z) = Z(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::Z, b::Y) = Z(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>Base.:(+)(a::Z, b::Z) = Z(a.num + b.num)</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>X(3) + Y(5)</code></pre>
<pre class="output"><code>X{Int64}(8)</code></pre>
<pre class="language-julia"><code>Y(3) + X(5)</code></pre>
<pre class="output"><code>X{Int64}(8)</code></pre>
<pre class="language-julia"><code>X(3) + Z(5)</code></pre>
<pre class="output"><code>Z{Int64}(8)</code></pre>
<pre class="language-julia"><code>Z(3) + Y(5)</code></pre>
<pre class="output"><code>Z{Int64}(8)</code></pre>
<p><strong>Julia function space is exponetially large!</strong> Quiz: If a function has parameters, and the module has types, how many different functions can be generated?</p>
<pre><code>f(x::T1, y::T2, z::T3...)</code></pre>
<p>If it is an object-oriented language like Python？</p>
<pre><code>class T1:
    def f(self, y, z, ...):
        self.num = num</code></pre>
<p><strong>Summary</strong> - Multiple dispatch is a feature of some programming languages in which a function or method can be dynamically dispatched based on the run-time type.</p>
<ul>
<li><p>Julia’s mutiple dispatch provides exponential abstraction power comparing with an object-oriented language.</p></li>
<li><p>By carefully designed type system, we can program in an exponentially large function space.</p></li>
</ul>
<h3 data-number="2.2.12" id="tuple-array-and-broadcasting"><span class="header-section-number">2.2.12</span> Tuple, Array and broadcasting</h3>
<p><strong>Tuple has fixed memory layout, but array does not.</strong></p>
<pre class="language-julia"><code>tp = (1, 2.0, &#39;c&#39;)</code></pre>
<pre class="output"><code>(1, 2.0, &#39;c&#39;)</code></pre>
<pre class="language-julia"><code>typeof(tp)</code></pre>
<pre class="output"><code>Tuple{Int64, Float64, Char}</code></pre>
<pre class="language-julia"><code>isbitstype(typeof(tp))</code></pre>
<p>true</p>
<pre class="language-julia"><code>arr = [1, 2.0, &#39;c&#39;]</code></pre>
<p>1</p>
<p>2.0</p>
<pre class="output"><code>&#39;c&#39;: ASCII/Unicode U+0063 (category Ll: Letter, lowercase)</code></pre>
<pre class="language-julia"><code>typeof(arr)</code></pre>
<pre class="output"><code>Vector{Any} (alias for Array{Any, 1})</code></pre>
<pre class="language-julia"><code>isbitstype(typeof(arr))</code></pre>
<p>false</p>
<p><strong>Boardcasting</strong></p>
<pre class="language-julia"><code>x = 0:0.1:π</code></pre>
<pre class="output"><code>0.0:0.1:3.1</code></pre>
<pre class="language-julia"><code>y = sin.(x)</code></pre>
<pre class="output"><code>[0.0, 0.09983341664682815, 0.19866933079506122, 0.2955202066613396, 0.3894183423086505, 0.479425538604203, 0.5646424733950355, 0.6442176872376911, 0.7173560908995228, 0.7833269096274834, 0.8414709848078965, 0.8912073600614354, 0.9320390859672264, 0.963558185417193, 0.9854497299884603, 0.9974949866040544, 0.9995736030415051, 0.9916648104524686, 0.9738476308781951, 0.9463000876874145, 0.9092974268256817, 0.8632093666488737, 0.8084964038195901, 0.74570521217672, 0.6754631805511506, 0.5984721441039564, 0.5155013718214642, 0.4273798802338298, 0.33498815015590466, 0.23924932921398198, 0.1411200080598672, 0.04158066243329049]</code></pre>
<pre class="language-julia"><code>using Plots</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>plot(x, y; label=&quot;sin&quot;)</code></pre>
<pre class="output"><code>Plot{Plots.GRBackend() n=1}</code></pre>
<pre class="language-julia"><code>mesh = (1:100)&#39;</code></pre>
<pre class="output"><code>1×100 adjoint(::UnitRange{Int64}) with eltype Int64:
 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96  97  98  99  100</code></pre>
<pre class="language-julia"><code>let
    X, Y = 0:0.1:5, 0:0.1:5
    heatmap(X, Y, sin.(X .+ Y&#39;))
end</code></pre>
<pre class="output"><code>Plot{Plots.GRBackend() n=1}</code></pre>
<p><strong>Broadcasting over non-concrete element types may be type unstable.</strong></p>
<pre class="language-julia"><code>eltype(arr)</code></pre>
<pre class="output"><code>Any</code></pre>
<pre class="language-julia"><code>arr .+ 1</code></pre>
<p>2</p>
<p>3.0</p>
<pre class="output"><code>&#39;d&#39;: ASCII/Unicode U+0064 (category Ll: Letter, lowercase)</code></pre>
<pre class="language-julia"><code>eltype(tp)</code></pre>
<pre class="output"><code>Any</code></pre>
<h3 data-number="2.2.13" id="julia-package-development"><span class="header-section-number">2.2.13</span> Julia package development</h3>
<pre class="language-julia"><code>using TropicalNumbers</code></pre>
<pre class="output"><code>nothing</code></pre>
<p>The file structure of a package</p>
<pre class="language-julia"><code>project_folder = dirname(dirname(pathof(TropicalNumbers)))</code></pre>
<p>/home/yidai/.julia/packages/TropicalNumbers/kRhOl</p>
<p><img src="./assets/images/julia_dev.png" alt="image" width="500" height="auto"></p>
<p><strong>Unit Test</strong></p>
<pre class="language-julia"><code>using Test</code></pre>
<pre class="output"><code>nothing</code></pre>
<pre class="language-julia"><code>@test Tropical(3.0) + Tropical(2.0) == Tropical(3.0)</code></pre>
<pre class="output"><code>Test Passed</code></pre>
<pre class="language-julia"><code>@test_throws BoundsError [1,2][3]</code></pre>
<pre class="output"><code>Test Passed
      Thrown: BoundsError</code></pre>
<pre class="language-julia"><code>@test_broken 3 == 2</code></pre>
<pre class="output"><code>Test Broken
  Expression: 3 == 2</code></pre>
<pre class="language-julia"><code>@testset &quot;Tropical Number addition&quot; begin
    @test Tropical(3.0) + Tropical(2.0) == Tropical(3.0)
    @test_throws BoundsError [1][2]
    @test_broken 3 == 2
end</code></pre>
<pre class="output"><code>Test.DefaultTestSet(&quot;Tropical Number addition&quot;, Any[Test Broken
  Expression: 3 == 2], 2, false, false, true, 1.708268439682298e9, 1.708268439693213e9, false, &quot;none&quot;)</code></pre>
<h3 data-number="2.2.14" id="case-study-create-a-package-like-happymolecules"><span class="header-section-number">2.2.14</span> Case study: Create a package like HappyMolecules</h3>
<p>With <code>PkgTemplates</code>.</p>
<p><a href="https://github.com/CodingThrust/HappyMolecules.jl">https://github.com/CodingThrust/HappyMolecules.jl</a></p>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/setup.html"><b>2.1</b> Setup Julia</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-1" href="/appendix.html"><b></b> Appendix</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Yu-Sheng Zhao, Yi-Dai Zhang, Jin-Guo Liu
</div>
</div>
</div>
</body>
</html>