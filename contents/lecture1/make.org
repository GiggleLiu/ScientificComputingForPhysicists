
:PROPERTIES:
:ID:       e5ca8be0-92aa-44f7-b076-8e68954f58fc
:END:
#+title: Make
#+HUGO_BASE_DIR: ./
#+filetags:
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{esdiff}
#+LATEX_HEADER: \usepackage{braket}
* Ref [1/3]
- [X] [[https://makefiletutorial.com/#getting-started][Make tutorial]]
- [ ] [[https://seisman.github.io/how-to-write-makefile/index.html][Good source for learning how to write makefile]]
- [ ] [[https://www.gnu.org/software/make/manual/][Make manual]]
* Make
- Help you manage compiling hundreds of file in a project
- Depends on a ~Makefile~ file for
  1) Targets: which to compile
  2) Dependencies: in what order and how to find required headers etc
  3) Rules: flags and compiler
- It runs from bottom to up

** Missing separator
- Makefile need tabs "\t" to let it know we are passing in commands
- Doom Emacs seems to insert 4 spaces instead of a tab for me.
- ~.RECIPEPREFIX = >~ allows the use of ">" as separator instead of the tab
** Generate json file for lsp
- Use ~bear~
- ~make clean; bear -- make~
* Templates
- Real world, ultra lazy ass ,handy
  1) We will need to run ~make depend~ first to update the dependency, which are
     the bottom two lines
    #+begin_src makefile
    CC = gcc
    CFLAGS = -std=gnu99 -pedantic -Wall
    SRCS=$(wildcard *.c) # finds all file in folder ending with .c
    OBJS=$(patsubst %.c,%.o,$(SRCS)) # replace the list of name ending in .c with .o
    myProgram: $(OBJS)
        gcc -o $@ $(OBJS) # $@ is just program name
    .PHONY: clean depend
    clean:
        rm -f myProgram *.o *.c~ *.h~
    depend:
        makedepend $(SRCS)
    # DO NOT DELETE
    anotherFile.o: anotherHeader.h someHeader.h
    oneFile.o: oneHeader.h someHeader.h
    #+end_src

- If you need to debug use the following make
      #+begin_src makefile
    CC = gcc
    CFLAGS = -std=gnu99 -pedantic -Wall -O3
    DBGFLAGS = -std=gnu99 -pedantic -Wall -ggdb3 -DDEBUG
    SRCS=$(wildcard *.c)
    OBJS=$(patsubst %.c,%.o,$(SRCS))
    DBGOBJS=$(patsubst %.c,%.dbg.o,$(SRCS))
    .PHONY: clean depend all
    all: myProgram myProgram-debug
    myProgram: $(OBJS)
        gcc -o $@ -O3 $(OBJS)
    myProgram-debug: $(DBGOBJS)
        gcc -o $@ -ggdb3 $(DBGOBJS)
    %.dbg.o: %.c
        gcc $(DBGFLAGS) -c -o $@ $<
    clean:
        rm -f myProgram myProgram-debug *.o *.c~ *.h~
    depend:
        makedepend $(SRCS)
        makedepend -a -o .dbg.o  $(SRCS)
    # DO NOT DELETE
    anotherFile.o: anotherHeader.h someHeader.h
    oneFile.o: oneHeader.h someHeader.h
      #+end_src
- Medium size project example
      #+begin_src makefile
    # Thanks to Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/)
    TARGET_EXEC := final_program

    BUILD_DIR := ./build
    SRC_DIRS := ./src

    # Find all the C and C++ files we want to compile
    # Note the single quotes around the * expressions. Make will incorrectly expand these otherwise.
    SRCS := $(shell find $(SRC_DIRS) -name '*.cpp' -or -name '*.c' -or -name '*.s')

    # String substitution for every C/C++ file.
    # As an example, hello.cpp turns into ./build/hello.cpp.o
    OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)

    # String substitution (suffix version without %).
    # As an example, ./build/hello.cpp.o turns into ./build/hello.cpp.d
    DEPS := $(OBJS:.o=.d)

    # Every folder in ./src will need to be passed to GCC so that it can find header files
    INC_DIRS := $(shell find $(SRC_DIRS) -type d)
    # Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag
    INC_FLAGS := $(addprefix -I,$(INC_DIRS))

    # The -MMD and -MP flags together generate Makefiles for us!
    # These files will have .d instead of .o as the output.
    CPPFLAGS := $(INC_FLAGS) -MMD -MP

    # The final build step.
    $(BUILD_DIR)/$(TARGET_EXEC): $(OBJS)
    	$(CC) $(OBJS) -o $@ $(LDFLAGS)

    # Build step for C source
    $(BUILD_DIR)/%.c.o: %.c
    	mkdir -p $(dir $@)
    	$(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@

    # Build step for C++ source
    $(BUILD_DIR)/%.cpp.o: %.cpp
    	mkdir -p $(dir $@)
    	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@


    .PHONY: clean
    clean:
    	rm -r $(BUILD_DIR)

    # Include the .d makefiles. The - at the front suppresses the errors of missing
    # Makefiles. Initially, all the .d files will be missing, and we don't want those
    # errors to show up.
    -include $(DEPS)
    #+end_src
* Syntax
** Default
1) The closer you are to the top the closer the output should be to an
   executable
    #+begin_src  makefile
    targets: prerequisites
        command
        command
        command
    target: dependency files
        gcc flags
    myProgram: oneFile.o anotherFile.o
        gcc -o myProgram oneFile.o anotherFile.o
    oneFile.o: oneFile.c oneHeader.h someHeader.h
        gcc -std=gnu99 -pedantic -Wall -c oneFile.c
    anotherFile.o: anotherFile.c anotherHeader.h someHeader.h
        gcc -std=gnu99 -pedantic -Wall -c anotherFile.c
    #+end_src

*** ~.PHONY~ means not actually create the file clean but treat it as a
     command.
    #+begin_src  makefile
    .PHONY: clean
    clean:
        rm -f myProgram *.o *.c~ *.h~
    #+end_src

#+begin_src  makefile
CC = gcc # specify compiler for default object file compilation
CFLAGS = -std=gnu99 -pedantic -Wall
myProgram: oneFile.o anotherFile.o
    gcc -o myProgram oneFile.o anotherFile.o
.PHONY: clean depend
clean:
    rm -f myProgram *.o *.c~ *.h~
depend:
    makedepend anotherFile.c oneFile.c # sounds like this line will generate the bottom two automatically
# DO NOT DELETE
anotherFile.o: anotherHeader.h someHeader.h
oneFile.o: oneHeader.h someHeader.h
#+end_src
*** Delete target that signaled error during making
- ~.DELETE_ON_ERROR:~
** Variable
*** Simple variable
- [[https://makefiletutorial.com/#variables-pt-2]]
- Define with ~:=~ or ~=~
  1) ~:=~ simple expand,
  2) ~=~ recursively expand
    #+begin_src makefile
  # Recursive variable. This will print "later" below
  one = one ${later_variable}
  # Simply expanded variable. This will not print "later" below
  two := two ${later_variable}

  later_variable = later

  all:
	  echo $(one)
	  echo $(two)
    #+end_src

- ~?=~ set variable if not set yet
  #+begin_src  makefile
one = hello
one ?= will not be set
two ?= will be set

all:
	echo $(one)
	echo $(two)
  #+end_src

- Reference with ~$()~ or ~${}~
#+begin_src makefile
 files := file1 file2
some_file: $(files)
	echo "Look at this variable: " $(files)
	touch some_file

file1:
	touch file1
file2:
	touch file2

clean:
	rm -f file1 file2 some_file

#+end_src

- Eg
#+begin_src makefile
CFLAGS=-std=gnu99 -pedantic -Wall
myProgram: oneFile.o anotherFile.o
    gcc -o myProgram oneFile.o anotherFile.o
oneFile.o: oneFile.c oneHeader.h someHeader.h
    gcc $(CFLAGS) -c oneFile.c
anotherFile.o: anotherFile.c anotherHeader.h someHeader.h
    gcc $(CFLAGS) -c anotherFile.c
#+end_src

*** Wildcard *
- Use ~%(wildcard *.c)~ for wild card.
- Don't left out ~wildrcard~ part, otherwise mistake
- It will *only* find *existing* files that matches the format.
  #+begin_src makefile
thing_wrong := *.o # Don't do this! '*' will not get expanded
thing_right := $(wildcard *.o)

all: one two three four

# Fails, because $(thing_wrong) is the string "*.o"
one: $(thing_wrong)

# Stays as *.o if there are no files that match this pattern :(
two: *.o

# Works as you would expect! In this case, it does nothing.
three: $(thing_right)

# Same as rule three
four: $(wildcard *.o)
  #+end_src

*** Wildcard %
- It will handle *non-existing* files and expand, useful when generating files?
1) String Substitution
2) The vpath Directive
3) When you feel too lazy to list out all object file
   a) ~$<~ specifies the source c file
   b) Use ~%~
   #+begin_src  makefile
     # A good start, but we lost the dependencies on the header files
     CFLAGS=-std=gnu99 -pedantic -Wall
     myProgram: oneFile.o anotherFile.o
         gcc -o myProgram oneFile.o anotherFile.o
     %.o: %.c
         gcc $(CFLAGS) -c $<
     .PHONY: clean
     clean:
         rm -f myProgram *.o *.c~ *.h~
     oneFile.o: oneHeader.h someHeader.h
     anotherFile.o: anotherHeader.h someHeader.h
   #+end_src
*** Automatic variable
- [[https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html][Collection of all obscure ones]]
- Most used ones
  #+begin_src makefile
hey: one two
	# Outputs "hey", since this is the first target
	echo $@

	# Outputs all prerequisites newer than the target
	echo $?

	# Outputs all prerequisites
	echo $^

	touch hey

one:
	touch one

two:
	touch two

clean:
	rm -f hey one two
  #+end_src
*** Target specific variable
#+begin_src makefile
	all: one = cool

all:
	echo one is defined: $(one)

other:
	echo one is nothing: $(one)

#+end_src
*** Pattern Specific Variable
#+begin_src makefile
%.c: one = cool

blah.c:
	echo one is defined: $(one)

other:
	echo one is nothing: $(one)
#+end_src
** Targets
- May have multiple targets for one block
- ~$@~ expands to all targets
  #+begin_src makefile
all: foo1.o foo2.o

foo1.o foo2.o:
    echo $@

  #+end_src
** Fancy Rules
*** Implicit rules
- You provide the target and requirements, make will carryout implicit actions
  depending on specific variable values.

- Compiling a C program: n.o is made automatically from n.c with a command of
  the form ~$(CC) -c $(CPPFLAGS) $(CFLAGS)~
- Compiling a C++ program: n.o is made automatically from n.cc or n.cpp with a
  command of the form ~$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)~
- Linking a single object file: n is made automatically from n.o by running the
  command ~$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)~
- The important variables used by implicit rules are:
  1) ~CC~: Program for compiling C programs; default cc
  2) ~CXX~: Program for compiling C++ programs; default g++
  3) ~CFLAGS~: Extra flags to give to the C compiler
  4) ~CXXFLAGS~: Extra flags to give to the C++ compiler
  5) ~CPPFLAGS~: Extra flags to give to the C preprocessor
  6) ~LDFLAGS~: Extra flags to give to compilers when they are supposed to
     invoke the linker

     #+begin_src  makefile
CC = gcc # Flag for implicit rules
CFLAGS = -g # Flag for implicit rules. Turn on debug info

# Implicit rule #1: blah is built via the C linker implicit rule
# Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists
blah: blah.o

blah.c:
	echo "int main() { return 0; }" > blah.c

clean:
	rm -f blah*
     #+end_src
*** Static Pattern Rule
- Use ~%~ wildcard to get the stem in targets and use the stem in pre-requisites
- ~targets...: target-pattern: prereq-patterns ...~
  #+begin_src  makefile
objects = foo.o bar.o all.o
all: $(objects)

# These files compile via implicit rules
# Syntax - targets ...: target-pattern: prereq-patterns ...
# In the case of the first target, foo.o, the target-pattern matches foo.o and sets the "stem" to be "foo".
# It then replaces the '%' in prereq-patterns with that stem
$(objects): %.o: %.c
# equivalent to below
# foo.o: foo.c
# bar.o: bar.c
# all.o: all.c

all.c:
	echo "int main() { return 0; }" > all.c

%.c:
	touch $@

clean:
	rm -f *.c *.o all

  #+end_src
**** Filter
- Within a list of file names, filter out the ones you want to work on
#+begin_src makefile
obj_files = foo.result bar.o lose.o
src_files = foo.raw bar.c lose.c

all: $(obj_files)

$(filter %.o,$(obj_files)): %.o: %.c
	echo "only files with .o ending is kept"
	echo "target: $@ prereq: $<"
$(filter %.result,$(obj_files)): %.result: %.raw
	echo "only file with .result ending is kept"
	echo "target: $@ prereq: $<"

%.c %.raw:
	touch $@

clean:
	rm -f $(src_files)
#+end_src
*** Pattern Rule
- A simpler form of static rule
- *OR* define you own implicit rules
  #+begin_src  makefile
# Define a pattern rule that compiles every .c file into a .o file
%.o : %.c
		$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
  #+end_src
*** Double Colon Rule
- Allow multiple command with same target
- Rarely used.
- I don't see the point of it.
  #+begin_src makefile
all: blah

blah::
	echo "hello"

blah::
	echo "hello again"
  #+end_src
** Conditional
*** If
#+begin_src  makefile
foo = ok

all:
ifeq ($(foo), ok)
	echo "foo equals ok"
else
	echo "nope"
endif
#+end_src
*** Check if empty
#+begin_src makefile
nullstring =
foo = $(nullstring) # end of line; there is a space here

all:
ifeq ($(strip $(foo)),)
	echo "foo is empty after being stripped"
endif
ifeq ($(nullstring),)
	echo "nullstring doesn't even have spaces"
endif
#+end_src
*** Check if defined
#+begin_src makefile
bar =
foo = $(bar)

all:
ifdef foo
	echo "foo is defined"
endif
ifndef bar
	echo "but bar is not"
endif
#+end_src
*** Search within ~makeflag~
#+begin_src makefile
bar =
foo = $(bar)

all:
# Search for the "-i" flag. MAKEFLAGS is just a list of single characters, one per flag. So look for "i" in this case.
ifneq (,$(findstring i, $(MAKEFLAGS)))
	echo "i was passed to MAKEFLAGS"
endif
#+end_src

* Commands and Execution in Make
- Each command appears as if they are started in a new shell. I.e ~cd~ effect will not persist
- add ~-s~ or ~@~ prior to ~echo~ commands to silence ~echo~
** Specify Shell
#+begin_src makefile
SHELL=/bin/bash

cool:
	echo "Hello from bash"
#+end_src
** Error Handling with flags
1) ~-k~ continue running even got error
2) ~-~ suppress error
3) ~-i~ surpress error for all commands
#+begin_src makefile
one:
	# This error will be printed but ignored, and make will continue to run
	-false
	touch one
#+end_src
** Call Make recursively in Makefile
- ~$(MAKE)~
- Use ~export~ to make a variable accessible for recursive called make
  1) .EXPORT_ALL_VARIABLES exports all variables for you.

  #+begin_src makefile
new_contents = "hello:\n\techo \$$(cooly)"

all:
	mkdir -p subdir
	printf $(new_contents) | sed -e 's/^ //' > subdir/makefile
	@echo "---MAKEFILE CONTENTS---"
	@cd subdir && cat makefile
	@echo "---END MAKEFILE CONTENTS---"
	cd subdir && $(MAKE)

# Note that variables and exports. They are set/affected globally.
cooly = "The subdirectory can see me!"
export cooly
# This would nullify the line above: unexport cooly

clean:
	rm -rf subdir
  #+end_src
** Flags
- see ~man make~
** Override Command line argument
- Given that you may or may not provide a certain argument, what to do
#+begin_src makefile
# Overrides command line arguments
override option_one = did_override
# Does not override command line arguments
option_two = not_override
all:
	echo $(option_one)
	echo $(option_two)
#+end_src
** Explicitly run command in different shell
- Use ~define~ and ~endef~
#+begin_src makefile
one = export blah="I was set!"; echo $$blah

define two
export blah=set
echo $$blah
endef

# One and two are different.

all:
	@echo "This prints 'I was set'"
	@$(one)
	@echo "This does not print 'I was set' because each command runs in a separate shell"
	@$(two)
#+end_src
* Functions
- Skipped
- [[https://www.gnu.org/software/make/manual/html_node/Functions.html][Builtin functions]]
