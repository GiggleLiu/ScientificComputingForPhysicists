<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plotting recipes with CairoMakie · Scientific Computing For Physicists</title><meta name="title" content="Plotting recipes with CairoMakie · Scientific Computing For Physicists"/><meta property="og:title" content="Plotting recipes with CairoMakie · Scientific Computing For Physicists"/><meta property="twitter:title" content="Plotting recipes with CairoMakie · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/append/plotting/"/><meta property="twitter:url" content="https://book.jinguo-group.science/append/plotting/"/><link rel="canonical" href="https://book.jinguo-group.science/append/plotting/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../../chap2/julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../../chap2/julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../../chap2/julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../../chap2/julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../../chap2/julia-release/">My First Package</a></li><li><a class="tocitem" href="../../chap2/julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../chap3/linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../../chap3/lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/qr/">QR Factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../chap3/tensors/">Tensor Operations</a></li><li><a class="tocitem" href="../../chap3/cuda/">Arrays on GPU</a></li><li><a class="tocitem" href="../../chap3/sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Randomness</span><ul><li><a class="tocitem" href="../../chap5/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li class="is-active"><a class="tocitem" href>Plotting recipes with CairoMakie</a><ul class="internal"><li><a class="tocitem" href="#Importing"><span>Importing</span></a></li><li><a class="tocitem" href="#Line-Plot"><span>Line Plot</span></a></li><li><a class="tocitem" href="#Scatter-Plot"><span>Scatter Plot</span></a></li><li><a class="tocitem" href="#Bar-plot"><span>Bar plot</span></a></li><li><a class="tocitem" href="#Heatmap"><span>Heatmap</span></a></li><li><a class="tocitem" href="#Contour-Plot"><span>Contour Plot</span></a></li><li><a class="tocitem" href="#Surface-plot"><span>Surface plot</span></a></li><li><a class="tocitem" href="#Colorbar-of-heatmap/contour"><span>Colorbar of heatmap/contour</span></a></li><li><a class="tocitem" href="#Quiver-Plot"><span>Quiver Plot</span></a></li><li><a class="tocitem" href="#Streamplot"><span>Streamplot</span></a></li><li><a class="tocitem" href="#Animation"><span>Animation</span></a></li><li><a class="tocitem" href="#More"><span>More</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Appendix</a></li><li class="is-active"><a href>Plotting recipes with CairoMakie</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plotting recipes with CairoMakie</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/append/plotting.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Plotting-recipes-with-CairoMakie"><a class="docs-heading-anchor" href="#Plotting-recipes-with-CairoMakie">Plotting recipes with CairoMakie</a><a id="Plotting-recipes-with-CairoMakie-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-recipes-with-CairoMakie" title="Permalink"></a></h1><p>In this appendix, we have prepared a set of plotting scripts and simple tutorials to show how to generate different type of pictures, such as line plots, scatter plots, subplots, heatmaps, contour plots, colorbars, arrows, brackets, error bars, stream plots, and text. We will use the CairoMakie library, which is a high-performance, interactive plotting library for Julia. They could be installed by running the following command in the Julia REPL:</p><pre><code class="language-julia hljs">julia&gt; ]add CairoMakie</code></pre><h2 id="Importing"><a class="docs-heading-anchor" href="#Importing">Importing</a><a id="Importing-1"></a><a class="docs-heading-anchor-permalink" href="#Importing" title="Permalink"></a></h2><p>First, we should import CairoMakie libraries to start plotting.</p><pre><code class="language-julia hljs">julia&gt; using CairoMakie</code></pre><p>Before we start, let&#39;s introduce some basic concepts in Makie.jl:</p><ul><li><p><strong>Figure</strong>: This is the top-level container for all the elements of your visualization. It can contain multiple plots, as well as other elements like legends, colorbars, etc.</p></li><li><p><strong>Axis</strong>: This is the actual plot, where your data is visualized. An axis can contain multiple graphical elements, like lines, scatter points, surfaces, etc. It also contains the x-axis and y-axis, which have scales (linear, logarithmic, etc.) and ticks. </p></li><li><p><strong>Plots</strong>: These are the graphical representations of your data. In Makie.jl, create a plot by adding graphical elements (like lines, scatter points, etc.) to an axis. Each type of plot is suited to represent a certain kind of data.</p></li></ul><p>In the next steps, we will take a look at how we can create these objects.</p><h2 id="Line-Plot"><a class="docs-heading-anchor" href="#Line-Plot">Line Plot</a><a id="Line-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Line-Plot" title="Permalink"></a></h2><p>The following code create line plot with the CairoMakie library, including setting titles, labels, and legends.</p><pre><code class="language-julia hljs">using CairoMakie
x = range(0, 10, length=100)
fig = Figure()
# Create an axis with title and labels
ax = Axis(fig[1, 1], title = &quot;Line Plots&quot;, xlabel = &quot;X&quot;, ylabel = &quot;Y&quot;)
# Create a line plot, set color and label
lines!(ax, x, sin.(x), color = :red, label = &quot;sin&quot;)
# Add another line plot to the same axis
lines!(ax, x, cos.(x), color = :blue, label = &quot;cos&quot;)
# Add a lengend at the bottom right with label size 15
axislegend(ax; position = :rb, labelsize = 15)
save(&quot;plot_lines6.png&quot;, fig)
fig</code></pre><img src="f724f75a.png" alt="Example block output"/><h3 id="Error-Bars"><a class="docs-heading-anchor" href="#Error-Bars">Error Bars</a><a id="Error-Bars-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Bars" title="Permalink"></a></h3><p>Error bars are graphical representations used in statistics and data visualization to indicate the standard deviation of data.</p><pre><code class="language-julia hljs">using CairoMakie


fig = Figure()
ax = Axis(fig[1, 1])

xs = 0:0.5:10
ys = 0.5 .* sin.(xs)
# Define the lower and upper errors for each point.
lowerrors = fill(0.1, length(xs))
higherrors = LinRange(0.1, 0.4, length(xs))
# Add error bars to the plot, with the color ranging from 0 to 1, and the width of the whiskers set to 10.
lines!(ax, xs, ys, color = :blue)
errorbars!(ax, xs, ys, lowerrors, higherrors,
    color = range(0, 1, length = length(xs)),
    whiskerwidth = 10)

# plot position scatters so low and high errors can be discriminated
scatter!(xs, ys, markersize = 3, color = :black)

fig</code></pre><img src="ad0e073b.png" alt="Example block output"/><h3 id="Texts"><a class="docs-heading-anchor" href="#Texts">Texts</a><a id="Texts-1"></a><a class="docs-heading-anchor-permalink" href="#Texts" title="Permalink"></a></h3><p>In CairoMakie, text can be positioned at specific coordinates on the plot, aligned to different sides, and styled with different fonts, sizes, colors, and rotations.</p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure()
ax = Axis(fig[1, 1])
# Add the first line to the axis, with x ranging from 0 to 10 and y, and add a label
lines!(0..10, x -&gt; sin(3x) / (cos(x) + 2),
    label = L&quot;\frac{\sin(3x)}{\cos(x) + 2}&quot;)
# Add the second line to the axis, with x ranging from 0 to 10 and y, and add a label.
lines!(0..10, x -&gt; sin(x^2) / (cos(sqrt(x)) + 2),
    label = L&quot;\frac{\sin(x^2)}{\cos(\sqrt{x}) + 2}&quot;)
# Add a legend to the figure
Legend(fig[1, 2], ax)

fig</code></pre><img src="4b4b7782.png" alt="Example block output"/><h3 id="Bracket"><a class="docs-heading-anchor" href="#Bracket">Bracket</a><a id="Bracket-1"></a><a class="docs-heading-anchor-permalink" href="#Bracket" title="Permalink"></a></h3><p>In the context of plotting in Julia with the CairoMakie library, a bracket can be added to a plot to highlight or annotate a specific range of values.</p><pre><code class="language-julia hljs">using CairoMakie
# Create a line plot of the sine function from 0 to 9, with the x and y grid lines turned off
fig, ax, l = lines(0..9, sin; axis = (; xgridvisible = false, ygridvisible = false))
ylims!(ax, -1.5, 1.5)
# Add a bracket to highlight the period length of the sine function, from (pi/2, 1) to (5pi/2, 1), with an offset of 5, and the text &quot;Period length&quot;. The bracket style is square.
bracket!(pi/2, 1, 5pi/2, 1, offset = 5, text = &quot;Period length&quot;, style = :square)
# Add a bracket to highlight the amplitude of the sine function, with the text &quot;Amplitude&quot;. The bracket is oriented downwards, and the text is aligned to the right and centered vertically.
bracket!(pi/2, 1, pi/2, -1, text = &quot;Amplitude&quot;, orientation = :down,
    linestyle = :dash, rotation = 0, align = (:right, :center), textoffset = 4, linewidth = 2, color = :red, textcolor = :red)
# Add a bracket to highlight a falling portion of the sine function, from (2.3, sin(2.3)) to (4.0, sin(4.0)), with the text &quot;Falling&quot;. The bracket is oriented upwards.
bracket!(2.3, sin(2.3), 4.0, sin(4.0),
    text = &quot;Falling&quot;, offset = 10, orientation = :up, color = :purple, textcolor = :purple)
# Add a bracket to highlight a rising portion of the sine function, from (5.5, sin(5.5)) to (7.0, sin(7.0)), with the text &quot;Rising&quot;. The bracket is oriented downwards.
bracket!(Point(5.5, sin(5.5)), Point(7.0, sin(7.0)),
    text = &quot;Rising&quot;, offset = 10, orientation = :down, color = :orange, textcolor = :orange,
    fontsize = 30, textoffset = 30, width = 50)
fig</code></pre><img src="b6fecb73.png" alt="Example block output"/><h3 id="Subplots"><a class="docs-heading-anchor" href="#Subplots">Subplots</a><a id="Subplots-1"></a><a class="docs-heading-anchor-permalink" href="#Subplots" title="Permalink"></a></h3><p>Subplots are a way to display multiple plots in different sub-regions of the same window. The following code demonstrates how to create multiple subplots using the CairoMakie library. It will generate a figure with three line plots, each representing the sin function, but with different colors (red, blue, and green).</p><pre><code class="language-julia hljs">using CairoMakie
x = LinRange(0, 10, 100)
y = sin.(x)
fig = Figure()
# Create an axis with title and labels
ax1 = Axis(fig[1, 1], title = &quot;Red Sin Plot&quot;, xlabel = &quot;X&quot;, ylabel = &quot;Y&quot;)
lines!(ax1, x, y, color = :red, label = &quot;sin&quot;)
ax2 = Axis(fig[1, 2], title = &quot;Blue Sin Plot&quot;, xlabel = &quot;X&quot;, ylabel = &quot;Y&quot;)
lines!(ax2, x, y, color = :blue, label = &quot;sin&quot;)
# Create a third axis spanning the first two positions of the second row of the figure, set the title, x-axis label, and y-axis label
ax3 = Axis(fig[2, 1:2], title = &quot;Green Sin Plot&quot;, xlabel = &quot;X&quot;, ylabel = &quot;Y&quot;)
lines!(ax3, x, y, color = :green, label = &quot;sin&quot;)

fig</code></pre><img src="f08f75e5.png" alt="Example block output"/><h2 id="Scatter-Plot"><a class="docs-heading-anchor" href="#Scatter-Plot">Scatter Plot</a><a id="Scatter-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Scatter-Plot" title="Permalink"></a></h2><p>A scatter plot is a type of plot used to display the relationship between two variables, where each point represents an observation. The following code will generate a figure with two scatter plots, one representing the sin function and the other representing the cos function.</p><pre><code class="language-julia hljs">using CairoMakie

x = range(0, 10, length=100)
fig = Figure()

# Create an axis at the first position of the figure, set the title, x-axis label, and y-axis label
ax = Axis(fig[1, 1], title = &quot;Scatter Plots&quot;, xlabel = &quot;X&quot;, ylabel = &quot;Y&quot;)

# Create a scatter plot on the axis, set the color to red, marker size to 5, and label to &quot;sin&quot;
scatter!(ax, x, sin.(x), color = :red, markersize = 5, label = &quot;sin&quot;)

# Add another scatter plot to the same axis, set the color to blue, marker size to 10, and label to &quot;cos&quot;
scatter!(ax, x, cos.(x), color = :blue, markersize = 10, label = &quot;cos&quot;)

# Set the legend for the axis, position it at the bottom right, and set the label size to 15
axislegend(ax; position = :rb, labelsize = 15)

fig</code></pre><img src="87c637b8.png" alt="Example block output"/><h2 id="Bar-plot"><a class="docs-heading-anchor" href="#Bar-plot">Bar plot</a><a id="Bar-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Bar-plot" title="Permalink"></a></h2><p>A bar plot is a type of plot used to visualize categorical data. It consists of rectangular bars with lengths proportional to the values they represent. Bar plots are commonly used to compare the values of different categories or groups.</p><p>The following code demonstrates how to create a bar plot using the CairoMakie library. It will generate a figure with a bar plot.</p><pre><code class="language-julia hljs">using CairoMakie
# Generate a color palette
colors = Makie.wong_colors()
# Define the data for the bar plot
tbl = (cat = [1, 1, 1, 2, 2, 2, 3, 3, 3],
       height = 0.1:0.1:0.9,
       grp = [1, 2, 3, 1, 2, 3, 1, 2, 3],
       grp1 = [1, 2, 2, 1, 1, 2, 1, 1, 2],
       grp2 = [1, 1, 2, 1, 2, 1, 1, 2, 1]
       )

# Figure and Axis
fig = Figure()
ax = Axis(fig[1,1], xticks = (1:3, [&quot;left&quot;, &quot;middle&quot;, &quot;right&quot;]),
        title = &quot;Dodged bars with legend&quot;)

# Plot
barplot!(ax, tbl.cat, tbl.height,
        dodge = tbl.grp,
        color = colors[tbl.grp])

# Define the labels for the legend
labels = [&quot;group 1&quot;, &quot;group 2&quot;, &quot;group 3&quot;]
# # Create the elements for the legend with custom colors
elements = [PolyElement(polycolor = colors[i]) for i in 1:length(labels)]
title = &quot;Groups&quot;

Legend(fig[1,2], elements, labels, title)

fig</code></pre><img src="1e2d1651.png" alt="Example block output"/><h2 id="Heatmap"><a class="docs-heading-anchor" href="#Heatmap">Heatmap</a><a id="Heatmap-1"></a><a class="docs-heading-anchor-permalink" href="#Heatmap" title="Permalink"></a></h2><p>A heatmap is a graphical representation of data where individual values contained in a matrix are represented as colors. It is a way of visualizing data density or intensity, making it easier to perceive patterns, trends, and outliers within large data sets.</p><p>This following code is using CairoMakie to create a heatmap of the Mandelbrot set. The Mandelbrot set is a set of complex numbers for which the function <span>$f(c) = z^2 + c$</span> does not diverge when iterated from z = 0.</p><pre><code class="language-julia hljs">using CairoMakie
fig = Figure()
# Create an axis with title and labels
ax = Axis(fig[1, 1], title = &quot;Heatmap&quot;, xlabel = &quot;X&quot;, ylabel = &quot;Y&quot;)
# The Mandelbrot function
function mandelbrot(x, y)
    z = c = x + y*im
    for i in 1:30.0; abs(z) &gt; 2 &amp;&amp; return i; z = z^2 + c; end; 0
end

hm = heatmap!(ax, -2:0.001:1, -1.1:0.001:1.1, mandelbrot,
    colormap = Reverse(:deep))

# Add a colorbar to the right of the heatmap with the label &quot;Color scale&quot;
Colorbar(fig[1, 2], hm, label = &quot;Color scale&quot;)
fig</code></pre><img src="c11da5ef.png" alt="Example block output"/><h2 id="Contour-Plot"><a class="docs-heading-anchor" href="#Contour-Plot">Contour Plot</a><a id="Contour-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Contour-Plot" title="Permalink"></a></h2><p>A contour plot is a graphical technique used to represent a 3-dimensional surface in two dimensions. It is like a topographical map in which x and y show the location, and the contour lines represent the third dimension (z) by their level.</p><p>Each contour line in a contour plot represents a set of points at the same height or value. The contour plot provides a way to visualize the relationship between three continuous variables. The color or the line style often indicates the value of the third variable. The following code demonstrates how to create a contour plot using the CairoMakie library.</p><pre><code class="language-julia hljs">using CairoMakie
# Define the Himmelblau function
himmelblau(x, y) = (x^2 + y - 11)^2 + (x + y^2 - 7)^2
x = y = range(-6, 6; length=100)
# Calculate z-values as the Himmelblau function for each combination of x and y
z = himmelblau.(x, y&#39;)
# Define the contour levels as powers of 10 from 0.3 to 3.5
levels = 10.0.^range(0.3, 3.5; length=10)
colorscale = ReversibleScale(x -&gt; x^(1 / 10), x -&gt; x^10)
# Create a contour plot of the z-values, with labels, levels, a hsv colormap, and the defined color scale.

fig = Figure()
ax = Axis(fig[1, 1])

ct = contour!(ax, x, y, z; labels=true, levels, colormap=:hsv, colorscale)
fig</code></pre><img src="86cdc9ed.png" alt="Example block output"/><h3 id="3D-Contour-Plot"><a class="docs-heading-anchor" href="#3D-Contour-Plot">3D Contour Plot</a><a id="3D-Contour-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Contour-Plot" title="Permalink"></a></h3><pre><code class="language-julia hljs">using CairoMakie

fig = Figure()
# Create a 3D axis at the first position of the figure, set the aspect ratio and perspective
Axis3(fig[1, 1], aspect=(0.5,0.5,1), perspectiveness=0.75)
# Create a linear range of numbers from -0.5 to 0.5, with 100 steps for x and y axes
xs = ys = LinRange(-0.5, 0.5, 100)
zs = [sqrt(x^2+y^2) for x in xs, y in ys]
# Create a 3D contour plot of the negative z-values
contour3d!(-zs, levels=-(.025:0.05:.475), linewidth=2, color=:blue2)
contour3d!(+zs, levels=  .025:0.05:.475,  linewidth=2, color=:red2)

fig</code></pre><img src="0756228f.png" alt="Example block output"/><h2 id="Surface-plot"><a class="docs-heading-anchor" href="#Surface-plot">Surface plot</a><a id="Surface-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Surface-plot" title="Permalink"></a></h2><p>In Makie.jl, a surface plot is a three-dimensional plot that displays a surface defined by a grid of x, y, and z values. It&#39;s used to visualize data that changes over two independent variables, much like a topographical map or a view of a landscape.</p><pre><code class="language-julia hljs">using CairoMakie
xs = LinRange(0, 10, 100)
ys = LinRange(0, 15, 100)
zs = [cos(x) * sin(y) for x in xs, y in ys]

surface(xs, ys, zs, axis=(type=Axis3,))</code></pre><img src="f5130449.png" alt="Example block output"/><h2 id="Colorbar-of-heatmap/contour"><a class="docs-heading-anchor" href="#Colorbar-of-heatmap/contour">Colorbar of heatmap/contour</a><a id="Colorbar-of-heatmap/contour-1"></a><a class="docs-heading-anchor-permalink" href="#Colorbar-of-heatmap/contour" title="Permalink"></a></h2><p>This Julia code demonstrates how to create heatmaps and contour plots with colorbars using CairoMakie. It first defines a range of x and y values and calculates a corresponding z value for each (x, y) pair. It then creates four subplots: two heatmaps and two contour plots, each with different color maps and level settings. A colorbar is added to each subplot for reference. The <code>heatmap</code>, <code>contourf</code>, and <code>Colorbar</code> functions are used to create the plots and colorbars.</p><pre><code class="language-julia hljs">using CairoMakie

xs = LinRange(0, 20, 50)
ys = LinRange(0, 15, 50)
# Calculate z-values
zs = [cos(x) * sin(y) for x in xs, y in ys]

fig = Figure()
# Create a heatmap at the first position of the figure and add a colorbar
ax, hm = heatmap(fig[1, 1][1, 1], xs, ys, zs)
Colorbar(fig[1, 1][1, 2], hm)
# Create a second heatmap at the second position of the figure with a grayscale colormap
ax, hm = heatmap(fig[1, 2][1, 1], xs, ys, zs, colormap = :grays,
    colorrange = (-0.75, 0.75), highclip = :red, lowclip = :blue)
Colorbar(fig[1, 2][1, 2], hm)
# Create a filled contour plot at the third position of the figure
ax, hm = contourf(fig[2, 1][1, 1], xs, ys, zs,
    levels = -1:0.25:1, colormap = :heat)
Colorbar(fig[2, 1][1, 2], hm, ticks = -1:0.25:1)
# Create a second filled contour plot
ax, hm = contourf(fig[2, 2][1, 1], xs, ys, zs,
    colormap = :Spectral, levels = [-1, -0.5, -0.25, 0, 0.25, 0.5, 1])
Colorbar(fig[2, 2][1, 2], hm, ticks = -1:0.25:1)

fig</code></pre><img src="d8f5814e.png" alt="Example block output"/><h2 id="Quiver-Plot"><a class="docs-heading-anchor" href="#Quiver-Plot">Quiver Plot</a><a id="Quiver-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#Quiver-Plot" title="Permalink"></a></h2><p>An arrow plot, also known as a quiver plot, is a type of plot that displays vector fields. This means it shows the direction and magnitude (strength) of data at different points in space. In these plots, each arrow represents a vector and points in the direction the vector is heading. The length (or color) of the arrow can also represent the magnitude of the vector.</p><p>The following examples demonstrate how to create 2D and 3D arrows using the CairoMakie library. </p><pre><code class="language-julia hljs">using CairoMakie

fig = Figure(size = (800, 800))
Axis(fig[1, 1], backgroundcolor = &quot;black&quot;)

xs = LinRange(0, 2pi, 20)
ys = LinRange(0, 3pi, 20)
# Calculate the u-component of the vectors as the sine of x times the cosine of y for each combination of x and y
us = [sin(x) * cos(y) for x in xs, y in ys]
# Calculate the v-component of the vectors as the negative cosine of x times the sine of y for each combination of x and y
vs = [-cos(x) * sin(y) for x in xs, y in ys]
# Calculate the strength (magnitude) of each vector as the square root of the sum of squares of its u and v components
strength = vec(sqrt.(us .^ 2 .+ vs .^ 2))
# Create a quiver plot with the calculated vectors, specified arrow size and length scale, and color the arrows based on their strength
arrows!(xs, ys, us, vs, arrowsize = 10, lengthscale = 0.3,
    arrowcolor = strength, linecolor = strength)

fig</code></pre><img src="a049e2da.png" alt="Example block output"/><h3 id="3D-Quiver-Plot"><a class="docs-heading-anchor" href="#3D-Quiver-Plot">3D Quiver Plot</a><a id="3D-Quiver-Plot-1"></a><a class="docs-heading-anchor-permalink" href="#3D-Quiver-Plot" title="Permalink"></a></h3><pre><code class="language-julia hljs">using CairoMakie
using LinearAlgebra

# Create a list of 3D points from -5 to 5 in steps of 2 for x, y, and z coordinates
ps = [Point3f(x, y, z) for x in -5:2:5 for y in -5:2:5 for z in -5:2:5]
# Calculate the direction vectors for each point by swapping the coordinates and scaling by 0.1
ns = map(p -&gt; 0.1 * Vec3f(p[2], p[3], p[1]), ps)
# Calculate the length (norm) of each direction vector
lengths = norm.(ns)
# Create a quiver plot with the calculated points and vectors, turn on anti-aliasing,color the arrows based on their length
# Specify the line width and arrow size, align the arrows at the center, and create a 3D axis
arrows(
    ps, ns, fxaa=true, # turn on anti-aliasing
    color=lengths,
    linewidth = 0.1, arrowsize = Vec3f(0.3, 0.3, 0.4),
    align = :center, axis=(type=Axis3,)
)</code></pre><img src="82644e39.png" alt="Example block output"/><h2 id="Streamplot"><a class="docs-heading-anchor" href="#Streamplot">Streamplot</a><a id="Streamplot-1"></a><a class="docs-heading-anchor-permalink" href="#Streamplot" title="Permalink"></a></h2><p>A streamplot is a type of plot used in fluid dynamics to visualize the flow of a fluid. It shows the direction and magnitude of the flow at different points in space. In a streamplot, the flow is represented by a series of lines that follow the direction of the flow. The density of the lines indicates the speed of the flow, with denser lines indicating faster flow.</p><pre><code class="language-julia hljs">using CairoMakie

# Define a struct to represent the Fitzhugh-Nagumo model, with parameters ϵ, s, γ, and β
struct FitzhughNagumo{T}
    ϵ::T
    s::T
    γ::T
    β::T
end
# Create an instance of the FitzhughNagumo struct with specific parameter values
P = FitzhughNagumo(0.1, 0.0, 1.5, 0.8)
# Define a function to represent the Fitzhugh-Nagumo model
f(x, P::FitzhughNagumo) = Point2f(
    (x[1]-x[2]-x[1]^3+P.s)/P.ϵ,
    P.γ*x[1]-x[2] + P.β
)
# Define a function to represent the Fitzhugh-Nagumo model with the specific parameter values
f(x) = f(x, P)
# Create a streamplot of the Fitzhugh-Nagumo model in both x and y directions, with the magma colormap
fig, ax, pl = streamplot(f, -1.5..1.5, -1.5..1.5, colormap = :magma)
# Add another streamplot to the figure, with the color set to a function that returns an RGBA color with the alpha channel set to 1
streamplot(fig[1,2], f, -1.5 .. 1.5, -1.5 .. 1.5, color=(p)-&gt; RGBAf(p..., 0.0, 1))
fig</code></pre><img src="31e12a4f.png" alt="Example block output"/><h2 id="Animation"><a class="docs-heading-anchor" href="#Animation">Animation</a><a id="Animation-1"></a><a class="docs-heading-anchor-permalink" href="#Animation" title="Permalink"></a></h2><p>In Makie.jl, animation is a feature that allows you to create a sequence of frames, each of which is a different plot, and then combine them into a single animated file. This is useful for visualizing changes in data over time or the progression of an algorithm.</p><pre><code class="language-julia hljs">using CairoMakie
using CairoMakie.Colors

fig, ax, lineplot = lines(0..10, sin; linewidth=10)

# animation settings
nframes = 30
framerate = 30
# Create an iterator for the hue values that will be used to change the color of the line
hue_iterator = range(0, 360, length=nframes)
# Start recording the animation
record(fig, &quot;color_animation.mp4&quot;, hue_iterator;
        framerate = framerate) do hue
    lineplot.color = HSV(hue, 1, 0.75)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;color_animation.mp4&quot;</code></pre><p><img src="../../assets/images/color_animation.gif" alt/></p><h3 id="Animation-using-Observables"><a class="docs-heading-anchor" href="#Animation-using-Observables">Animation using <code>Observables</code></a><a id="Animation-using-Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Animation-using-Observables" title="Permalink"></a></h3><p>Often, you want to animate a complex plot over time, and all the data that is displayed should be determined by the current time stamp. Such a dependency is really easy to express with <code>Observables</code>.</p><p>We can save a lot of work if we create our data depending on a single time <code>Observable</code>, so we don&#39;t have to change every plot&#39;s data manually as the animation progresses.</p><p>Here is an example that plots two different functions. The y-values of each depend on time and therefore we only have to change the time for both plots to change. We use the convenient <code>@lift</code> macro which denotes that the <code>lifted</code> expression depends on each Observable marked with a <code>$</code>sign.</p><pre><code class="language-julia hljs">using CairoMakie
time = Observable(0.0)

xs = range(0, 7, length=40)

ys_1 = @lift(sin.(xs .- $time))
ys_2 = @lift(cos.(xs .- $time) .+ 3)
# Create a line plot for the sine wave with a dynamic title
fig = lines(xs, ys_1, color = :blue, linewidth = 4,
    axis = (title = @lift(&quot;t = $(round($time, digits = 1))&quot;),))
# Add a scatter plot for the cosine wave to the same figure
scatter!(xs, ys_2, color = :red, markersize = 15)
# Set the framerate and the timestamps for the animation
framerate = 10
timestamps = range(0, 2, step=1/framerate)
# Start recording the animation
record(fig, &quot;time_animation.gif&quot;, timestamps;
        framerate = framerate) do t
    time[] = t
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;time_animation.gif&quot;</code></pre><p><img src="../../assets/images/time_animation.gif" alt/></p><h2 id="More"><a class="docs-heading-anchor" href="#More">More</a><a id="More-1"></a><a class="docs-heading-anchor-permalink" href="#More" title="Permalink"></a></h2><p>For more information on plotting with Makie, please refer to the <a href="https://docs.makie.org/stable/">official documentation</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../chap5/montecarlo/">« Markov Chain Monte Carlo</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 2 April 2024 04:08">Tuesday 2 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
