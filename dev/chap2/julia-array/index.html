<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Array and Broadcasting Â· Scientific Computing For Physicists</title><meta name="title" content="Array and Broadcasting Â· Scientific Computing For Physicists"/><meta property="og:title" content="Array and Broadcasting Â· Scientific Computing For Physicists"/><meta property="twitter:title" content="Array and Broadcasting Â· Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap2/julia-array/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap2/julia-array/"/><link rel="canonical" href="https://book.jinguo-group.science/chap2/julia-array/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../julia-type/">Types and Multiple-dispatch</a></li><li class="is-active"><a class="tocitem" href>Array and Broadcasting</a><ul class="internal"><li><a class="tocitem" href="#Array-indexing-and-broadcasting"><span>Array indexing and broadcasting</span></a></li><li><a class="tocitem" href="#Julia-array-is-column-major"><span>Julia array is column-major</span></a></li><li><a class="tocitem" href="#Benchmark:-matrix-multiplication"><span>Benchmark: matrix multiplication</span></a></li></ul></li><li><a class="tocitem" href="../julia-release/">My First Package</a></li><li><a class="tocitem" href="../julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../chap3/linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../../chap3/lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/qr/">QR Factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../chap3/tensors/">Tensor Operations</a></li><li><a class="tocitem" href="../../chap3/cuda/">Arrays on GPU</a></li><li><a class="tocitem" href="../../chap3/sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Randomness</span><ul><li><a class="tocitem" href="../../chap5/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Julia Programming Language</a></li><li class="is-active"><a href>Array and Broadcasting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Array and Broadcasting</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap2/julia-array.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Array-and-Broadcasting"><a class="docs-heading-anchor" href="#Array-and-Broadcasting">Array and Broadcasting</a><a id="Array-and-Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Array-and-Broadcasting" title="Permalink"></a></h1><h2 id="Array-indexing-and-broadcasting"><a class="docs-heading-anchor" href="#Array-indexing-and-broadcasting">Array indexing and broadcasting</a><a id="Array-indexing-and-broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Array-indexing-and-broadcasting" title="Permalink"></a></h2><p>Julia array can be <strong>initialized</strong> with multiple ways.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1, 2, 3]; # a vector</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = [1 2 3; 4 5 6; 7 8 9];  # a matrix</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; zero_vector = zeros(3); # zero vector</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rand_vector = randn(Float32, 3, 3); # random normal distribution</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; step_vector = collect(1:3);  # collect from a range</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; uninitialized_vector = Vector{Int}(undef, 3); # uninitialized vector of size 3</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Julia array <strong>indexing</strong> starts from 1, which is different from C, Python, and R. ğŸ˜</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1, 2, 3];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[1]     # the first element</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[end]   # the last element</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[1:2]   # the first two elements</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[2:-1:1] # the first two elements in the reversed order</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 2
 1</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = [1 2 3; 4 5 6; 7 8 9];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B[1:2]   # the first two elements, returns B[1,1] and B[2,1] since B is column-major</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B[1:2, 1:2] # returns a submatrix</code><code class="nohighlight hljs ansi" style="display:block;">2Ã—2 Matrix{Int64}:
 1  2
 4  5</code></pre><p>Julia has a powerful <strong>broadcasting</strong> mechanism. It is a way to apply a function to each element of an array. The broadcasting is done by adding a dot <code>.</code> before the function name.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 0:0.1Ï€:2Ï€</code><code class="nohighlight hljs ansi" style="display:block;">0.0:0.3141592653589793:6.283185307179586</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; y = sin.(x) .+ cos.(3 .* x);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>The broadcasting also does the <strong>loop fusion</strong>, which means only one loop is used to iterate over the elements of the array and no intermediate array is created. This is often more efficient than the step-by-step loop.</p><p>We can use <code>Ref</code> to protect an object from being broadcasted.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ref([3,2,1,0]) .* (1:3)</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Vector{Int64}}:
 [3, 2, 1, 0]
 [6, 4, 2, 0]
 [9, 6, 3, 0]</code></pre><p>We can see the vector is treated as a whole.</p><h2 id="Julia-array-is-column-major"><a class="docs-heading-anchor" href="#Julia-array-is-column-major">Julia array is column-major</a><a id="Julia-array-is-column-major-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-array-is-column-major" title="Permalink"></a></h2><p>In Julia, arrays are stored in <strong>column-major</strong> order. This may affect the performance of the code.</p><img src="../../assets/images/colmajor.png" alt="column-major" width="200"/><p>For example, we can implement the Frobenius norm of a matrix as follows.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function frobenius_norm(A::AbstractMatrix)
           s = zero(eltype(A))
           # the `@inbounds` macro tells the compiler that the loop is safe and it can skip the boundary check.
           @inbounds for i in 1:size(A, 1)
               for j in 1:size(A, 2)
                   s += A[i, j]^2
               end
           end
           return sqrt(s)
       end</code><code class="nohighlight hljs ansi" style="display:block;">frobenius_norm (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = randn(1000, 1000);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; frobenius_norm(A)</code><code class="nohighlight hljs ansi" style="display:block;">1000.0152494162214</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using BenchmarkTools

julia&gt; @benchmark frobenius_norm($A)
BenchmarkTools.Trial: 25 samples with 1 evaluation.
 Range (min â€¦ max):  203.310 ms â€¦ 214.439 ms  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     204.769 ms               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   205.331 ms Â±   2.247 ms  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ƒ   â–ƒâ–ƒâ–ˆâ–ˆâ–ˆâ–ƒ â–ƒ                                                   
  â–ˆâ–â–‡â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–ˆâ–â–â–‡â–â–â–â–â–â–â–‡â–â–â–â–â–â–â–â–â–â–â–‡â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–‡ â–
  203 ms           Histogram: frequency by time          214 ms &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>Alternatively, we can loop over the second index first.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function frobenius_norm_colmajor(A::AbstractMatrix)
           s = zero(eltype(A))
           @inbounds for j in 1:size(A, 2)
               for i in 1:size(A, 1)
                   s += A[i, j]^2
               end
           end
           return sqrt(s)
       end</code><code class="nohighlight hljs ansi" style="display:block;">frobenius_norm_colmajor (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @benchmark frobenius_norm_colmajor($A)
BenchmarkTools.Trial: 53 samples with 1 evaluation.
 Range (min â€¦ max):  90.380 ms â€¦ 133.823 ms  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     92.729 ms               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   94.415 ms Â±   6.425 ms  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

      â–‚ â–‚â–ˆ â–„   â–‚                                                
  â–†â–ˆâ–ˆâ–„â–ˆâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–†â–†â–„â–ˆâ–„â–â–â–â–â–„â–„â–„â–â–â–â–â–â–â–â–â–â–„â–â–â–â–„â–â–â–â–â–„â–â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„ â–
  90.4 ms         Histogram: frequency by time          108 ms &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><p>We can see by simply changing the order of the loop, the performance is improved by more than 2 times. This is because the memory access pattern is more cache-friendly.</p><h3 id="Example:-create-a-meshgrid-for-triangular-lattice"><a class="docs-heading-anchor" href="#Example:-create-a-meshgrid-for-triangular-lattice">Example: create a meshgrid for triangular lattice</a><a id="Example:-create-a-meshgrid-for-triangular-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-create-a-meshgrid-for-triangular-lattice" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; b1 = [1, 0]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Int64}:
 1
 0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b2 = [0.5, sqrt(3)/2]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.5
 0.8660254037844386</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = 5</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mesh1 = [i * b1 + j * b2 for i in 1:n, j in 1:n]  # list comprehension</code><code class="nohighlight hljs ansi" style="display:block;">5Ã—5 Matrix{Vector{Float64}}:
 [1.5, 0.866025]  [2.0, 1.73205]  â€¦  [3.0, 3.4641]  [3.5, 4.33013]
 [2.5, 0.866025]  [3.0, 1.73205]     [4.0, 3.4641]  [4.5, 4.33013]
 [3.5, 0.866025]  [4.0, 1.73205]     [5.0, 3.4641]  [5.5, 4.33013]
 [4.5, 0.866025]  [5.0, 1.73205]     [6.0, 3.4641]  [6.5, 4.33013]
 [5.5, 0.866025]  [6.0, 1.73205]     [7.0, 3.4641]  [7.5, 4.33013]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mesh2= (1:n) .* Ref(b1) .+ (1:n)&#39; .* Ref(b2)  # broadcasting</code><code class="nohighlight hljs ansi" style="display:block;">5Ã—5 Matrix{Vector{Float64}}:
 [1.5, 0.866025]  [2.0, 1.73205]  â€¦  [3.0, 3.4641]  [3.5, 4.33013]
 [2.5, 0.866025]  [3.0, 1.73205]     [4.0, 3.4641]  [4.5, 4.33013]
 [3.5, 0.866025]  [4.0, 1.73205]     [5.0, 3.4641]  [5.5, 4.33013]
 [4.5, 0.866025]  [5.0, 1.73205]     [6.0, 3.4641]  [6.5, 4.33013]
 [5.5, 0.866025]  [6.0, 1.73205]     [7.0, 3.4641]  [7.5, 4.33013]</code></pre><pre><code class="language-julia hljs">using CairoMakie

scatter(vec(getindex.(mesh2, 1)), vec(getindex.(mesh2, 2)), label=&quot;mesh2&quot;, ratio=1, markersize=10)</code></pre><img src="4f7cc16e.png" alt="Example block output"/><h2 id="Benchmark:-matrix-multiplication"><a class="docs-heading-anchor" href="#Benchmark:-matrix-multiplication">Benchmark: matrix multiplication</a><a id="Benchmark:-matrix-multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark:-matrix-multiplication" title="Permalink"></a></h2><p>Matrix multiplication is a fundamental operation in scientific computing. Julia&#39;s built-in <code>*</code> operator is backed by highly optimized BLAS libraries. Let&#39;s benchmark the performance of matrix multiplication.</p><pre><code class="language-julia-repl hljs">julia&gt; @benchmark $A * $B
BenchmarkTools.Trial: 383 samples with 1 evaluation.
 Range (min â€¦ max):  12.089 ms â€¦ 38.311 ms  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     12.873 ms              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   13.052 ms Â±  1.418 ms  â”Š GC (mean Â± Ïƒ):  1.20% Â± 3.41%

       â–„â–†â–… â–‚â–„â–‡â–ˆâ–‡â–…â–…â–„                                            
  â–†â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–†â–â–„â–â–â–„â–â–„â–â–†â–†â–‡â–„â–‡â–„â–‡â–ˆâ–‡â–‡â–â–â–‡â–â–†â–â–†â–„â–â–„â–â–â–â–â–â–â–â–â–â–â–â–„ â–‡
  12.1 ms      Histogram: log(frequency) by time      15.8 ms &lt;

 Memory estimate: 7.63 MiB, allocs estimate: 2.</code></pre><p>The performance of a CPU is measured by the number of <strong>floating point operations per second</strong> (FLOPS) it can perform. The floating point operations include addition, subtraction, multiplication and division. The FLOPS can be related to multiple factors, such as the clock frequency, the number of cores, the number of instructions per cycle, and the number of floating point units. A simple way to measure the FLOPS is to benchmarking the speed of matrix multiplication. The number of FLOPS in a <span>$n\times n\times n$</span> matrix multiplication is <span>$2n^3$</span>. The FLOPS can be calculated as: <span>$2 \times 1000^3 / (12.089 \times 10^{-3}) \approx 165~{\rm GFLOPS}$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../julia-type/">Â« Types and Multiple-dispatch</a><a class="docs-footer-nextpage" href="../julia-release/">My First Package Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 31 March 2024 13:55">Sunday 31 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
