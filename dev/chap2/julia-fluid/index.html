<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Project: Fluid dynamics · Scientific Computing For Physicists</title><meta name="title" content="Project: Fluid dynamics · Scientific Computing For Physicists"/><meta property="og:title" content="Project: Fluid dynamics · Scientific Computing For Physicists"/><meta property="twitter:title" content="Project: Fluid dynamics · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap2/julia-fluid/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap2/julia-fluid/"/><link rel="canonical" href="https://book.jinguo-group.science/chap2/julia-fluid/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../julia-release/">My First Package</a></li><li class="is-active"><a class="tocitem" href>Project: Fluid dynamics</a><ul class="internal"><li><a class="tocitem" href="#Fluid-Dynamics-Simulation"><span>Fluid Dynamics Simulation</span></a></li><li><a class="tocitem" href="#D2Q9-model"><span>D2Q9 model</span></a></li><li><a class="tocitem" href="#Julia-implementation"><span>Julia implementation</span></a></li></ul></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../chap3/linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../../chap3/lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/qr/">QR Factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../chap3/tensors/">Tensor Operations</a></li><li><a class="tocitem" href="../../chap3/cuda/">Arrays on GPU</a></li></ul></li><li><span class="tocitem">Optimization (×)</span><ul><li><a class="tocitem" href="../../chap4/combinatorial/">Combinatorial Optimization</a></li><li><a class="tocitem" href="../../chap4/optimization/">Optimization</a></li><li><a class="tocitem" href="../../chap4/ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Randomness (×)</span><ul><li><a class="tocitem" href="../../chap5/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Sparsity (×)</span><ul><li><a class="tocitem" href="../../chap6/sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../../chap6/compressedsensing/">Compressed sensing</a></li></ul></li><li><span class="tocitem">High Performance Computing (×)</span><ul><li><a class="tocitem" href="../../chap7/hpc/">MPI and OpenMP</a></li><li><a class="tocitem" href="../../chap7/cuda/">CUDA programming</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Julia Programming Language</a></li><li class="is-active"><a href>Project: Fluid dynamics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Project: Fluid dynamics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap2/julia-fluid.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Project:-Fluid-dynamics"><a class="docs-heading-anchor" href="#Project:-Fluid-dynamics">Project: Fluid dynamics</a><a id="Project:-Fluid-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Project:-Fluid-dynamics" title="Permalink"></a></h1><h2 id="Fluid-Dynamics-Simulation"><a class="docs-heading-anchor" href="#Fluid-Dynamics-Simulation">Fluid Dynamics Simulation</a><a id="Fluid-Dynamics-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Fluid-Dynamics-Simulation" title="Permalink"></a></h2><p>Fluid dynamics is the study of the movement of fluids, including air and water. In this project, we will use the Lattice Boltzmann Method (LBM) to simulate fluid dynamics, which is a mesoscopic method based on the kinetic theory of gases.</p><table><tr><th style="text-align: right"></th><th style="text-align: right">micro</th><th style="text-align: right">meso</th><th style="text-align: right">macro</th></tr><tr><td style="text-align: right"><strong>Scale</strong></td><td style="text-align: right"><span>$10^{-9}$</span>m</td><td style="text-align: right"><span>$10^{-9} -10^{-6}$</span>m</td><td style="text-align: right"><span>$&gt;10^{6}$</span>m</td></tr><tr><td style="text-align: right"><strong>Physics</strong></td><td style="text-align: right">molecular</td><td style="text-align: right">probabilistic</td><td style="text-align: right">continuous</td></tr><tr><td style="text-align: right"><strong>Gov. Eq.</strong></td><td style="text-align: right">Newton</td><td style="text-align: right">Boltzmann</td><td style="text-align: right">Navier-Stokes equations</td></tr><tr><td style="text-align: right"><strong>Method</strong></td><td style="text-align: right">Molecular Dynamics</td><td style="text-align: right">Lattice Boltzmann</td><td style="text-align: right">Computational Fluid Dynamics</td></tr></table><p>This book does not aim to provide a comprehensive understanding of fluid dynamics. If you are interested in learning more about fluid dynamics, you can refer to the following resources:</p><ul><li><p><a href="https://physics.weber.edu/schroeder/fluids/">Fluid Dynamics Simulation (in Python, Java and Javascript)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=jfk4feD7rFQ">YouTube - Introduction to Lattice Boltzmann Method</a></p></li></ul><h3 id="Lattice-Boltzmann-Method-(LBM)"><a class="docs-heading-anchor" href="#Lattice-Boltzmann-Method-(LBM)">Lattice Boltzmann Method (LBM)</a><a id="Lattice-Boltzmann-Method-(LBM)-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-Boltzmann-Method-(LBM)" title="Permalink"></a></h3><p>The general idea of LBM is to simulate the fluid dynamics by modeling the movement of particles in a lattice, a grid of cells, without keeping track of the individual particles. The state of a cell in the lattice is defined by the density of particles moving in different directions, i.e. </p><p class="math-container">\[{\rm state}(i, j) \equiv \rho_{ij}(\mathbf{v})\]</p><p>where <span>$(i, j)$</span> is the position of the cell in the lattice and <span>$\mathbf{v}$</span> is the velocity of the particles.</p><img src="../../assets/images/lattice.png" alt="image" width=300 height="auto"><p>The particles move with different velocities <span>$\mathbf v$</span> and collide with each other, driving the fluid to reach an equilibrium state, where the energy of the particles is governed by the Boltzmann distribution</p><p class="math-container">\[\rho_{\rm eq}(E) \sim e^{-\frac{E}{k_BT}} ({\rm or }\; e^{- {\rm const.} \times |\mathbf{v}|^2}),\]</p><p>where <span>$k_B$</span> is the Boltzmann constant, <span>$T$</span> is the temperature, and <span>$E = \frac{1}{2}m|\mathbf{v}|^2$</span> is the energy of the particles.</p><h2 id="D2Q9-model"><a class="docs-heading-anchor" href="#D2Q9-model">D2Q9 model</a><a id="D2Q9-model-1"></a><a class="docs-heading-anchor-permalink" href="#D2Q9-model" title="Permalink"></a></h2><p>The lattice Boltzmann method uses a discrete set of velocities, which is a simplification of the continuous velocity space. One of the simplest models is the D2Q9 model, which contains</p><ul><li>a 2D lattice, and</li><li>9 discrete velocities: <span>$(0,0)$</span>, <span>$(1,0), (0,1), (-1,0), (0,-1)$</span>, <span>$(1,1), (-1,1), (-1,-1), (1,-1)$</span>.</li></ul><img src="../../assets/images/D2Q9.png" alt="image" width=500 height="auto"><p>Lattice Boltzmann Method (LBM) contains two steps:</p><ol><li>Streaming - particles move to neighboring cells</li><li>Collision - particles collide and exchange momentum</li></ol><h3 id="Streaming"><a class="docs-heading-anchor" href="#Streaming">Streaming</a><a id="Streaming-1"></a><a class="docs-heading-anchor-permalink" href="#Streaming" title="Permalink"></a></h3><img src="../../assets/images/stream.png" alt="image" width=500 height="auto"><h3 id="Collision-Bhatnagar-Gross-Krook-(BGK)-model."><a class="docs-heading-anchor" href="#Collision-Bhatnagar-Gross-Krook-(BGK)-model.">Collision - Bhatnagar-Gross-Krook (BGK) model.</a><a id="Collision-Bhatnagar-Gross-Krook-(BGK)-model.-1"></a><a class="docs-heading-anchor-permalink" href="#Collision-Bhatnagar-Gross-Krook-(BGK)-model." title="Permalink"></a></h3><p>The collision step is based on the Bhatnagar-Gross-Krook (BGK) model, which is a simplified version of the Boltzmann equation. The collision step is defined as</p><p class="math-container">\[\rho\leftarrow(1-\omega)\rho_0+\omega\rho_\mathrm{\rm eq}\]</p><p>where <span>$\rho$</span> is the updated density <span>$\rho_0$</span> is the density before collision, and <span>$\rho_{\text{eq}}$</span> is the equilibrium density <span>$\omega = \Delta t/\tau$</span>, where <span>$\tau$</span> is the (relative) relaxation time</p><img src="../../assets/images/Equilibrium density.png" alt="image" width=500 height="auto"><p>The BGK model has a nice property that it conserves:</p><ul><li>total density <span>$\rho$</span></li><li>momentum <span>$\rho\mathbf{u}$</span></li></ul><h2 id="Julia-implementation"><a class="docs-heading-anchor" href="#Julia-implementation">Julia implementation</a><a id="Julia-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-implementation" title="Permalink"></a></h2><p>The following code is a part of the package <code>MyFirstPackage</code> that we created in the previous section: <a href="../julia-release/#My-First-Package">My First Package</a>.</p><p><em>File</em>: <code>src/fluid.jl</code> (Step 1-6)</p><h4 id="Step-1.-Define-the-lattice-Boltzmann-configuration"><a class="docs-heading-anchor" href="#Step-1.-Define-the-lattice-Boltzmann-configuration">Step 1. Define the lattice Boltzmann configuration</a><a id="Step-1.-Define-the-lattice-Boltzmann-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1.-Define-the-lattice-Boltzmann-configuration" title="Permalink"></a></h4><p>Let us start by defining an abstract type for lattice Boltzmann configurations and a concrete type that implements the D2Q9 lattice.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    AbstractLBConfig{D, N}

An abstract type for lattice Boltzmann configurations.
&quot;&quot;&quot;
abstract type AbstractLBConfig{D, N} end</code></pre><p>The D2Q9 lattice Boltzman configuration is defined as follows:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    D2Q9 &lt;: AbstractLBConfig{2, 9}

A lattice Boltzmann configuration for 2D, 9-velocity model.
&quot;&quot;&quot;
struct D2Q9 &lt;: AbstractLBConfig{2, 9} end
directions(::D2Q9) = (
        Point(1, 1), Point(-1, 1),
        Point(1, 0), Point(0, -1),
        Point(0, 0), Point(0, 1),
        Point(-1, 0), Point(1, -1),
        Point(-1, -1),
    )</code></pre><p>The <code>directions</code> function returns the 9 discrete velocities in the D2Q9 model. The velocities are ordered in a specific way, which enables us to define a function to flip the velocity vector. This is useful for handling the boundaries and barriers in the lattice.</p><pre><code class="language-julia hljs"># directions[k] is the opposite of directions[flip_direction_index(k)
function flip_direction_index(::D2Q9, i::Int)
    return 10 - i
end</code></pre><h4 id="Step-2:-Define-the-Cell-type-for-storing-the-state"><a class="docs-heading-anchor" href="#Step-2:-Define-the-Cell-type-for-storing-the-state">Step 2: Define the <code>Cell</code> type for storing the state</a><a id="Step-2:-Define-the-Cell-type-for-storing-the-state-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Define-the-Cell-type-for-storing-the-state" title="Permalink"></a></h4><p>The cell state is defined by the density of the fluid in different directions, <span>$\rho_{ij}(\mathbf{v})$</span>.</p><pre><code class="language-julia hljs"># the density of the fluid, each component is the density of a velocity
struct Cell{N, T &lt;: Real}
    density::NTuple{N, T}
end
# the total density of the fluid
density(cell::Cell) = sum(cell.density)
# the density of the fluid in a specific direction,
# where the direction is an integer
density(cell::Cell, direction::Int) = cell.density[direction]</code></pre><p>Expect the total density, the momentum <span>$\mathbf{u}$</span> is also conserved, which is defined as the <code>momentum</code> of the fluid.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    momentum(lb::AbstractLBConfig, rho::Cell)

Compute the momentum of the fluid from the density of the fluid.
&quot;&quot;&quot;
function momentum(lb::AbstractLBConfig, rho::Cell)
    return mapreduce((r, d) -&gt; r * d, +, rho.density, directions(lb)) / density(rho)
end</code></pre><p>Let us also define the addition and multiplication operations for the <code>Cell</code> type.</p><pre><code class="language-julia hljs">Base.:+(x::Cell, y::Cell) = Cell(x.density .+ y.density)
Base.:*(x::Real, y::Cell) = Cell(x .* y.density)</code></pre><h4 id="Step-3.-Implement-the-streaming-step"><a class="docs-heading-anchor" href="#Step-3.-Implement-the-streaming-step">Step 3. Implement the streaming step</a><a id="Step-3.-Implement-the-streaming-step-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3.-Implement-the-streaming-step" title="Permalink"></a></h4><pre><code class="language-julia hljs"># streaming step
function stream!(
        lb::AbstractLBConfig{2, N},  # lattice configuration
        newgrid::AbstractMatrix{D}, # the updated grid
        grid::AbstractMatrix{D}, # the original grid
        barrier::AbstractMatrix{Bool} # the barrier configuration
    ) where {N, T, D&lt;:Cell{N, T}}
    ds = directions(lb)
    @inbounds for ci in CartesianIndices(newgrid)
        i, j = ci.I
        newgrid[ci] = Cell(ntuple(N) do k # collect the densities
            ei = ds[k]
            m, n = size(grid)
            i2, j2 = mod1(i - ei[1], m), mod1(j - ei[2], n)
            if barrier[i2, j2]
                # if the cell is a barrier, the fluid flows back
                density(grid[i, j], flip_direction_index(lb, k))
            else
                # otherwise, the fluid flows to the neighboring cell
                density(grid[i2, j2], k)
            end
        end)
    end
end</code></pre><h4 id="Step-4.-Implement-the-collision-step"><a class="docs-heading-anchor" href="#Step-4.-Implement-the-collision-step">Step 4. Implement the collision step</a><a id="Step-4.-Implement-the-collision-step-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4.-Implement-the-collision-step" title="Permalink"></a></h4><p>By the Bhatnagar-Gross-Krook (BGK) model, the collision step drives the fluid towards an equilibrium state. The equilibrium density is completely determined by the total density and the momentum of the fluid:</p><p class="math-container">\[\rho_{\rm eq}(\mathbf{v}_i) \approx \rho_{\rm tot} w_i \left(1 + 3\mathbf{v}_i\cdot\mathbf{u} + \frac{9}{2}(\mathbf{v}_i\cdot\mathbf{u})^2 - \frac{3}{2}\mathbf{u}\cdot\mathbf{u}\right)\]</p><p>where <span>$\rho_{\rm tot}$</span> is the total density, <span>$\mathbf{u}$</span> is the momentum, <span>$w_i \sim e^{-|\mathbf{v}_i|^2}$</span> is the distribution of velocities with mean-velocity zero, and <span>$v_i$</span> is the velocity vector.</p><p>The detailed derivation of the equilibrium density could be found in the first reference at the top of this page.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    equilibrium_density(lb::AbstractLBConfig, ρ, u)

Compute the equilibrium density of the fluid from the total density and the momentum.
&quot;&quot;&quot;
function equilibrium_density(lb::AbstractLBConfig{D, N}, ρ, u) where {D, N}
    ws, ds = weights(lb), directions(lb)
    return Cell(
        ntuple(i-&gt; ρ * ws[i] * _equilibrium_density(u, ds[i]), N)
    )
end

# the distribution of the 9 velocities at the equilibrium state
weights(::D2Q9) = (1/36, 1/36, 1/9, 1/9, 4/9, 1/9, 1/9, 1/36, 1/36)
function _equilibrium_density(u, ei)
    # the equilibrium density of the fluid with a specific mean momentum
    return (1 + 3 * dot(ei, u) + 9/2 * dot(ei, u)^2 - 3/2 * dot(u, u))
end</code></pre><p>The collision step that implements the BGK model is defined as follows:</p><pre><code class="language-julia hljs"># collision step, applied on a single cell
function collide(lb::AbstractLBConfig{D, N}, rho; viscosity = 0.02) where {D, N}
    omega = 1 / (3 * viscosity + 0.5)   # &quot;relaxation&quot; parameter
    # Recompute macroscopic quantities:
    v = momentum(lb, rho)
    return (1 - omega) * rho + omega * equilibrium_density(lb, density(rho), v)
end</code></pre><h4 id="Step-5.-Implement-the-lattice-Boltzmann-simulation"><a class="docs-heading-anchor" href="#Step-5.-Implement-the-lattice-Boltzmann-simulation">Step 5. Implement the lattice Boltzmann simulation</a><a id="Step-5.-Implement-the-lattice-Boltzmann-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5.-Implement-the-lattice-Boltzmann-simulation" title="Permalink"></a></h4><pre><code class="language-julia hljs">&quot;&quot;&quot;
    LatticeBoltzmann{D, N, T, CFG, MT, BT}

A lattice Boltzmann simulation with D dimensions, N velocities, and lattice configuration CFG.
&quot;&quot;&quot;

struct LatticeBoltzmann{D, N, T, CFG&lt;:AbstractLBConfig{D, N}, MT&lt;:AbstractMatrix{Cell{N, T}}, BT&lt;:AbstractMatrix{Bool}}
    config::CFG # lattice configuration
    grid::MT    # density of the fluid
    gridcache::MT # cache for the density of the fluid
    barrier::BT # barrier configuration
end

function LatticeBoltzmann(config::AbstractLBConfig{D, N}, grid::AbstractMatrix{&lt;:Cell}, barrier::AbstractMatrix{Bool}) where {D, N}
    @assert size(grid) == size(barrier)
    return LatticeBoltzmann(config, grid, similar(grid), barrier)
end</code></pre><p>A single step of the lattice Boltzmann simulation is defined as follows, which directly modifies the <code>grid</code> field of the <code>LatticeBoltzmann</code> type.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    step!(lb::LatticeBoltzmann)

Perform a single step of the lattice Boltzmann simulation.
&quot;&quot;&quot;
function step!(lb::LatticeBoltzmann)
    copyto!(lb.gridcache, lb.grid)
    stream!(lb.config, lb.grid, lb.gridcache, lb.barrier)
    lb.grid .= collide.(Ref(lb.config), lb.grid)
    return lb
end</code></pre><p>For better visualization, we define a function to compute the curl of the momentum field in 2D, which is defined as:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    curl(u::AbstractMatrix{Point2D{T}})

Compute the curl of the momentum field in 2D, which is defined as:
```math
∂u_y/∂x−∂u_x/∂y
```
&quot;&quot;&quot;
function curl(u::Matrix{Point2D{T}}) where T 
    return map(CartesianIndices(u)) do ci
        i, j = ci.I
        m, n = size(u)
        uy = u[mod1(i + 1, m), j][2] - u[mod1(i - 1, m), j][2]
        ux = u[i, mod1(j + 1, n)][1] - u[i, mod1(j - 1, n)][1]
        return uy - ux # a factor of 1/2 is missing here?
    end
end</code></pre><h4 id="Step-6.-Find-the-example-simulation"><a class="docs-heading-anchor" href="#Step-6.-Find-the-example-simulation">Step 6. Find the example simulation</a><a id="Step-6.-Find-the-example-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Step-6.-Find-the-example-simulation" title="Permalink"></a></h4><p>A D2Q9 lattice Boltzmann simulation example. A simple linear barrier is added to the lattice.</p><pre><code class="language-julia hljs">function example_d2q9(;
        height = 80, width = 200,
        u0 = Point(0.0, 0.1)) # initial and in-flow speed
    # Initialize all the arrays to steady rightward flow:
    rho = equilibrium_density(D2Q9(), 1.0, u0)
    rgrid = fill(rho, height, width)

    # Initialize barriers:
    barrier = falses(height, width)  # True wherever there&#39;s a barrier
    mid = div(height, 2)
    barrier[mid-8:mid+8, div(height,2)] .= true              # simple linear barrier

    return LatticeBoltzmann(D2Q9(), rgrid, barrier)
end</code></pre><h4 id="Step-7.-Include-the-above-file-into-the-package-module"><a class="docs-heading-anchor" href="#Step-7.-Include-the-above-file-into-the-package-module">Step 7. Include the above file into the package module</a><a id="Step-7.-Include-the-above-file-into-the-package-module-1"></a><a class="docs-heading-anchor-permalink" href="#Step-7.-Include-the-above-file-into-the-package-module" title="Permalink"></a></h4><p><em>File</em>: <code>src/MyFirstPackage.jl</code></p><pre><code class="language-julia hljs">module MyFirstPackage
# import packages
using LinearAlgebra

# export interfaces
export Lorenz, integrate_step
export Point, Point2D, Point3D
export RungeKutta, Euclidean
export D2Q9, LatticeBoltzmann, step!, equilibrium_density, momentum, curl, example_d2q9, density

include(&quot;lorenz.jl&quot;)
include(&quot;fluid.jl&quot;)

end</code></pre><h3 id="Using-the-package"><a class="docs-heading-anchor" href="#Using-the-package">Using the package</a><a id="Using-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-package" title="Permalink"></a></h3><p><em>File</em>: <code>examples/barrier.jl</code></p><pre><code class="language-julia hljs">using Makie: RGBA # for visualization
using Makie, CairoMakie
using MyFirstPackage # our package

# Set up the visualization with Makie:
lb = example_d2q9()
vorticity = Observable(curl(momentum.(Ref(lb.config), lb.grid))&#39;)
fig, ax, plot = image(vorticity, colormap = :jet, colorrange = (-0.1, 0.1))

# Show barrier
barrier_img = map(x -&gt; x ? RGBA(0, 0, 0, 1) : RGBA(0, 0, 0, 0), lb.barrier)
image!(ax, barrier_img&#39;)

# Recording the simulation
record(fig, joinpath(@__DIR__, &quot;barrier.mp4&quot;), 1:100; framerate = 10) do i
    for i=1:20
        step!(lb)
    end
    vorticity[] = curl(momentum.(Ref(lb.config), lb.grid))&#39;
end</code></pre><p>To ensure the reproducibility of the code, we need to create a local environment and install the required packages.</p><pre><code class="language-julia-pkg hljs">pkg&gt; activate examples

pkg&gt; dev .

pkg&gt; add Makie CairoMakie BenchmarkTools</code></pre><p>Type <code>Backspace</code> to exit the package mode. To execute the code, type</p><pre><code class="language-julia hljs">julia&gt; include(&quot;examples/barrier.jl&quot;)</code></pre><p>You should see a new file <code>barrier.mp4</code> in the <code>examples</code> directory, which is the recording of the simulation.</p><video width="320" height="240" controls>
  <source src="../../assets/images/barrier.mp4" type="video/mp4">
</video><h3 id="Benchmarking"><a class="docs-heading-anchor" href="#Benchmarking">Benchmarking</a><a id="Benchmarking-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarking" title="Permalink"></a></h3><pre><code class="language-julia hljs">julia&gt; using BenchmarkTools

julia&gt; @benchmark step!($(deepcopy(lb)))
BenchmarkTools.Trial: 3637 samples with 1 evaluation.
 Range (min … max):  1.323 ms …  1.899 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     1.363 ms              ┊ GC (median):    0.00%
 Time  (mean ± σ):   1.374 ms ± 30.730 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%

             ▁▇█▆▄▃▃▂▂▂▁▂▂▂▂▁▁▁▁▁▁                           ▁
  ▃▁▁▃▃▃▃▁▁▁▃█████████████████████████▆▆▆▆▅▆▆▆▆▅▅▆▆▃▅▅▄▆▆▅▃▆ █
  1.32 ms      Histogram: log(frequency) by time     1.49 ms &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre><h3 id="Profiling-identify-the-performance-bottleneck"><a class="docs-heading-anchor" href="#Profiling-identify-the-performance-bottleneck">Profiling - identify the performance bottleneck</a><a id="Profiling-identify-the-performance-bottleneck-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling-identify-the-performance-bottleneck" title="Permalink"></a></h3><blockquote><p><em>Premature optimization is the root of all evil – Donald Knuth</em></p></blockquote><p>Performance optimization comes after the correctness of the code, and it should be based on the profiling result. Profiling is mainly used to identify the performance bottleneck of your code. The <a href="https://docs.julialang.org/en/v1/manual/profile/">Profile</a> module in Julia provides a set of tools to profile your code.</p><pre><code class="language-julia-repl hljs">julia&gt; using Profile

julia&gt; Profile.init(n = 10^7, delay = 0.001) # set the number of samples and the delay between samples</code></pre><p>Then you can profile your code by wrapping the code with <code>@profile</code> macro.</p><pre><code class="language-julia-repl hljs">julia&gt; @profile for i in 1:100
           step!(lb)
       end</code></pre><p>In order to collect enough samples, we run the <code>step!</code> function for 100 times. To view the profile result, you can use the <code>Profile.print</code> function.</p><pre><code class="language-julia-repl hljs">julia&gt; Profile.print(; mincount=10) # only show functions with ≥10 counts
Overhead ╎ [+additional indent] Count File:Line; Function
=========================================================
            ... truncated message ...
  ╎    ╎    ╎    ╎ 88  …rc/fluid.jl:144; step!(lb::LatticeBoltzm…
  ╎    ╎    ╎    ╎  88  …rc/fluid.jl:76; stream!(lb::D2Q9, newgr…
33╎    ╎    ╎    ╎   88  …e/ntuple.jl:19; ntuple
  ╎    ╎    ╎    ╎    18  …rc/fluid.jl:79; (::MyFirstPackage.var…
  ╎    ╎    ╎    ╎     10  …perators.jl:830; mod1
 1╎    ╎    ╎    ╎    16  …rc/fluid.jl:80; (::MyFirstPackage.var…
  ╎    ╎    ╎    ╎     15  …actarray.jl:1291; getindex
  ╎    ╎    ╎    ╎    ╎ 13  …actarray.jl:1323; _getindex
 1╎    ╎    ╎    ╎    ╎  13  …actarray.jl:702; checkbounds
  ╎    ╎    ╎    ╎    ╎   12  …actarray.jl:681; checkbounds
  ╎    ╎    ╎    ╎ 13  …rc/fluid.jl:145; step!(lb::LatticeBoltzm…
  ╎    ╎    ╎    ╎  13  …roadcast.jl:911; materialize!
  ╎    ╎    ╎    ╎   13  …roadcast.jl:914; materialize!
  ╎    ╎    ╎    ╎    13  …roadcast.jl:956; copyto!
  ╎    ╎    ╎    ╎     13  …roadcast.jl:1003; copyto!
  ╎    ╎    ╎    ╎    ╎ 12  …simdloop.jl:77; macro expansion
  ╎    ╎    ╎    ╎    ╎  12  …roadcast.jl:1004; macro expansion
  ╎    ╎    ╎    ╎    ╎   12  …roadcast.jl:636; getindex
Total snapshots: 112. Utilization: 100% across all threads and tasks. Use the `groupby` kwarg to break down by thread and/or task.</code></pre><p>Alternatively, you can use the format <code>:flat</code> to show the profile result in a flat view.</p><pre><code class="language-julia-repl hljs">julia&gt; Profile.print(; mincount=10, format=:flat)
 Count  Overhead File                                                        Line Function
 =====  ======== ====                                                        ==== ========
            ... truncated message ...
    10         0 @MyFirstPackage/src/fluid.jl                                  63 #6
    11        11 @MyFirstPackage/src/fluid.jl                                   ? (::MyFirstPackage.var&quot;#8#9&quot;{D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}, BitMatrix, N…
    20         0 @MyFirstPackage/src/fluid.jl                                  79 (::MyFirstPackage.var&quot;#8#9&quot;{D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}, BitMatrix, N…
    17         0 @MyFirstPackage/src/fluid.jl                                  80 (::MyFirstPackage.var&quot;#8#9&quot;{D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}, BitMatrix, N…
    15         3 @MyFirstPackage/src/fluid.jl                                  94 collide(lb::D2Q9, rho::MyFirstPackage.Cell{9, Float64}; viscosity::Float64)
    11         1 @MyFirstPackage/src/fluid.jl                                  62 equilibrium_density(lb::D2Q9, ρ::Float64, u::Point2D{Float64})
    97         0 @MyFirstPackage/src/fluid.jl                                 144 step!(lb::LatticeBoltzmann{2, 9, Float64, D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}…
    10         0 @MyFirstPackage/src/fluid.jl                                 145 step!(lb::LatticeBoltzmann{2, 9, Float64, D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}…
    97         0 @MyFirstPackage/src/fluid.jl                                  76 stream!(lb::D2Q9, newgrid::Matrix{MyFirstPackage.Cell{9, Float64}}, grid::Matrix{MyFirs…
Total snapshots: 120. Utilization: 100% across all threads and tasks. Use the `groupby` kwarg to break down by thread and/or task.</code></pre><p>The printed result shows that the <code>stream!</code> step is more costly than the <code>collide</code> step, which should be the focus of optimization.</p><div class="admonition is-info"><header class="admonition-header">How profiling works</header><div class="admonition-body"><p>Profiling is a statistical method to measure the performance of your code. It works by sampling the function call stack of the running code at a certain frequency.</p></div></div><p>Let use look at the <code>stream!</code> function to see which part of the code is more costly.</p><pre><code class="language-julia-repl hljs">julia&gt; Profile.clear()   # clear the previous profile result

julia&gt; @profile for i in 1:300
    MyFirstPackage.stream!(lb.config, lb.grid, lb.gridcache, lb.barrier)
end

Profile.print(format=:flat, mincount=30)  # show the profile result, only show the functions that are called more than 5 times
            ... truncated message ...
  ╎    ╎    ╎    ╎ 263 …rc/fluid.jl:76; stream!(lb::D2Q9, newgri…
77╎    ╎    ╎    ╎  259 …e/ntuple.jl:19; ntuple
  ╎    ╎    ╎    ╎   57  …rc/fluid.jl:79; (::MyFirstPackage.var&quot;…
28╎    ╎    ╎    ╎    28  @Base/int.jl:86; -
  ╎    ╎    ╎    ╎    29  …perators.jl:830; mod1
  ╎    ╎    ╎    ╎     27  @Base/int.jl:287; mod
  ╎    ╎    ╎    ╎    ╎ 27  @Base/div.jl:319; fld
  ╎    ╎    ╎    ╎    ╎  27  @Base/div.jl:354; div
  ╎    ╎    ╎    ╎    ╎   25  @Base/int.jl:1068; -
25╎    ╎    ╎    ╎    ╎    25  @Base/int.jl:86; -
 3╎    ╎    ╎    ╎   51  …rc/fluid.jl:80; (::MyFirstPackage.var&quot;…
  ╎    ╎    ╎    ╎    48  …actarray.jl:1291; getindex
  ╎    ╎    ╎    ╎     46  …actarray.jl:1323; _getindex
 3╎    ╎    ╎    ╎    ╎ 46  …actarray.jl:702; checkbounds
  ╎    ╎    ╎    ╎    ╎  43  …actarray.jl:681; checkbounds
  ╎    ╎    ╎    ╎    ╎   39  …actarray.jl:728; checkbounds_indi…
  ╎    ╎    ╎    ╎    ╎    39  …actarray.jl:728; checkbounds_ind…
  ╎    ╎    ╎    ╎    ╎     39  …actarray.jl:763; checkindex
38╎    ╎    ╎    ╎    ╎    ╎ 39  @Base/int.jl:86; -
  ╎    ╎    ╎    ╎   29  …rc/fluid.jl:83; (::MyFirstPackage.var&quot;…
29╎    ╎    ╎    ╎    29  …sentials.jl:14; getindex
Total snapshots: 264. Utilization: 100% across all threads and tasks. Use the `groupby` kwarg to break down by thread and/or task.</code></pre><p>The line 79 in file <code>src/fluid.jl</code> costs <code>57/264</code> samples, which is the following line of code:</p><pre><code class="language-julia hljs">i2, j2 = mod1(i - ei[1], m), mod1(j - ei[2], n)</code></pre><p>The line 80 in file <code>src/fluid.jl</code> costs <code>51/264</code> samples, which is the following line of code:</p><pre><code class="language-julia hljs">if barrier[i2, j2]</code></pre><p>and most of the time is spent on the <code>checkbounds</code> function.</p><p>Could we remove the boundary check? Please refer to the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">Julia Performance Tips</a> for more information.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../julia-release/">« My First Package</a><a class="docs-footer-nextpage" href="../../chap3/linalg/">Matrix Computation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 13 March 2024 06:02">Wednesday 13 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
