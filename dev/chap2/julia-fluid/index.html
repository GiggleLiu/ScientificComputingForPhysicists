<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Project: Fluid dynamics · Scientific Computing For Physicists</title><meta name="title" content="Project: Fluid dynamics · Scientific Computing For Physicists"/><meta property="og:title" content="Project: Fluid dynamics · Scientific Computing For Physicists"/><meta property="twitter:title" content="Project: Fluid dynamics · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap2/julia-fluid/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap2/julia-fluid/"/><link rel="canonical" href="https://book.jinguo-group.science/chap2/julia-fluid/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../julia-release/">My First Package</a></li><li><a class="tocitem" href="../julia-performance/">Performance and Profile</a></li><li class="is-active"><a class="tocitem" href>Project: Fluid dynamics</a><ul class="internal"><li><a class="tocitem" href="#Fluid-Dynamics-Simulation"><span>Fluid Dynamics Simulation</span></a></li><li><a class="tocitem" href="#D2Q9-model"><span>D2Q9 model</span></a></li><li><a class="tocitem" href="#Julia-implementation"><span>Julia implementation</span></a></li></ul></li></ul></li><li><span class="tocitem">Tensors (×)</span><ul><li><a class="tocitem" href="../../chap3/array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../../chap3/linalg/">Basic Linear Algebra</a></li><li><a class="tocitem" href="../../chap3/factorization/">Matrix factorization</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/tensors/">Tensor Operations</a></li><li><a class="tocitem" href="../../chap3/cuda/">Arrays on GPU</a></li></ul></li><li><span class="tocitem">Optimization (×)</span><ul><li><a class="tocitem" href="../../chap4/combinatorial/">Combinatorial Optimization</a></li><li><a class="tocitem" href="../../chap4/optimization/">Optimization</a></li><li><a class="tocitem" href="../../chap4/ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Randomness (×)</span><ul><li><a class="tocitem" href="../../chap5/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Sparsity (×)</span><ul><li><a class="tocitem" href="../../chap6/sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../../chap6/compressedsensing/">Compressed sensing</a></li></ul></li><li><span class="tocitem">High Performance Computing (×)</span><ul><li><a class="tocitem" href="../../chap7/hpc/">MPI and OpenMP</a></li><li><a class="tocitem" href="../../chap7/cuda/">CUDA programming</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Julia Programming Language</a></li><li class="is-active"><a href>Project: Fluid dynamics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Project: Fluid dynamics</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap2/julia-fluid.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Project:-Fluid-dynamics"><a class="docs-heading-anchor" href="#Project:-Fluid-dynamics">Project: Fluid dynamics</a><a id="Project:-Fluid-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Project:-Fluid-dynamics" title="Permalink"></a></h1><h2 id="Fluid-Dynamics-Simulation"><a class="docs-heading-anchor" href="#Fluid-Dynamics-Simulation">Fluid Dynamics Simulation</a><a id="Fluid-Dynamics-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Fluid-Dynamics-Simulation" title="Permalink"></a></h2><p>Fluid dynamics is the study of the movement of fluids, including air and water. In this project, we will use the Lattice Boltzmann Method (LBM) to simulate fluid dynamics, which is a mesoscopic method based on the kinetic theory of gases.</p><table><tr><th style="text-align: right"></th><th style="text-align: right">micro</th><th style="text-align: right">meso</th><th style="text-align: right">macro</th></tr><tr><td style="text-align: right"><strong>Scale</strong></td><td style="text-align: right"><span>$10^{-9}$</span>m</td><td style="text-align: right"><span>$10^{-9} -10^{-6}$</span>m</td><td style="text-align: right"><span>$&gt;10^{6}$</span>m</td></tr><tr><td style="text-align: right"><strong>Physics</strong></td><td style="text-align: right">molecular</td><td style="text-align: right">probabilistic</td><td style="text-align: right">continuous</td></tr><tr><td style="text-align: right"><strong>Gov. Eq.</strong></td><td style="text-align: right">Newton</td><td style="text-align: right">Boltzmann</td><td style="text-align: right">Navier-Stokes equations</td></tr><tr><td style="text-align: right"><strong>Method</strong></td><td style="text-align: right">Molecular Dynamics</td><td style="text-align: right">Lattice Boltzmann</td><td style="text-align: right">Computational Fluid Dynamics</td></tr></table><p>This book does not aim to provide a comprehensive understanding of fluid dynamics. If you are interested in learning more about fluid dynamics, you can refer to the following resources:</p><ul><li><p><a href="https://physics.weber.edu/schroeder/fluids/">Fluid Dynamics Simulation (in Python, Java and Javascript)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=jfk4feD7rFQ">YouTube - Introduction to Lattice Boltzmann Method</a></p></li></ul><h3 id="Lattice-Boltzmann-Method-(LBM)"><a class="docs-heading-anchor" href="#Lattice-Boltzmann-Method-(LBM)">Lattice Boltzmann Method (LBM)</a><a id="Lattice-Boltzmann-Method-(LBM)-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-Boltzmann-Method-(LBM)" title="Permalink"></a></h3><p>The general idea of LBM is to simulate the fluid dynamics by modeling the movement of particles in a lattice, a grid of cells, without keeping track of the individual particles. The state of a cell in the lattice is defined by the density of particles moving in different directions, i.e. </p><p class="math-container">\[{\rm state}(i, j) \equiv \rho_{ij}(\mathbf{v})\]</p><p>where <span>$(i, j)$</span> is the position of the cell in the lattice and <span>$\mathbf{v}$</span> is the velocity of the particles.</p><img src="/assets/images/lattice.png" alt="image" width=300 height="auto"><p>The particles move with different velocities <span>$\mathbf v$</span> and collide with each other, driving the fluid to reach an equilibrium state, where the energy of the particles is governed by the Boltzmann distribution</p><p class="math-container">\[\rho_{eq}(E) \sim e^{-\frac{E}{k_BT}} ({\rm or }\; e^{- {\rm const.} \times |\mathbf{v}|^2}),\]</p><p>where <span>$k_B$</span> is the Boltzmann constant, <span>$T$</span> is the temperature, and <span>$E = \frac{1}{2}m|\mathbf{v}|^2$</span> is the energy of the particles.</p><h2 id="D2Q9-model"><a class="docs-heading-anchor" href="#D2Q9-model">D2Q9 model</a><a id="D2Q9-model-1"></a><a class="docs-heading-anchor-permalink" href="#D2Q9-model" title="Permalink"></a></h2><p>The lattice Boltzmann method uses a discrete set of velocities, which is a simplification of the continuous velocity space. One of the simplest models is the D2Q9 model, which contains</p><ul><li>a 2D lattice, and</li><li>9 discrete velocities: <span>$(0,0)$</span>, <span>$(1,0), (0,1), (-1,0), (0,-1)$</span>, <span>$(1,1), (-1,1), (-1,-1), (1,-1)$</span>.</li></ul><img src="/assets/images/D2Q9.png" alt="image" width=500 height="auto"><p>Lattice Boltzmann Method (LBM) contains two steps:</p><ol><li>Streaming - particles move to neighboring cells</li><li>Collision - particles collide and exchange momentum</li></ol><h3 id="Streaming"><a class="docs-heading-anchor" href="#Streaming">Streaming</a><a id="Streaming-1"></a><a class="docs-heading-anchor-permalink" href="#Streaming" title="Permalink"></a></h3><img src="/assets/images/stream.png" alt="image" width=500 height="auto"><h3 id="Collision-Bhatnagar-Gross-Krook-(BGK)-model."><a class="docs-heading-anchor" href="#Collision-Bhatnagar-Gross-Krook-(BGK)-model.">Collision - Bhatnagar-Gross-Krook (BGK) model.</a><a id="Collision-Bhatnagar-Gross-Krook-(BGK)-model.-1"></a><a class="docs-heading-anchor-permalink" href="#Collision-Bhatnagar-Gross-Krook-(BGK)-model." title="Permalink"></a></h3><p>The collision step is based on the Bhatnagar-Gross-Krook (BGK) model, which is a simplified version of the Boltzmann equation. The collision step is defined as</p><p class="math-container">\[\rho\leftarrow(1-\omega)\rho_0+\omega\rho_\mathrm{eq}\]</p><p>where <span>$\rho$</span> is the updated density <span>$\rho_0$</span> is the density before collision, and <span>$\rho_{\text{eq}}$</span> is the equilibrium density <span>$\omega = \Delta t/\tau$</span>, where <span>$\tau$</span> is the (relative) relaxation time</p><img src="/assets/images/Equilibrium density.png" alt="image" width=500 height="auto"><p>The BGK model has a nice property that it conserves:</p><ul><li>total density <span>$\rho$</span></li><li>momentum <span>$\rho\mathbf{u}$</span></li></ul><h2 id="Julia-implementation"><a class="docs-heading-anchor" href="#Julia-implementation">Julia implementation</a><a id="Julia-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-implementation" title="Permalink"></a></h2><p>The following code is a part of the package <code>MyFirstPackage</code> that we created in the previous section: <a href="../julia-release/#My-First-Package">My First Package</a>.</p><p><em>File</em>: <code>src/fluid.jl</code></p><p>Step 1. Let us start by defining an abstract type for lattice Boltzmann configurations and a concrete type that implements the D2Q9 lattice.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    AbstractLBConfig{D, N}

An abstract type for lattice Boltzmann configurations.
&quot;&quot;&quot;
abstract type AbstractLBConfig{D, N} end</code></pre><p>The D2Q9 lattice Boltzman configuration is defined as follows:</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    D2Q9 &lt;: AbstractLBConfig{2, 9}

A lattice Boltzmann configuration for 2D, 9-velocity model.
&quot;&quot;&quot;
struct D2Q9 &lt;: AbstractLBConfig{2, 9} end
directions(::D2Q9) = (
        Point(1, 1), Point(-1, 1),
        Point(1, 0), Point(0, -1),
        Point(0, 0), Point(0, 1),
        Point(-1, 0), Point(1, -1),
        Point(-1, -1),
    )</code></pre><p>The <code>directions</code> function returns the 9 discrete velocities in the D2Q9 model. The velocities are ordered in a specific way, which enables us to define a function to flip the velocity vector. This is useful for handling the boundaries and barriers in the lattice.</p><pre><code class="language-julia hljs"># directions[k] is the opposite of directions[flip_direction_index(k)
function flip_direction_index(::D2Q9, i::Int)
    return 10 - i
end</code></pre><p>Step 3: Define the <code>Cell</code> type for storing the state <span>$\rho_{ij}(\mathbf{v})$</span> of a cell.</p><pre><code class="language-julia hljs"># the density of the fluid, each component is the density of a velocity
struct Cell{N, T &lt;: Real}
    density::NTuple{N, T}
end
# the total density of the fluid
density(cell::Cell) = sum(cell.density)
# the density of the fluid in a specific direction,
# where the direction is an integer
density(cell::Cell, direction::Int) = cell.density[direction]</code></pre><p>Expect the total density, the momentum is also conserved, which is defined as the <code>momentum</code> of the fluid.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    momentum(lb::AbstractLBConfig, rho::Cell)

Compute the momentum of the fluid from the density of the fluid.
&quot;&quot;&quot;
function momentum(lb::AbstractLBConfig, rho::Cell)
    return mapreduce((r, d) -&gt; r * d, +, rho.density, directions(lb)) / density(rho)
end</code></pre><p>Let us also define the addition and multiplication operations for the <code>Cell</code> type.</p><pre><code class="language-julia hljs">Base.:+(x::Cell, y::Cell) = Cell(x.density .+ y.density)
Base.:*(x::Real, y::Cell) = Cell(x .* y.density)</code></pre><p>Step 4. Implement the streaming step.</p><pre><code class="language-julia hljs"># streaming step
function stream!(
        lb::AbstractLBConfig{2, N},  # lattice configuration
        newgrid::AbstractMatrix{D}, # the updated grid
        grid::AbstractMatrix{D}, # the original grid
        barrier::AbstractMatrix{Bool} # the barrier configuration
    ) where {N, T, D&lt;:Cell{N, T}}
    ds = directions(lb)
    @inbounds for ci in CartesianIndices(newgrid)
        i, j = ci.I
        newgrid[ci] = Cell(ntuple(N) do k # collect the densities
            ei = ds[k]
            m, n = size(grid)
            i2, j2 = mod1(i - ei[1], m), mod1(j - ei[2], n)
            if barrier[i2, j2]
                # if the cell is a barrier, the fluid flows back
                density(grid[i, j], flip_direction_index(lb, k))
            else
                # otherwise, the fluid flows to the neighboring cell
                density(grid[i2, j2], k)
            end
        end)
    end
end</code></pre><p>Step 5. Implement the collision step.</p><p>By the Bhatnagar-Gross-Krook (BGK) model, the collision step drives the fluid towards an equilibrium state. The equilibrium density <span>$\rho_{eq}(\rho_{\rm tot}, \mu)$</span>.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    equilibrium_density(lb::AbstractLBConfig, ρ, u)

Compute the equilibrium density of the fluid from the total density and the momentum.
&quot;&quot;&quot;
function equilibrium_density(lb::AbstractLBConfig{D, N}, ρ, u) where {D, N}
    ws, ds = weights(lb), directions(lb)
    return Cell(
        ntuple(i-&gt; ρ * ws[i] * _equilibrium_density(u, ds[i]), N)
    )
end</code></pre><pre><code class="language-julia hljs"># the distribution of the 9 velocities at the equilibrium state
weights(::D2Q9) = (1/36, 1/36, 1/9, 1/9, 4/9, 1/9, 1/9, 1/36, 1/36)
function _equilibrium_density(u, ei)
    # the equilibrium density of the fluid with a specific mean momentum
    return (1 + 3 * dot(ei, u) + 9/2 * dot(ei, u)^2 - 3/2 * dot(u, u))
end</code></pre><pre><code class="language-julia hljs"># collision step, applied on a single cell
function collide(lb::AbstractLBConfig{D, N}, rho; viscosity = 0.02) where {D, N}
    omega = 1 / (3 * viscosity + 0.5)   # &quot;relaxation&quot; parameter
    # Recompute macroscopic quantities:
    v = momentum(lb, rho)
    return (1 - omega) * rho + omega * equilibrium_density(lb, density(rho), v)
end</code></pre><h3 id="Curl-for-visualization"><a class="docs-heading-anchor" href="#Curl-for-visualization">Curl - for visualization</a><a id="Curl-for-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Curl-for-visualization" title="Permalink"></a></h3><pre><code class="language-julia hljs">&quot;&quot;&quot;
    curl(u::AbstractMatrix{Point2D{T}})

Compute the curl of the momentum field in 2D, which is defined as:
```math
∂u_y/∂x−∂u_x/∂y
```
&quot;&quot;&quot;
function curl(u::Matrix{Point2D{T}}) where T 
    return map(CartesianIndices(u)) do ci
        i, j = ci.I
        m, n = size(u)
        uy = u[mod1(i + 1, m), j][2] - u[mod1(i - 1, m), j][2]
        ux = u[i, mod1(j + 1, n)][1] - u[i, mod1(j - 1, n)][1]
        return uy - ux # a factor of 1/2 is missing here?
    end
end</code></pre><h3 id="Lattice-Boltzmann-simulation"><a class="docs-heading-anchor" href="#Lattice-Boltzmann-simulation">Lattice Boltzmann simulation</a><a id="Lattice-Boltzmann-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-Boltzmann-simulation" title="Permalink"></a></h3><pre><code class="language-julia hljs">&quot;&quot;&quot;
    LatticeBoltzmann{D, N, T, CFG, MT, BT}

A lattice Boltzmann simulation with D dimensions, N velocities, and lattice configuration CFG.
&quot;&quot;&quot;

struct LatticeBoltzmann{D, N, T, CFG&lt;:AbstractLBConfig{D, N}, MT&lt;:AbstractMatrix{Cell{N, T}}, BT&lt;:AbstractMatrix{Bool}}
    config::CFG # lattice configuration
    grid::MT    # density of the fluid
    gridcache::MT # cache for the density of the fluid
    barrier::BT # barrier configuration
end</code></pre><pre><code class="language-julia hljs">function LatticeBoltzmann(config::AbstractLBConfig{D, N}, grid::AbstractMatrix{&lt;:Cell}, barrier::AbstractMatrix{Bool}) where {D, N}
    @assert size(grid) == size(barrier)
    return LatticeBoltzmann(config, grid, similar(grid), barrier)
end</code></pre><h3 id="Single-step-simulation"><a class="docs-heading-anchor" href="#Single-step-simulation">Single step simulation</a><a id="Single-step-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Single-step-simulation" title="Permalink"></a></h3><pre><code class="language-julia hljs">&quot;&quot;&quot;
    step!(lb::LatticeBoltzmann)

Perform a single step of the lattice Boltzmann simulation.
&quot;&quot;&quot;
function step!(lb::LatticeBoltzmann)
    copyto!(lb.gridcache, lb.grid)
    stream!(lb.config, lb.grid, lb.gridcache, lb.barrier)
    lb.grid .= collide.(Ref(lb.config), lb.grid)
    return lb
end</code></pre><h3 id="The-example-simulation"><a class="docs-heading-anchor" href="#The-example-simulation">The example simulation</a><a id="The-example-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#The-example-simulation" title="Permalink"></a></h3><p>A D2Q9 lattice Boltzmann simulation example. A simple linear barrier is added to the lattice.</p><pre><code class="language-julia hljs">function example_d2q9(;
        height = 80, width = 200,
        u0 = Point(0.0, 0.1)) # initial and in-flow speed
    # Initialize all the arrays to steady rightward flow:
    rho = equilibrium_density(D2Q9(), 1.0, u0)
    rgrid = fill(rho, height, width)

    # Initialize barriers:
    barrier = falses(height, width)  # True wherever there&#39;s a barrier
    mid = div(height, 2)
    barrier[mid-8:mid+8, div(height,2)] .= true              # simple linear barrier

    return LatticeBoltzmann(D2Q9(), rgrid, barrier)
end</code></pre><h3 id="Using-the-package"><a class="docs-heading-anchor" href="#Using-the-package">Using the package</a><a id="Using-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-package" title="Permalink"></a></h3><p><em>File</em>: <code>examples/barrier.jl</code></p><pre><code class="language-julia hljs">using Makie: RGBA # for visualization
using Makie, GLMakie
using MyFirstPackage # our package</code></pre><h3 id="Simulation-and-visualization"><a class="docs-heading-anchor" href="#Simulation-and-visualization">Simulation and visualization</a><a id="Simulation-and-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-and-visualization" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Set up the visualization with Makie:
lb = example_d2q9()
vorticity = Observable(curl(momentum.(Ref(lb.config), lb.grid))&#39;)
fig, ax, plot = image(vorticity, colormap = :jet, colorrange = (-0.1, 0.1))

# Show barrier
barrier_img = map(x -&gt; x ? RGBA(0, 0, 0, 1) : RGBA(0, 0, 0, 0), lb.barrier)
image!(ax, barrier_img&#39;)</code></pre><h3 id="Benchmarking"><a class="docs-heading-anchor" href="#Benchmarking">Benchmarking</a><a id="Benchmarking-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarking" title="Permalink"></a></h3><pre><code class="language-julia hljs">using BenchmarkTools
@benchmark step!($(deepcopy(lb)))</code></pre><h3 id="Profiling-(!!!)"><a class="docs-heading-anchor" href="#Profiling-(!!!)">Profiling (!!!)</a><a id="Profiling-(!!!)-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling-(!!!)" title="Permalink"></a></h3><pre><code class="language-julia hljs">julia&gt; using Profile

julia&gt; Profile.init(n = 10^7)

julia&gt; @profile for i in 1:100
           step!(lb)
       end
    
julia&gt; Profile.print()</code></pre><h3 id="Recording-the-simulation"><a class="docs-heading-anchor" href="#Recording-the-simulation">Recording the simulation</a><a id="Recording-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Recording-the-simulation" title="Permalink"></a></h3><pre><code class="language-julia hljs">record(fig, joinpath(@__DIR__, &quot;barrier.mp4&quot;), 1:100; framerate = 10) do i
    for i=1:20
        step!(lb)
    end
    vorticity[] = curl(momentum.(Ref(lb.config), lb.grid))&#39;
end</code></pre><h3 id="To-run"><a class="docs-heading-anchor" href="#To-run">To run</a><a id="To-run-1"></a><a class="docs-heading-anchor-permalink" href="#To-run" title="Permalink"></a></h3><p>Install dependencies</p><pre><code class="language-julia-pkg hljs">pkg&gt; activate(&quot;examples&quot;)

pkg&gt; dev .

pkg&gt; add Makie GLMakie BenchmarkTools</code></pre><p>Type <code>Backspace</code> to exit the package mode.</p><pre><code class="language-julia hljs">julia&gt; include(&quot;examples/barrier.jl&quot;)</code></pre><p>&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;   &lt;source src=&quot;barrier.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt;</p><p>Please find the video <code>barrier.mp4</code> in the same folder as this file if the video does not show up.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../julia-performance/">« Performance and Profile</a><a class="docs-footer-nextpage" href="../../chap3/array/">Array and Broadcasting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 27 February 2024 07:27">Tuesday 27 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
