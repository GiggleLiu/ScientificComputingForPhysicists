<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>My First Package · Scientific Computing For Physicists</title><meta name="title" content="My First Package · Scientific Computing For Physicists"/><meta property="og:title" content="My First Package · Scientific Computing For Physicists"/><meta property="twitter:title" content="My First Package · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap2/julia-release/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap2/julia-release/"/><link rel="canonical" href="https://book.jinguo-group.science/chap2/julia-release/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../julia-array/">Array and Broadcasting</a></li><li class="is-active"><a class="tocitem" href>My First Package</a><ul class="internal"><li><a class="tocitem" href="#Create-a-package"><span>Create a package</span></a></li><li><a class="tocitem" href="#Specify-the-dependency"><span>Specify the dependency</span></a></li><li><a class="tocitem" href="#Develop-the-package"><span>Develop the package</span></a></li><li><a class="tocitem" href="#Open-source-the-package"><span>Open-source the package</span></a></li><li><a class="tocitem" href="#Register-the-package"><span>Register the package</span></a></li><li><a class="tocitem" href="#Case-study:-The-file-structure-of-[OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl)"><span>Case study: The file structure of OMEinsum.jl</span></a></li></ul></li><li><a class="tocitem" href="../julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../chap3/linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../../chap3/lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/qr/">QR Factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../chap3/sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Tensors and Tensor Networks</span><ul><li><a class="tocitem" href="../../chap3/tensors/">Tensor Operations</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../chap4/optimization/">Optimization</a></li><li><a class="tocitem" href="../../chap4/ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Randomness</span><ul><li><a class="tocitem" href="../../chap5/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Julia Programming Language</a></li><li class="is-active"><a href>My First Package</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>My First Package</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap2/julia-release.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="My-First-Package"><a class="docs-heading-anchor" href="#My-First-Package">My First Package</a><a id="My-First-Package-1"></a><a class="docs-heading-anchor-permalink" href="#My-First-Package" title="Permalink"></a></h1><p>One of the most important features of Julia is its package manager. It allows one to create, manage, and publish his own packages. In this section, we will learn how to create a package and publish it to the Julia registry.</p><p>Julia package manager can install the correct version of a package and its dependencies because it knows the exact versions of all the packages that are compatible with each other. This information was stored in the <a href="https://github.com/JuliaRegistries/General"><code>General</code> registry</a> - a central GitHub repository of metadata about all registered Julia packages.</p><p>Everyone can register a package in the <code>General</code> registry. To do so, you need to:</p><ol><li><a href="#Create-a-package"><strong>Create a package</strong></a>.</li><li><a href="#Specify-the-dependency"><strong>Specify the dependency</strong></a> of your package in the <code>Project.toml</code> file, like which version of a package your package depends on.</li><li><a href="#Develop-the-package"><strong>Develop the package</strong></a> by writing the source code, tests, and documentation.</li><li><a href="#Open-source-the-package"><strong>Open-source the package</strong></a> by pushing the package to a public repository on GitHub. GitHub Actions can be used to automate the process of testing, building the documentation, and tagging a release so that other developers can contribute to the package easily.</li><li><a href="#Register-the-package"><strong>Register the package</strong></a> in the <code>General</code> registry by creating a pull request to the <code>General</code> registry.</li></ol><h2 id="Create-a-package"><a class="docs-heading-anchor" href="#Create-a-package">Create a package</a><a id="Create-a-package-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-package" title="Permalink"></a></h2><p>We use <a href="https://github.com/JuliaCI/PkgTemplates.jl"><code>PkgTemplate</code></a>. Open a Julia REPL and type the following commands to initialize a new package named <code>MyFirstPackage</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using PkgTemplates

julia&gt; tpl = Template(;
    user=&quot;GiggleLiu&quot;,  # replace!
    authors=&quot;GiggleLiu&quot;,  # replace!
    julia=v&quot;1.10&quot;,
    plugins=[
        License(; name=&quot;MIT&quot;),
        Git(; ssh=true),
        GitHubActions(; x86=true),
        Codecov(),
        Documenter{GitHubActions}(),
    ],
)

julia&gt; tpl(&quot;MyFirstPackage&quot;)</code></pre><p>where the username <code>&quot;GiggleLiu&quot;</code> should be replaced with your GitHub username. Many plugins are used in the above example:</p><ul><li><p><code>License</code>: to choose a license for the package. Here we use the MIT license, which is a permissive free software license. Popular licenses include:</p><ul><li><a href="https://en.wikipedia.org/wiki/MIT_License">MIT</a>: a permissive free software license, featured with a short and simple permissive license with conditions only requiring preservation of copyright and license notices.</li><li><a href="https://en.wikipedia.org/wiki/Apache_License">Apache2</a>: a permissive free software license, featured with a contributor license agreement and a patent grant.</li><li><a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">GPL</a>: a copyleft free software license, featured with a strong copyleft license that requires derived works to be available under the same license.</li></ul></li><li><p><code>Git</code>: to initialize a Git repository for the package. Here we use the SSH protocol for Git for convenience. Using <a href="https://docs.github.com/en/authentication/securing-your-account-with-two-factor-authentication-2fa/configuring-two-factor-authentication">two-factor authentication (2FA)</a> can make your GitHub account more secure.</p></li><li><p><code>GitHubActions</code>: to enable continuous integration (CI) with <a href="https://docs.github.com/en/actions">GitHub Actions</a>.</p></li><li><p><code>Codecov</code>: to enable code coverage tracking with <a href="https://about.codecov.io/">Codecov</a>. It is a tool that helps you to measure the test coverage of your code. A package with high test coverage is more reliable.</p></li><li><p><code>Documenter</code>: to enable documentation building and deployment with <a href="https://documenter.juliadocs.org/stable/">Documenter.jl</a> and <a href="https://pages.github.com/">GitHub pages</a>.</p></li></ul><p>After running the above commands, a new directory named <code>MyFirstPackage</code> will be created in the folder <code>~/.julia/dev/</code> - the default location for Julia packages.</p><div class="admonition is-info"><header class="admonition-header">What makes a good package name?</header><div class="admonition-body"><p>For a package that is intended to be registered in the <code>General</code> registry, it is recommended to use a name that follows the <a href="https://pkgdocs.julialang.org/v1/creating-packages/#Package-naming-guidelines">Julia package naming guidelines</a>. Although the same registry may not have two packages with the same name, a package use the <a href="https://docs.julialang.org/en/v1/stdlib/UUIDs/">UUID</a> rather than the name as its unique identifier, because name may not be unique when multiple registries are used together.</p></div></div><p>The file structure of the package is as follows:</p><pre><code class="language-bash hljs">tree .   
.
├── .git
│   ...
├── .github
│   ├── dependabot.yml
│   └── workflows
│       ├── CI.yml
│       ├── CompatHelper.yml
│       └── TagBot.yml
├── .gitignore
├── LICENSE
├── Manifest.toml
├── Project.toml
├── README.md
├── docs
│   ├── Manifest.toml
│   ├── Project.toml
│   ├── make.jl
│   └── src
│       └── index.md
├── src
│   └── MyFirstPackage.jl
└── test
    └── runtests.jl</code></pre><ul><li><code>.git</code> and <code>.gitignore</code>: the files that are used by Git. The <code>.gitingore</code> file contains the files that should be ignored by Git. By default, the <code>.gitignore</code> file contains the following lines:<pre><code class="language-gitignore hljs">*.jl.*.cov
*.jl.cov
*.jl.mem
/Manifest.toml
/docs/Manifest.toml
/docs/build/</code></pre></li><li><code>.github</code>: the folder that contains the GitHub Actions configuration files.</li><li><code>LICENSE</code>: the file that contains the license of the package. The MIT license is used in this package.</li><li><code>README.md</code>: the manual that shows up in the GitHub repository of the package, which contains the description of the package.</li><li><code>Project.toml</code>: the file that contains the metadata of the package, including the name, UUID, version, dependencies and compatibility of the package.</li><li><code>Manifest.toml</code>: the file that contains the exact versions of all the packages that are compatible with each other. It is usually automatically resolved from the <code>Project.toml</code> file, and it is not recommended pushing it to the remote repository.</li><li><code>docs</code>: the folder that contains the documentation of the package. It has its own <code>Project.toml</code> and <code>Manifest.toml</code> files, which are used to manage the documentation environment. The <code>make.jl</code> file is used to build the documentation and the <code>src</code> folder contains the source code of the documentation.</li><li><code>src</code>: the folder that contains the source code of the package.</li><li><code>test</code>: the folder that contains the test code of the package, which contains the main test file <code>runtests.jl</code>.</li></ul><h2 id="Specify-the-dependency"><a class="docs-heading-anchor" href="#Specify-the-dependency">Specify the dependency</a><a id="Specify-the-dependency-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-the-dependency" title="Permalink"></a></h2><p>The file that contains the metadata of the package, including the name, UUID, version, dependencies and compatibility of the package. To <strong>add a new dependency</strong>, you can use the following command in the package path:</p><pre><code class="language-bash hljs">$ cd ~/.julia/dev/MyFirstPackage

$ julia --project</code></pre><p>This will open a Julia REPL in the package environment. To check the package environment, you can type the following commands in the package mode (press <code>]</code>) of the REPL:</p><pre><code class="language-julia-repl hljs">(MyFirstPackage) pkg&gt; st
Project MyFirstPackage v1.0.0-DEV
Status `~/.julia/dev/MyFirstPackage/Project.toml` (empty project)</code></pre><p>After that, you can add a new dependency by typing:</p><pre><code class="language-julia-repl hljs">(MyFirstPackage) pkg&gt; add LinearAlgebra

(MyFirstPackage) pkg&gt; st
Project MyFirstPackage v1.0.0-DEV
Status `~/jcode/ScientificComputingForPhysicists/lib/MyFirstPackage/Project.toml`
  [37e2e46d] LinearAlgebra</code></pre><p>The dependency is added correctly if no error is thrown. Press <code>backspace</code> to exit the package mode.</p><p>Type <code>;</code> to enter the shell mode and then type</p><pre><code class="language-julia-repl hljs">shell&gt; cat Project.toml
name = &quot;MyFirstPackage&quot;
uuid = &quot;594718ca-da39-4ff3-a299-6d8961b2aa49&quot;
authors = [&quot;GiggleLiu&quot;]
version = &quot;1.0.0-DEV&quot;

[deps]
LinearAlgebra = &quot;37e2e46d-f89d-539d-b4ee-838fcccc9c8e&quot;

[compat]
julia = &quot;1.10&quot;

[extras]
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [&quot;Test&quot;]</code></pre><p>You will see that the dependency <code>LinearAlgebra</code> is added to the <code>[deps]</code> section of the <code>Project.toml</code> file.</p><p>We also need to specify which version of <code>LinearAlgebra</code> is <strong>compatible</strong> with the current package. To do so, you need to edit the <code>[compat]</code> section of the <code>Project.toml</code> file with your favorite editor.</p><pre><code class="nohighlight hljs">[compat]
julia = &quot;1.10&quot;
LinearAlgebra = &quot;1&quot;  # added line</code></pre><p>Here, we have used the most widely used dependency version specifier <code>=</code>, which means matching the first nonzero component of the version number. For example:</p><ul><li><code>1</code> matches <code>1.0.0</code>, <code>1.1.0</code>, <code>1.1.1</code>, but not <code>2.0.0</code>.</li><li><code>0.8</code> matches <code>0.8.0</code>, <code>0.8.1</code>, <code>0.8.2</code>, but not <code>0.9.0</code> or <code>0.7.0</code>.</li><li><code>1.2</code> matches <code>1.2.0</code>, <code>1.3.1</code>, but not <code>1.1.0</code> or <code>2.0.0</code>.</li></ul><p>The validity of specifying compatibility is based on the consensus among the developers:</p><ul><li>whenever an exported function is changed in a package, the first nonzero component of the version number should be increased.</li><li>version number starts with <code>0</code> is considered as a development version, and it is not stable.</li></ul><p>Please check the Julia documentation about <a href="https://pkgdocs.julialang.org/v1/compatibility/">package compatibility</a> for advanced usage.</p><h2 id="Develop-the-package"><a class="docs-heading-anchor" href="#Develop-the-package">Develop the package</a><a id="Develop-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Develop-the-package" title="Permalink"></a></h2><p>Developers develop packages in the package environment. The package development process includes:</p><h3 id="1.-Edit-the-source-code"><a class="docs-heading-anchor" href="#1.-Edit-the-source-code">1. Edit the source code</a><a id="1.-Edit-the-source-code-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Edit-the-source-code" title="Permalink"></a></h3><p>The source code of the package is located in the <code>src</code> folder of the package path.</p><p>Let us add a simple function to the package. The source code of the package is as follows:</p><p><em>File</em>: <code>src/MyFirstPackage.jl</code></p><pre><code class="language-julia hljs">module MyFirstPackage
# import packages
using LinearAlgebra

# export interfaces
export Lorenz, integrate_step
export Point, Point2D, Point3D
export RungeKutta, Euclidean

# `include` other source files into this module
include(&quot;lorenz.jl&quot;)

end</code></pre><p>The <code>include(&quot;lorenz.jl&quot;)</code> line includes the source code of the <a href="https://en.wikipedia.org/wiki/Lorenz_system"><code>Lorenz</code></a> system, which can be defined in the <code>lorenz.jl</code> file in the same folder. The source code of is as follows:</p><p><em>File</em>: <code>src/lorenz.jl</code></p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    Point{D, T}

A point in D-dimensional space, with coordinates of type T.

# Examples
```jldoctest
julia&gt; p1 = Point(1.0, 2.0)
Point{2, Float64}((1.0, 2.0))

julia&gt; p2 = Point(3.0, 4.0)
Point{2, Float64}((3.0, 4.0))

julia&gt; p1 + p2
Point{2, Float64}((4.0, 6.0))
```
&quot;&quot;&quot;
# define a point in D-dimensional space
struct Point{D, T &lt;: Real}
    data::NTuple{D, T}  # a tuple of D elements of type T
end
Point(x::Real...) = Point((x...,))  # `...` is the splat operator
# define 2D and 3D points
const Point2D{T} = Point{2, T}
const Point3D{T} = Point{3, T}

# define the dot product of two coordinate vectors
# `mapreduce` is a high-order function that applies a function to each element 
# of an iterable and then reduces the result to a single value.
LinearAlgebra.dot(x::Point, y::Point) = mapreduce(*, +, x.data, y.data)
# implement the operations of the point
# `Base` is the standard library of Julia
# `Base.isapprox` is used to define a new method for the function `isapprox` in the `Base` module
# for arithmetic operations like `*`, `*`, `+`, an extra `:` is required to avoid ambiguity
Base.:*(x::Real, y::Point) = Point(x .* y.data) # `.` is the broadcast operator
Base.:/(y::Point, x::Real) = Point(y.data ./ x)
Base.:+(x::Point, y::Point) = Point(x.data .+ y.data)
Base.isapprox(x::Point, y::Point; kwargs...) = all(isapprox.(x.data, y.data; kwargs...))
# `all` returns true if all elements of the iterable are true

# define the index and broadcastable functions
Base.getindex(p::Point, i::Int) = p.data[i] # for `p[i]` like operations
Base.broadcastable(p::Point) = p.data # for `x .+ y` like operations
Base.iterate(p::Point, args...) = iterate(p.data, args...) # for `[p...]` like operations

# the Lorenz system
struct Lorenz
    σ::Float64
    ρ::Float64
    β::Float64
end

# the differential equation of the Lorenz system
function field(p::Lorenz, u)
    x, y, z = u
    Point(p.σ*(y-x), x*(p.ρ-z)-y, x*y-p.β*z)
end

# abstract type for integrators, which allows us to switch between different integration methods
abstract type AbstractIntegrator end
# Runge-Kutta 4th order method
# https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods
struct RungeKutta{K} &lt;: AbstractIntegrator end
# Euclidean method
struct Euclidean &lt;: AbstractIntegrator end

function integrate_step(f, ::RungeKutta{4}, t, y, Δt)
    k1 = Δt * f(t, y)
    k2 = Δt * f(t+Δt/2, y + k1 / 2)
    k3 = Δt * f(t+Δt/2, y + k2 / 2)
    k4 = Δt * f(t+Δt, y + k3)
    return y + k1/6 + k2/3 + k3/3 + k4/6
end

# Euclidean integration
function integrate_step(f, ::Euclidean, t, y, Δt)
    return y + Δt * f(t, y)
end

function integrate_step(lz::Lorenz, int::AbstractIntegrator, u, Δt)
    return integrate_step((t, u) -&gt; field(lz, u), int, zero(Δt), u, Δt)
end</code></pre><p>To use this function, you can type the following commands in the <strong>package environment</strong>:</p><pre><code class="language-julia-repl hljs">julia&gt; using MyFirstPackage

julia&gt; Point(2.0, 3.0)
Point2D{Float64}((2.0, 3.0))</code></pre><div class="admonition is-info"><header class="admonition-header">How to enter package environment?</header><div class="admonition-body"><ul><li>In shell: type<pre><code class="language-bash hljs">$ cd ~/.julia/dev/MyFirstPackage
$ julia --project</code></pre></li><li>In REPL: press <code>]</code> to enter the package mode and then type<pre><code class="language-julia-repl hljs">pkg&gt; activate path/to/package</code></pre>to enter the package environment. To deactivate the package environment, type<pre><code class="language-julia-repl hljs">pkg&gt; activate</code></pre></li><li>In VSCode: Click the <code>Julia env: ...</code> button in the bottom of the window and then select the package path.</li></ul></div></div><h3 id="2.-Write-tests"><a class="docs-heading-anchor" href="#2.-Write-tests">2. Write tests</a><a id="2.-Write-tests-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Write-tests" title="Permalink"></a></h3><p>We always need to write tests for the package. The test code of the package is located in the <code>test</code> folder of the package path.</p><p><em>File</em>: <code>test/runtests.jl</code></p><pre><code class="language-julia hljs">using Test
using MyFirstPackage

@testset &quot;lorenz&quot; begin
    include(&quot;lorenz.jl&quot;)
end</code></pre><p><em>File</em>: <code>test/lorenz.jl</code></p><pre><code class="language-julia hljs">using Test, MyFirstPackage

@testset &quot;Point&quot; begin
    p1 = Point(1.0, 2.0)
    p2 = Point(3.0, 4.0)
    @test p1 + p2 ≈ Point(4.0, 6.0)
end

@testset &quot;step&quot; begin
    lz = Lorenz(10.0, 28.0, 8/3)
    int = RungeKutta{4}()
    r1 = integrate_step(lz, int, Point(1.0, 1.0, 1.0), 0.0001)
    eu = Euclidean()
    r2 = integrate_step(lz, eu, Point(1.0, 1.0, 1.0), 0.0001)
    @test isapprox(r1, r2; rtol=1e-5)
end</code></pre><p>To run the tests, you can use the following command in the package environment:</p><pre><code class="language-julia-repl hljs">(MyFirstPackage) pkg&gt; test
  ... 
  [8e850b90] libblastrampoline_jll v5.8.0+1
Precompiling project...
  1 dependency successfully precompiled in 1 seconds. 2 already precompiled.
     Testing Running tests...
Test Summary: | Pass  Total  Time
lorenz        |    2      2  0.1s
Test Summary: | Pass  Total  Time
fluid         |    1      1  0.1s
     Testing MyFirstPackage tests passed</code></pre><p>Cheers! All tests passed.</p><p>You might want to write some examples to visualize the results of the package with <a href="https://github.com/MakieOrg/Makie.jl">Makie</a>. We create an <code>examples</code> folder in the package path and then write the following example code</p><p><em>File</em>: <code>examples/lorenz.jl</code></p><pre><code class="language-julia hljs">using CairoMakie, MyFirstPackage
set_theme!(theme_black())

# create a Lorenz system
lz = Lorenz(10, 28, 8/3)

# initial condition
y = MyFirstPackage.Point(1.0, 1.0, 1.0)
 
# `Observable` defines the signal that can be used to update plots efficiently
points = Observable(Point3f[])
colors = Observable(Int[])

# create a figure
fig, ax, l = lines(points, color = colors,
    colormap = :inferno, transparency = true, 
    axis = (; type = Axis3, protrusions = (0, 0, 0, 0), 
              viewmode = :fit, limits = (-30, 30, -30, 30, 0, 50)))

record(fig, &quot;lorenz.mp4&quot;, 1:120) do frame
    global y
    for i in 1:50
        # update arrays inplace
        y = integrate_step(lz, RungeKutta{4}(), y, 0.01)
        push!(points[], Point3f(y...))
        push!(colors[], frame)
    end
    ax.azimuth[] = 1.7pi + 0.3 * sin(2pi * frame / 120) # set the view angle of the axis
    notify(points); notify(colors) # tell points and colors that their value has been updated
    l.colorrange = (0, frame) # update plot attribute directly
end</code></pre><p>It output a video file <code>lorenz.mp4</code> that visualizes the Lorenz system: <img src="../../assets/images/lorenz.gif" alt/></p><h3 id="3.-Write-documentation"><a class="docs-heading-anchor" href="#3.-Write-documentation">3. Write documentation</a><a id="3.-Write-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Write-documentation" title="Permalink"></a></h3><p>The documentation is built with <a href="https://documenter.juliadocs.org/stable/">Documenter.jl</a>. The build script is <code>docs/make.jl</code>. To <strong>build the documentation</strong>, you can first enter the package environment and then type the following commands in a terminal:</p><pre><code class="language-bash hljs">$ cd docs
$ julia --project</code></pre><p>Instantiate or update the documentation environment if necessary. </p><pre><code class="language-julia-repl hljs">(docs) pkg&gt; dev ..

(docs) pkg&gt; instantiate # or `up`</code></pre><p>where <code>dev ..</code> is used to add the <code>MyFirstPackage</code> under development to the documentation environment.</p><p>Then build the documentation by typing</p><pre><code class="language-julia-repl hljs">julia&gt; include(&quot;make.jl&quot;)</code></pre><p>where <code>include</code> is a built-in function in Julia that includes the source code of the documentation build file <code>make.jl</code> into the current environment.</p><p>The generated HTML files are located in the <code>docs/build</code> folder of the package path. To preview the documentation, just open the <code>index.html</code> file in a web browser.</p><div class="admonition is-info"><header class="admonition-header">Live preview of documentation</header><div class="admonition-body"><p>For seamless <strong>previewing</strong> of documentation on updates, it is highly recommended using the <a href="https://github.com/tlienart/LiveServer.jl">LiveServer.jl</a> package.</p></div></div><h2 id="Open-source-the-package"><a class="docs-heading-anchor" href="#Open-source-the-package">Open-source the package</a><a id="Open-source-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Open-source-the-package" title="Permalink"></a></h2><p>To open-source the package, you need to push the package to a public repository on GitHub.</p><ol><li><p>First create a GitHub repository with the same name as the package. In this example, the repository name should be <code>MyFirstPackage.jl</code>. To check the remote repository of the package, you can use the following command in the package path:</p><pre><code class="language-bash hljs">$ git remote -v
origin	git@github.com:GiggleLiu/MyFirstPackage.jl.git (fetch)
origin	git@github.com:GiggleLiu/MyFirstPackage.jl.git (push)</code></pre></li><li><p>Then push the package to the remote repository:</p><pre><code class="language-bash hljs">$ git add -A
$ git commit -m &quot;Initial commit&quot;
$ git push</code></pre></li><li><p>After that, you need to check if all your GitHub Actions are passing. You can check the status of the GitHub Actions from the badge in the <code>README.md</code> file of the package repository. The configuration of GitHub Actions is located in the <code>.github/workflows</code> folder of the package path. Its file structure is as follows:</p><pre><code class="language-bash hljs">.github
├── dependabot.yml
└── workflows
    ├── CI.yml
    ├── CompatHelper.yml
    └── TagBot.yml</code></pre><ul><li>The <code>CI.yml</code> file contains the configuration for the CI of the package, which is used to automate the process of<ul><li><strong>Testing</strong> the package after a pull request is opened, or the main branch is updated. This process can be automated with the <a href="https://github.com/julia-actions/julia-runtest">julia-runtest</a> action.</li><li>Building the <strong>documentation</strong> after the main branch is updated. Please check the <a href="https://documenter.juliadocs.org/stable/man/hosting/">Documenter documentation</a> for more information.</li></ul></li><li>The <code>TagBot.yml</code> file contains the configuration for the <a href="https://github.com/JuliaRegistries/TagBot">TagBot</a>, which is used to automate the process of tagging a release after a pull request is merged.</li><li>The <code>CompatHelper.yml</code> file contains the configuration for the <a href="https://github.com/JuliaRegistries/CompatHelper.jl">CompatHelper</a>, which is used to automate the process of updating the <code>[compat]</code> section of the <code>Project.toml</code> file after a pull request is merged.</li></ul><p>Configuring GitHub Actions is a bit complicated. For beginners, it is a good practise to mimic the configuration of another package, e.g. <a href="https://github.com/under-Peter/OMEinsum.jl">OMEinsum.jl</a>.</p></li></ol><h2 id="Register-the-package"><a class="docs-heading-anchor" href="#Register-the-package">Register the package</a><a id="Register-the-package-1"></a><a class="docs-heading-anchor-permalink" href="#Register-the-package" title="Permalink"></a></h2><p>Once your package is ready to be published, you need to register the package in the <a href="https://github.com/JuliaRegistries/General"><code>General</code></a> registry. The <code>General</code> registry is a central GitHub repository of metadata about all registered Julia packages. To register the package, you need to create a pull request to the <code>General</code> registry and wait for the pull request to be reviewed and merged. This process can be automated by the <a href="https://github.com/JuliaRegistries/Registrator.jl">Julia registrator</a>. If the pull request meets all guidelines, your pull request will be merged after a few days. Then, your package is available to the public. </p><p>A good practice is to <strong>tag a release</strong> after the pull request is merged so that your package version update can be reflected in your GitHub repository. This process can be automated by the <a href="https://github.com/JuliaRegistries/TagBot">TagBot</a>.</p><h2 id="Case-study:-The-file-structure-of-[OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl)"><a class="docs-heading-anchor" href="#Case-study:-The-file-structure-of-[OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl)">Case study: The file structure of <a href="https://github.com/under-Peter/OMEinsum.jl">OMEinsum.jl</a></a><a id="Case-study:-The-file-structure-of-[OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#Case-study:-The-file-structure-of-[OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl)" title="Permalink"></a></h2><p><img src="../../assets/images/omeinsum.png" alt/></p><p><code>OMEinsum.jl</code> is a package for tensor contraction. The badges in the <code>README.md</code> file of the package repository are the following:</p><ul><li><code>build/passing</code>: the tests executed by GitHub Actions are passing.</li><li><code>codecov/89%</code>: the code coverage is 89%, meaning that 89% of the code is covered by tests.</li><li><code>docs/dev</code>: the documentation is built and deployed with GitHub pages.</li></ul><p>Now, let&#39;s take a look at the file structure of the package by running the following command in the package path (<code>~/.julia/dev/OMEinsum</code>):</p><pre><code class="language-bash hljs">$ tree . -L 1 -a
.
├── .git
├── .github
├── .gitignore
├── LICENSE
├── Project.toml
├── README.md
├── benchmark
├── docs
├── examples
├── ext
├── ome-logo.png
├── src
└── test</code></pre><p><em>File</em>: <code>Project.toml</code></p><pre><code class="language-toml hljs">name = &quot;OMEinsum&quot;
uuid = &quot;ebe7aa44-baf0-506c-a96f-8464559b3922&quot;
authors = [&quot;Andreas Peter &lt;andreas.peter.ch@gmail.com&gt;&quot;]
version = &quot;0.8.1&quot;

[deps]
AbstractTrees = &quot;1520ce14-60c1-5f80-bbc7-55ef81b5835c&quot;
BatchedRoutines = &quot;a9ab73d0-e05c-5df1-8fde-d6a4645b8d8e&quot;
ChainRulesCore = &quot;d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4&quot;
Combinatorics = &quot;861a8166-3701-5b0c-9a16-15d98fcdc6aa&quot;
LinearAlgebra = &quot;37e2e46d-f89d-539d-b4ee-838fcccc9c8e&quot;
MacroTools = &quot;1914dd2f-81c6-5fcd-8719-6d5c9610ff09&quot;
OMEinsumContractionOrders = &quot;6f22d1fd-8eed-4bb7-9776-e7d684900715&quot;
TupleTools = &quot;9d95972d-f1c8-5527-a6e0-b4b365fa01f6&quot;

[weakdeps]
CUDA = &quot;052768ef-5323-5732-b1bb-66c8b64840ba&quot;

[extensions]
CUDAExt = &quot;CUDA&quot;

[compat]
AbstractTrees = &quot;0.3, 0.4&quot;
BatchedRoutines = &quot;0.2&quot;
CUDA = &quot;4, 5&quot;
ChainRulesCore = &quot;1&quot;
Combinatorics = &quot;1.0&quot;
MacroTools = &quot;0.5&quot;
OMEinsumContractionOrders = &quot;0.8&quot;
TupleTools = &quot;1.2, 1.3&quot;
julia = &quot;1&quot;

[extras]
Documenter = &quot;e30172f5-a6a5-5a46-863b-614d45cd2de4&quot;
DoubleFloats = &quot;497a8b3b-efae-58df-a0af-a86822472b78&quot;
ForwardDiff = &quot;f6369f11-7733-5829-9624-2563aa707210&quot;
LinearAlgebra = &quot;37e2e46d-f89d-539d-b4ee-838fcccc9c8e&quot;
Polynomials = &quot;f27b6e38-b328-58d1-80ce-0feddd5e7a45&quot;
ProgressMeter = &quot;92933f4c-e287-5a05-a399-4b506db050ca&quot;
Random = &quot;9a3f8284-a2c9-5f02-9a11-845980a1fd5c&quot;
SymEngine = &quot;123dc426-2d89-5057-bbad-38513e3affd8&quot;
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;
TropicalNumbers = &quot;b3a74e9c-7526-4576-a4eb-79c0d4c32334&quot;
Zygote = &quot;e88e6eb3-aa80-5325-afca-941959d7151f&quot;

[targets]
test = [&quot;Test&quot;, &quot;Documenter&quot;, &quot;LinearAlgebra&quot;, &quot;ProgressMeter&quot;, &quot;SymEngine&quot;, &quot;Random&quot;, &quot;Zygote&quot;, &quot;DoubleFloats&quot;, &quot;TropicalNumbers&quot;, &quot;ForwardDiff&quot;, &quot;Polynomials&quot;, &quot;CUDA&quot;]</code></pre><p>It contains the following more sections:</p><ul><li><code>[weakdeps]</code> and <code>[extensions]</code>: the sections that specify the extensions of the package, which is related with the files in the <code>ext</code> folder. A package &quot;extension&quot; is a module that is automatically loaded when a specified set of other packages (its &quot;extension dependencies&quot;) are loaded in the current Julia session. As a using case, consider you want to add the CUDA support to your package, but you don&#39;t want to force all users to install <code>CUDA</code> package if they don&#39;t need it, then adding <code>CUDA</code> as a weak dependency and move this feature <code>ext</code> folder is a good choice. Please check the Julia documentation about <a href="https://docs.julialang.org/en/v1/manual/code-loading/#man-extensions">package extensions</a> for more information.</li><li><code>[extras]</code> and <code>[targets]</code>: the section that specifies the extra dependencies of the package that used to test the package. One can also specify the extra dependencies for the test environment in the <code>test</code> folder of the package path.</li></ul><p><em>Quiz</em>: </p><ol><li>Is <code>ChainRulesCore</code> at version 1.2 compatible with <code>OMEinsum</code>?</li><li>If <code>ChainRulesCore</code> at version 2.0 is released, what should be done to make <code>OMEinsum</code> compatible with the new version of <code>ChainRulesCore</code>? Which GitHub Action is used to automate this process?</li><li>If an author of <code>OMEinsum</code> fixed a bug, what should be done to make the new version of <code>OMEinsum</code> available to the public?</li><li>If an author of <code>OMEinsum</code> changed an exported function, what should be done to make the new version of <code>OMEinsum</code> available to the public?</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../julia-array/">« Array and Broadcasting</a><a class="docs-footer-nextpage" href="../julia-fluid/">Project: Fluid dynamics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 16 April 2024 03:09">Tuesday 16 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
