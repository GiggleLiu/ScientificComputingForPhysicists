<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Multiple-dispatch · Scientific Computing For Physicists</title><meta name="title" content="Types and Multiple-dispatch · Scientific Computing For Physicists"/><meta property="og:title" content="Types and Multiple-dispatch · Scientific Computing For Physicists"/><meta property="twitter:title" content="Types and Multiple-dispatch · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap2/julia-type/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap2/julia-type/"/><link rel="canonical" href="https://book.jinguo-group.science/chap2/julia-type/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../julia-why/">Why Julia?</a></li><li class="is-active"><a class="tocitem" href>Types and Multiple-dispatch</a><ul class="internal"><li><a class="tocitem" href="#Julia-Types"><span>Julia Types</span></a></li><li><a class="tocitem" href="#Multiple-dispatch"><span>Multiple dispatch</span></a></li><li><a class="tocitem" href="#Example:-Julia-number-system"><span>Example: Julia number system</span></a></li><li><a class="tocitem" href="#Example:-Computing-Fibonacci-number-at-compile-time"><span>Example: Computing Fibonacci number at compile time</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../julia-release/">My First Package</a></li><li><a class="tocitem" href="../julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../chap3/linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../../chap3/lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/qr/">QR Factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../chap3/sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Tensors and Tensor Networks</span><ul><li><a class="tocitem" href="../../chap3/tensors/">Tensor Operations</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../chap4/optimization/">Optimization</a></li><li><a class="tocitem" href="../../chap4/ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Randomness</span><ul><li><a class="tocitem" href="../../chap5/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Julia Programming Language</a></li><li class="is-active"><a href>Types and Multiple-dispatch</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Multiple-dispatch</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap2/julia-type.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Types-and-Multiple-dispatch"><a class="docs-heading-anchor" href="#Types-and-Multiple-dispatch">Types and Multiple-dispatch</a><a id="Types-and-Multiple-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-Multiple-dispatch" title="Permalink"></a></h1><h2 id="Julia-Types"><a class="docs-heading-anchor" href="#Julia-Types">Julia Types</a><a id="Julia-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Types" title="Permalink"></a></h2><p>Julia has rich type system, which is not limited to the <strong>primitive types</strong> that supported by the hardware. The type system is the key to the <strong>multiple dispatch</strong> feature of Julia.</p><p>As an example, let us consider the type for complex numbers.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Complex{Float64}</code><code class="nohighlight hljs ansi" style="display:block;">ComplexF64<span class="sgr90"> (alias for Complex{Float64})</span></code></pre><p>where <code>Float64</code> is the <strong>type parameter</strong> of <code>Complex</code>. Type parameters are a part of a type, without which the type is not fully specified. A fully specified type is called a <strong>concrete type</strong>, which has a fixed memory layout and can be instantiated in memory. For example, the <code>Complex{Float64}</code> consists of two fields of type <code>Float64</code>, which are the real and imaginary parts of the complex number.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(Complex{Float64})</code><code class="nohighlight hljs ansi" style="display:block;">(:re, :im)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldtypes(Complex{Float64})</code><code class="nohighlight hljs ansi" style="display:block;">(Float64, Float64)</code></pre><p>Extending the example, we can define the type for a matrix of complex numbers.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Array{Complex{Float64}, 2}</code><code class="nohighlight hljs ansi" style="display:block;">Matrix{ComplexF64}<span class="sgr90"> (alias for Array{Complex{Float64}, 2})</span></code></pre><p><code>Array</code> type has two type parameters, the first one is the <strong>element type</strong> and the second one is the <strong>dimension</strong> of the array.</p><p>One can get the type of value with <code>typeof</code> function.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(1+2im)</code><code class="nohighlight hljs ansi" style="display:block;">Complex{Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(randn(Complex{Float64}, 2, 2))</code><code class="nohighlight hljs ansi" style="display:block;">Matrix{ComplexF64}<span class="sgr90"> (alias for Array{Complex{Float64}, 2})</span></code></pre><p>Then, what the type of a type?</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Complex{Float64})</code><code class="nohighlight hljs ansi" style="display:block;">DataType</code></pre><p>There is a very special type: <code>Tuple</code>, which is different from regular types in the following ways:</p><ul><li>Tuple types may have any number of parameters.</li><li>Tuple types are covariant in their parameters: <code>Tuple{Int}</code> is a subtype of <code>Tuple{Any}</code>. Therefore <code>Tuple{Any}</code> is considered an abstract type, and tuple types are only concrete if their parameters are.</li><li>Tuples do not have field names; fields are only accessed by index.</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; tp = (1, 2.0, &#39;c&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">(1, 2.0, &#39;c&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(tp)</code><code class="nohighlight hljs ansi" style="display:block;">Tuple{Int64, Float64, Char}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tp[2]</code><code class="nohighlight hljs ansi" style="display:block;">2.0</code></pre><h2 id="Multiple-dispatch"><a class="docs-heading-anchor" href="#Multiple-dispatch">Multiple dispatch</a><a id="Multiple-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-dispatch" title="Permalink"></a></h2><p><strong>Multiple dispatch</strong> is a feature of some programming languages in which a function or method can be dynamically dispatched based on the <strong>run-time</strong> type. The <strong>dispatch</strong> is the process of selecting the method to invoke based on the type of the arguments.</p><p>We first define of an abstract type <code>AbstractAnimal</code> with the keyword <code>abstract type</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; abstract type AbstractAnimal{L} end</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>where the type parameter <code>L</code> stands for the number of legs. Defining the number of legs as a type parameter or a field of a concrete type is a design choice. Providing more information in the type system can help the compiler to optimize the code, but it can also make the compiler generate more code.</p><p>Abstract types can have subtypes. In the following we define a concrete subtype type <code>Dog</code> with 4 legs, which is a subtype of <code>AbstractAnimal{4}</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Dog &lt;: AbstractAnimal{4}
       	color::String
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>where <code>&lt;:</code> is the symbol for sybtyping， <code>A &lt;: B</code> means A is a subtype of B. Concrete types can have fields, which are the data members of the type. However, they can not have subtypes.</p><p>Similarly, we define a <code>Cat</code> with 4 legs, a <code>Cock</code> with 2 legs and a <code>Human</code> with 2 legs.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Cat &lt;: AbstractAnimal{4}
       	color::String
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Cock &lt;: AbstractAnimal{2}
       	gender::Bool
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Human{FT &lt;: Real} &lt;: AbstractAnimal{2}
       	height::FT
       	function Human(height::T) where T &lt;: Real
       		if height &lt;= 0 || height &gt; 300
       			error(&quot;The tall of a Human being must be in range 0~300, got $(height)&quot;)
       		end
       		return new{T}(height)
       	end
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Here, the <code>Human</code> type has its own constructor. The <code>new</code> function is the default constructor.</p><p>We can define a <strong>fall back method</strong> <code>fight</code> on the abstract type <code>AbstractAnimal</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(a::AbstractAnimal, b::AbstractAnimal) = &quot;draw&quot;</code><code class="nohighlight hljs ansi" style="display:block;">fight (generic function with 1 method)</code></pre><p>where <code>::</code> is a type assertion. This function will be invoked if two subtypes of <code>AbstractAnimal</code> are fed into the function <code>fight</code> and no more <strong>explicit</strong> methods are defined.</p><p>We can define many more explicit methods with the same name.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(dog::Dog, cat::Cat) = &quot;win&quot;</code><code class="nohighlight hljs ansi" style="display:block;">fight (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(hum::Human, a::AbstractAnimal) = &quot;win&quot;</code><code class="nohighlight hljs ansi" style="display:block;">fight (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(hum::Human, a::Union{Dog, Cat}) = &quot;loss&quot;</code><code class="nohighlight hljs ansi" style="display:block;">fight (generic function with 4 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(hum::AbstractAnimal, a::Human) = &quot;loss&quot;</code><code class="nohighlight hljs ansi" style="display:block;">fight (generic function with 5 methods)</code></pre><p>where <code>Union{Dog, Cat}</code> is a <strong>union type</strong>. It is a type that can be either <code>Dog</code> or <code>Cat</code>. <code>Union</code> types are not concrete since they do not have a fixed memory layout, meanwhile, they can not be subtyped! Here, we defined 5 methods for the function <code>fight</code>. However, defining too many methods for the same function can be dangerous. You need to be careful about the ambiguity error!</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(Human(170), Human(180))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: fight(::Main.Human{Int64}, ::Main.Human{Int64}) is ambiguous.

Candidates:
  fight(<span class="sgr90">hum</span>::<span class="sgr1">Main.AbstractAnimal</span>, <span class="sgr90">a</span>::<span class="sgr1">Main.Human</span>)
<span class="sgr90">    @</span> <span class="sgr90">Main</span> <span class="sgr90"><span class="sgr4">REPL[4]:1</span></span>
  fight(<span class="sgr90">hum</span>::<span class="sgr1">Main.Human</span>, <span class="sgr90">a</span>::<span class="sgr1">Main.AbstractAnimal</span>)
<span class="sgr90">    @</span> <span class="sgr90">Main</span> <span class="sgr90"><span class="sgr4">REPL[2]:1</span></span>

Possible fix, define
  fight(::Main.Human, ::Main.Human)</code></pre><p>It makes sense because we claim <code>Human</code> wins any other animals, but we also claim any animal losses to <code>Human</code>. When it comes to two <code>Human</code>s, the two functions are equally valid. To resolve the ambiguity, we can define a new method for the function <code>fight</code> as follows.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(hum::Human{T}, hum2::Human{T}) where T&lt;:Real = hum.height &gt; hum2.height ? &quot;win&quot; : &quot;loss&quot;</code><code class="nohighlight hljs ansi" style="display:block;">fight (generic function with 6 methods)</code></pre><p>Now, we can test the function <code>fight</code> with different combinations of animals.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(Cock(true), Cat(&quot;red&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;draw&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(Dog(&quot;blue&quot;), Cat(&quot;white&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;win&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(Human(180), Cat(&quot;white&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;loss&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fight(Human(170), Human(180))</code><code class="nohighlight hljs ansi" style="display:block;">&quot;loss&quot;</code></pre><p>Quiz: How many method instances are generated for fight so far?</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using MethodAnalysis</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; methodinstances(fight)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Core.MethodInstance}:
 MethodInstance for Main.fight(::Main.Dog, ::Main.Cat)
 MethodInstance for Main.fight(::Main.Human{Int64}, ::Main.Human{Int64})
 MethodInstance for Main.fight(::Main.Human{Int64}, ::Main.Cat)
 MethodInstance for Main.fight(::Main.Cock, ::Main.Cat)</code></pre><h2 id="Example:-Julia-number-system"><a class="docs-heading-anchor" href="#Example:-Julia-number-system">Example: Julia number system</a><a id="Example:-Julia-number-system-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Julia-number-system" title="Permalink"></a></h2><p>The Julia type system is a tree, and <code>Any</code> is the root of type tree, i.e. it is a super type of any other type. The <code>Number</code> type is the root type of Julia number system, which is also a subtype of <code>Any</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Number &lt;: Any</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>The type tree rooted on <code>Number</code> looks like:</p><pre><code class="nohighlight hljs">Number
├─ Base.MultiplicativeInverses.MultiplicativeInverse{T}
│  ├─ Base.MultiplicativeInverses.SignedMultiplicativeInverse{T&lt;:Signed}
│  └─ Base.MultiplicativeInverses.UnsignedMultiplicativeInverse{T&lt;:Unsigned}
├─ Complex{T&lt;:Real}
├─ Real
│  ├─ AbstractFloat
│  │  ├─ BigFloat
│  │  ├─ Float16
│  │  ├─ Float32
│  │  └─ Float64
│  ├─ AbstractIrrational
...</code></pre><p>There are utilities to analyze the type tree:</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; subtypes(Number)</code><code class="nohighlight hljs ansi" style="display:block;">7-element Vector{Any}:
 Base.MultiplicativeInverses.MultiplicativeInverse
 Complex
 DualNumbers.Dual
 ExactPredicates.Codegen.Formula
 MakieCore.Unit
 Mods.AbstractMod
 Real</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(Float64)</code><code class="nohighlight hljs ansi" style="display:block;">AbstractFloat</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; AbstractFloat &lt;: Real</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>The leaf nodes of the type tree are called <strong>concrete types</strong>. They are the types that can be instantiated in memory. Among the concrete types, there are <strong>primitive types</strong> and <strong>composite types</strong>. Primitive types are built into the language, such as <code>Int64</code>, <code>Float64</code>, <code>Bool</code>, and <code>Char</code>, while composite types are built on top of primitive types, such as <code>Dict</code>, <code>Complex</code> and the user-defined types.</p><p><strong>The list of primitive types</strong></p><pre><code class="language-bash hljs">primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end

primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end

primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end</code></pre><h3 id="Extending-the-number-system-a-comparison-with-object-oriented-programming"><a class="docs-heading-anchor" href="#Extending-the-number-system-a-comparison-with-object-oriented-programming">Extending the number system - a comparison with object-oriented programming</a><a id="Extending-the-number-system-a-comparison-with-object-oriented-programming-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-the-number-system-a-comparison-with-object-oriented-programming" title="Permalink"></a></h3><p>Extending the number system in Julia is much easier than in object-oriented languages like Python. In the following example, we show how to implement addition operation of a user defined class in Python (feel free to skip if you do not know Python).</p><pre><code class="language-python hljs">class X:
  def __init__(self, num):
    self.num = num

  def __add__(self, other_obj):
    return X(self.num+other_obj.num)

  def __radd__(self, other_obj):
    return X(other_obj.num + self.num)

  def __str__(self):
    return &quot;X = &quot; + str(self.num)

class Y:
  def __init__(self, num):
    self.num = num

  def __radd__(self, other_obj):
    return Y(self.num+other_obj.num)

  def __str__(self):
    return &quot;Y = &quot; + str(self.num)

print(X(3) + Y(5))

print(Y(3) + X(5))</code></pre><p>Here, we implemented the addition operation of two classes <code>X</code> and <code>Y</code>. The <code>__add__</code> method is called when the <code>+</code> operator is used with the object on the left-hand side, while the <code>__radd__</code> method is called when the object is on the right-hand side. The output is as follows:</p><pre><code class="nohighlight hljs">X = 8
X = 8</code></pre><p>It turns out the <code>__radd__</code> method of <code>Y</code> is not called at all. This is because the <code>__radd__</code> method is only called when the object on the left-hand side does not have the <code>__add__</code> method by some artifical rules.</p><p>Implement addition in Julian style is much easier. We can define the addition operation of two types <code>X</code> and <code>Y</code> as follows.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct X{T} &lt;: Number
       	num::T
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Y{T} &lt;: Number
       	num::T
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::X, b::Y) = X(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::Y, b::X) = X(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::X, b::X) = X(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::Y, b::Y) = Y(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Multiple dispatch seems to be more expressive than object-oriented programming.</p><p>Now, supposed you want to extend this method to a new type <code>Z</code>. In python, he needs to define a new class <code>Z</code> as follows.</p><pre><code class="language-python hljs">class Z:
  def __init__(self, num):
    self.num = num

  def __add__(self, other_obj):
    return Z(self.num+other_obj.num)

  def __radd__(self, other_obj):
    return Z(other_obj.num + self.num)

  def __str__(self):
    return &quot;Z = &quot; + str(self.num)

print(X(3) + Z(5))

print(Z(3) + X(5))</code></pre><p>The output is as follows:</p><pre><code class="nohighlight hljs">X = 8
Z = 8</code></pre><p>No matter how hard you try, you can not make the <code>__add__</code> method of <code>Z</code> to be called when the object is on the left-hand side. In Julia, this is not a problem at all. We can define the addition operation of <code>Z</code> as follows.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct Z{T} &lt;: Number
           num::T
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::X, b::Z) = Z(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::Z, b::X) = Z(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::Y, b::Z) = Z(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::Z, b::Y) = Z(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.:(+)(a::Z, b::Z) = Z(a.num + b.num);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X(3) + Y(5)</code><code class="nohighlight hljs ansi" style="display:block;">Main.X{Int64}(8)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Y(3) + X(5)</code><code class="nohighlight hljs ansi" style="display:block;">Main.X{Int64}(8)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X(3) + Z(5)</code><code class="nohighlight hljs ansi" style="display:block;">Main.Z{Int64}(8)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Z(3) + Y(5)</code><code class="nohighlight hljs ansi" style="display:block;">Main.Z{Int64}(8)</code></pre><p>There is a deeper reason why multiple dispatch is more expressive than object-oriented programming. <em>The Julia function space is exponentially large</em>! If a function <span>$f$</span> has <span>$k$</span> parameters, and the module has <span>$t$</span> types, there can be <span>$t^k$</span> methods for the function <span>$f$</span>:</p><pre><code class="language-jula hljs">f(x::T1, y::T2, z::T3...)</code></pre><p>Exponential function space allows us to specify the behavior of a function in a very fine-grained way. However, in an object-oriented language like Python, the function space is only linear to the number of classes.</p><pre><code class="language-python hljs">class T1:
    def f(self, y, z, ...):
        self.num = num
</code></pre><p>The behavior of method <code>f</code> is completely determined by the first argument <code>self</code>, which means <em>object-oriented programming is equivalent to single dispatch</em>.</p><h2 id="Example:-Computing-Fibonacci-number-at-compile-time"><a class="docs-heading-anchor" href="#Example:-Computing-Fibonacci-number-at-compile-time">Example: Computing Fibonacci number at compile time</a><a id="Example:-Computing-Fibonacci-number-at-compile-time-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Computing-Fibonacci-number-at-compile-time" title="Permalink"></a></h2><p>The Fibonacci number has a recursive definition:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fib(x::Int) = x &lt;= 2 ? 1 : fib(x-1) + fib(x-2)</code><code class="nohighlight hljs ansi" style="display:block;">fib (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; addup(x::Int, y::Int) = x + y</code><code class="nohighlight hljs ansi" style="display:block;">addup (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @btime fib(40)
  278.066 ms (0 allocations: 0 bytes)
102334155</code></pre><p>Oops, it is really slow. There is definitely a better way to calculate the Fibonacci number, but let us stick to this recursive implementation for now.</p><p>If you know the Julia type system, you can implement the Fibonacci number in a zero cost way. The trick is to use the type system to calculate the Fibonacci number at compile time. There is a type <code>Val</code> defined in the <code>Base</code> module, which is just a type with a type parameter. The type parameter can be a number:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Val(3.0)</code><code class="nohighlight hljs ansi" style="display:block;">Val{3.0}()</code></pre><p>We can define the addition operation of <code>Val</code> as the addition of the type parameters.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; addup(::Val{x}, ::Val{y}) where {x, y} = Val(x + y)</code><code class="nohighlight hljs ansi" style="display:block;">addup (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; addup(Val(5), Val(7))</code><code class="nohighlight hljs ansi" style="display:block;">Val{12}()</code></pre><p>Finally, we can define the Fibonacci number in a zero cost way.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fib(::Val{x}) where x = x &lt;= 2 ? Val(1) : addup(fib(Val(x-1)), fib(Val(x-2)))</code><code class="nohighlight hljs ansi" style="display:block;">fib (generic function with 2 methods)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @btime fib(Val(40))
  0.792 ns (0 allocations: 0 bytes)
Val{102334155}()</code></pre><p>Wow, it computes in no time! However, this trick is not recommended in the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">Julia performance tips</a>. This implementation simply transfers the run-time computation to the compile time. On the other hand, we find the compiling time of the function <code>fib</code> is much shorter than the run-time. The recursive form turns out to be optimized away by the Julia compiler. But still, it is not recommended to abuse the type system.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><ul><li><em>Multiple dispatch</em> is a feature of some programming languages in which a function or method can be dynamically dispatched based on the <strong>run-time</strong> type.</li><li>Julia&#39;s multiple dispatch provides exponential large function space, which allows extending the number system easily.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../julia-why/">« Why Julia?</a><a class="docs-footer-nextpage" href="../julia-array/">Array and Broadcasting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 16 April 2024 03:09">Tuesday 16 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
