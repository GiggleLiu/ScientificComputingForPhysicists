<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fast Fourier transform · Scientific Computing For Physicists</title><meta name="title" content="Fast Fourier transform · Scientific Computing For Physicists"/><meta property="og:title" content="Fast Fourier transform · Scientific Computing For Physicists"/><meta property="twitter:title" content="Fast Fourier transform · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap3/fft/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap3/fft/"/><link rel="canonical" href="https://book.jinguo-group.science/chap3/fft/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../../chap2/julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../../chap2/julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../../chap2/julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../../chap2/julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../../chap2/julia-release/">My First Package</a></li><li><a class="tocitem" href="../../chap2/julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../qr/">QR Factorization: Bottom-up</a></li><li class="is-active"><a class="tocitem" href>Fast Fourier transform</a><ul class="internal"><li><a class="tocitem" href="#Definition"><span>Definition</span></a></li><li><a class="tocitem" href="#Discrete-Fourier-Transformation-(DFT)"><span>Discrete Fourier Transformation (DFT)</span></a></li><li><a class="tocitem" href="#The-Cooley–Tukey&#39;s-Fast-Fourier-transformation-(FFT)"><span>The Cooley–Tukey&#39;s Fast Fourier transformation (FFT)</span></a></li><li><a class="tocitem" href="#Application-1:-Fast-polynomial-multiplication"><span>Application 1: Fast polynomial multiplication</span></a></li><li><a class="tocitem" href="#Application-2:-Image-compression"><span>Application 2: Image compression</span></a></li></ul></li><li><a class="tocitem" href="../sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../tensors/">Tensor Operations</a></li><li><a class="tocitem" href="../cuda/">Arrays on GPU</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Linear Algebra</a></li><li class="is-active"><a href>Fast Fourier transform</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fast Fourier transform</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap3/fft.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fast-Fourier-transform"><a class="docs-heading-anchor" href="#Fast-Fourier-transform">Fast Fourier transform</a><a id="Fast-Fourier-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Fourier-transform" title="Permalink"></a></h1><h2 id="Definition"><a class="docs-heading-anchor" href="#Definition">Definition</a><a id="Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Definition" title="Permalink"></a></h2><p>Given a function <span>$f(x)$</span> defined on <span>$x \in \mathbb{C}$</span>, the Fourier transformation is defined as</p><p class="math-container">\[g(u) = \int_{-\infty}^{\infty} e^{-2\pi iux} f(x) dx.\]</p><p>The space of <span>$u$</span> is called the momentum space, and the space of <span>$x$</span> is called the position space. Its inverse process, or the inverse Fourier transformation is defined as</p><p class="math-container">\[f(x) = \int_{-\infty}^{\infty} e^{2\pi iux} g(u) dk\]</p><p>The two-dimensional Fourier transformation and its inverse transformation are defined as</p><p class="math-container">\[\begin{align*}
&amp;g(u, v) = \int_{-\infty}^{\infty}dy\int_{-\infty}^\infty e^{-2\pi i(ux+vy)} f(x, y) dx,\\
&amp;f(x, y) = \int_{-\infty}^{\infty}du\int_{-\infty}^\infty e^{2\pi i(ux+vy)} g(u, v) dv.
\end{align*}\]</p><p>Fourier transformation is widely used in many fields, including</p><ul><li>Image and audio processing: <a href="https://www.youtube.com/watch?v=gGEBUdM0PVc">YouTube: Image Compression and the FFT, Steve Brunton</a></li><li>Solid state physics: Kittel, Charles, and Paul McEuen. Introduction to solid state physics. John Wiley &amp; Sons, 2018.</li><li>Quantum computing: Nielsen, Michael A., and Isaac L. Chuang. Quantum computation and quantum information. Cambridge university press, 2010.</li><li>Fourier optics: Goodman, Joseph W. Introduction to Fourier optics. Roberts and Company publishers, 2005.</li></ul><h2 id="Discrete-Fourier-Transformation-(DFT)"><a class="docs-heading-anchor" href="#Discrete-Fourier-Transformation-(DFT)">Discrete Fourier Transformation (DFT)</a><a id="Discrete-Fourier-Transformation-(DFT)-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-Fourier-Transformation-(DFT)" title="Permalink"></a></h2><p>Let <span>$x$</span> be a vector of length <span>$n$</span>, the DFT of <span>$x$</span> is defined as</p><p class="math-container">\[y_{i}=\sum_{n=0}^{n-1}x_{j}\cdot e^{-{\frac {i2\pi }{n}}ij}\]</p><p>Since this transformation is linear, we can represent it as a matrix multiplication. Let <span>$F_n$</span> be the matrix of size <span>$n \times n$</span> defined as</p><p class="math-container">\[F_n = \left(
\begin{matrix}
1 &amp; 1 &amp; 1 &amp; \ldots &amp; 1\\
1 &amp; \omega &amp; \omega^2 &amp; \ldots &amp; \omega^{n-1}\\
1 &amp; \omega^2 &amp; \omega^4 &amp; \ldots &amp; \omega^{2n-2}\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
1 &amp; \omega^{n-1} &amp; \omega^{2n-2} &amp; \ldots &amp; \omega^{(n-1)^2}\\
\end{matrix}
\right)\]</p><p>where <span>$\omega = e^{-2\pi i/n}$</span>.  This matrix is called the DFT matrix, and the DFT of <span>$x$</span> is represented as <span>$F_n x$</span>. The inverse transformation is defined as <span>$F_n^\dagger x/n$</span>, i.e. <span>$F_n F_n^\dagger = I$</span>.</p><pre><code class="language-julia hljs">using Test, LinearAlgebra

function dft_matrix(n::Int)
    ω = exp(-2π*im/n)
    return [ω^((i-1)*(j-1)) for i=1:n, j=1:n]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">dft_matrix (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = 3</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fn = dft_matrix(n)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{ComplexF64}:
 1.0+0.0im   1.0+0.0im        1.0+0.0im
 1.0+0.0im  -0.5-0.866025im  -0.5+0.866025im
 1.0+0.0im  -0.5+0.866025im  -0.5-0.866025im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dft_matrix(n) * dft_matrix(n)&#39; ./ n</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{ComplexF64}:
          1.0+0.0im          …  1.4803e-16+1.85037e-16im
 -3.70074e-17-1.11022e-16im            0.0+1.11022e-16im
   1.4803e-16-1.85037e-16im            1.0+0.0im</code></pre><h2 id="The-Cooley–Tukey&#39;s-Fast-Fourier-transformation-(FFT)"><a class="docs-heading-anchor" href="#The-Cooley–Tukey&#39;s-Fast-Fourier-transformation-(FFT)">The Cooley–Tukey&#39;s Fast Fourier transformation (FFT)</a><a id="The-Cooley–Tukey&#39;s-Fast-Fourier-transformation-(FFT)-1"></a><a class="docs-heading-anchor-permalink" href="#The-Cooley–Tukey&#39;s-Fast-Fourier-transformation-(FFT)" title="Permalink"></a></h2><p>We have a recursive algorithm to compute the DFT.</p><p class="math-container">\[F_n x = \left(\begin{matrix}I_{n/2} &amp; D_{n/2}\\I_{n/2} &amp; -D_{n/2} \end{matrix}\right)\left(\begin{matrix} F_{n/2} &amp; 0 \\ 0 &amp; F_{n/2}\end{matrix}\right)\left(\begin{matrix}x_{\rm odd}\\x_{\rm even}\end{matrix}\right)\]</p><p>where <span>$D_n = {\rm diag}(1, \omega, \omega^2, \ldots, \omega^{n-1})$</span>.</p><div class="admonition is-info"><header class="admonition-header">Quiz</header><div class="admonition-body"><p>What is the computational complexity of evaluating <span>$F_n x$</span>? Hint: <span>$T(n) = 2 T(n/2) + O(n)$</span>.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SparseArrays</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;fft decomposition&quot; begin
           n = 4
           Fn = dft_matrix(n)
           F2n = dft_matrix(2n)
       
           # the permutation matrix to permute elements at 1:2:n (odd) to 1:n÷2 (top half)
           pm = sparse([iseven(j) ? (j÷2+n) : (j+1)÷2 for j=1:2n], 1:2n, ones(2n), 2n, 2n)
       
           # construct the D matrix
           ω = exp(-π*im/n)
           d1 = Diagonal([ω^(i-1) for i=1:n])
       
           # construct F_{2n} from F_n
           F2n_ = [Fn d1 * Fn; Fn -d1 * Fn]
           @test F2n * pm&#39; ≈ F2n_
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Test Summary:     | <span class="sgr32">Pass  </span><span class="sgr36">Total  </span>Time</span>
fft decomposition | <span class="sgr32">   1  </span><span class="sgr36">    1  </span>1.4s
Test.DefaultTestSet(&quot;fft decomposition&quot;, Any[], 1, false, false, true, 1.711531518509412e9, 1.711531519890098e9, false, &quot;REPL[2]&quot;)</code></pre><p>We implement the <span>$O(n\log(n))$</span> time Cooley-Tukey FFT algorithm.</p><pre><code class="language-julia hljs">function fft!(x::AbstractVector{T}) where T
    N = length(x)
    @inbounds if N &lt;= 1
        return x
    end

    # divide
    odd  = x[1:2:N]
    even = x[2:2:N]

    # conquer
    fft!(odd)
    fft!(even)

    # combine
    @inbounds for i=1:N÷2
       t = exp(T(-2im*π*(i-1)/N)) * even[i]
       oi = odd[i]
       x[i]     = oi + t
       x[i+N÷2] = oi - t
    end
    return x
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">fft! (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;fft&quot; begin
           x = randn(ComplexF64, 8)
           @test fft!(copy(x)) ≈ dft_matrix(8) * x
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Test Summary: | <span class="sgr32">Pass  </span><span class="sgr36">Total  </span>Time</span>
fft           | <span class="sgr32">   1  </span><span class="sgr36">    1  </span>0.3s
Test.DefaultTestSet(&quot;fft&quot;, Any[], 1, false, false, true, 1.711531520025373e9, 1.711531520325337e9, false, &quot;REPL[1]&quot;)</code></pre><p>The Julia package <code>FFTW.jl</code> contains a superfast FFT implementation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FFTW</code><code class="nohighlight hljs ansi" style="display:block;">WARNING: using FFTW.fft! in module Main conflicts with an existing identifier.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;fft&quot; begin
           x = randn(ComplexF64, 8)
           @test FFTW.fft(copy(x)) ≈ dft_matrix(8) * x
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Test Summary: | <span class="sgr32">Pass  </span><span class="sgr36">Total  </span>Time</span>
fft           | <span class="sgr32">   1  </span><span class="sgr36">    1  </span>0.0s
Test.DefaultTestSet(&quot;fft&quot;, Any[], 1, false, false, true, 1.711531520330231e9, 1.711531520333362e9, false, &quot;REPL[2]&quot;)</code></pre><h2 id="Application-1:-Fast-polynomial-multiplication"><a class="docs-heading-anchor" href="#Application-1:-Fast-polynomial-multiplication">Application 1: Fast polynomial multiplication</a><a id="Application-1:-Fast-polynomial-multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Application-1:-Fast-polynomial-multiplication" title="Permalink"></a></h2><p>Given two polynomials <span>$p(x)$</span> and <span>$q(x)$</span></p><p class="math-container">\[\begin{align*}
&amp;p(x) = \sum_{k=0}^{n-1} a_k x^k\\
&amp;q(x) = \sum_{k=0}^{n-1} b_k x^k
\end{align*}\]</p><p>The multiplication of them is defined as</p><p class="math-container">\[p(x)q(x) = \sum_{k=0}^{2n-2} c_k x^{k}\]</p><p>Fourier transformation can be used to compute the product of two polynomials in <span>$O(n \log n)$</span> time, which is much faster than the naive algorithm that takes <span>$O(n^2)$</span> time.</p><div class="admonition is-info"><header class="admonition-header">Algorithm: Fast polynomial multiplication</header><div class="admonition-body"><ol><li><p>Evaluate <span>$p(x)$</span> and <span>$q(x)$</span> at <span>$2n$</span> points <span>$ω^0, \ldots , ω^{2n−1}$</span> using DFT. This step takes time <span>$O(n \log n)$</span>.</p></li><li><p>Obtain the values of <span>$p(x)q(x)$</span> at these 2n points through pointwise multiplication</p></li></ol><p class="math-container">\[\begin{align*}
(p \circ q)(ω^0) &amp;= p(ω^0) q(ω^0), \\
(p \circ q)(ω^1) &amp;= p(ω^1) q(ω^1),\\
&amp;\vdots\\
(p \circ q)(ω^{2n−1}) &amp;= p(ω^{2n−1}) q(ω^{2n−1}).
\end{align*}\]</p><p>This step takes time <span>$O(n)$</span>.</p><ol><li>Interpolate the polynomial <span>$p \circ q$</span> at the product values using inverse DFT to obtain coefficients <span>$c_0, c_1, \ldots, c_{2n−2}$</span>. This last step requires time <span>$O(n \log n)$</span>.</li></ol><p>We can also use FFT to compute the convolution of two vectors <span>$a = (a_0,\ldots , a_{n−1})$</span> and <span>$b = (b_0, \ldots , b_{n−1})$</span>, which is defined as a vector <span>$c = (c_0, \ldots , c_{n−1})$</span> where</p><p class="math-container">\[c_j = \sum^j_{k=0} a_kb_{j−k}, ~~~~~~ j = 0,\ldots, n − 1.\]</p><p>The running time is again <span>$O(n \log n)$</span>.</p></div></div><p>In the following example, we use the <code>Polynomials</code> package to define the polynomial and use the FFT algorithm to compute the product of two polynomials.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Polynomials</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = Polynomial([1, 3, 2, 5, 6])</code><code class="nohighlight hljs ansi" style="display:block;">Polynomial(1 + 3*x + 2*x^2 + 5*x^3 + 6*x^4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q = Polynomial([3, 1, 6, 2, 2])</code><code class="nohighlight hljs ansi" style="display:block;">Polynomial(3 + x + 6*x^2 + 2*x^3 + 2*x^4)</code></pre><p>Step 1: evaluate <span>$p(x)$</span> at <span>$2n-1$</span> different points.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pvals = fft(vcat(p.coeffs, zeros(4)))</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{ComplexF64}:
               17.0 + 0.0im
 -4.492726040024655 - 10.28022621396024im
 1.7378259501428421 + 4.548389131353467im
                0.5 - 6.06217782649107im
 -1.745099910118187 + 1.8382342885471272im
 -1.745099910118187 - 1.8382342885471272im
                0.5 + 6.06217782649107im
 1.7378259501428421 - 4.548389131353467im
 -4.492726040024655 + 10.28022621396024im</code></pre><p>which is equivalent to computing:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = 5</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ω = exp(-2π*im/(2n-1))</code><code class="nohighlight hljs ansi" style="display:block;">0.766044443118978 - 0.6427876096865393im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; map(k-&gt;p(ω^k), 0:(2n-1))</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{ComplexF64}:
                17.0 + 0.0im
  -4.492726040024651 - 10.28022621396024im
  1.7378259501428397 + 4.5483891313534635im
  0.5000000000000016 - 6.062177826491066im
 -1.7450999101181899 + 1.838234288547124im
 -1.7450999101181837 - 1.8382342885471246im
  0.4999999999999951 + 6.0621778264910615im
   1.737825950142845 - 4.548389131353452im
 -4.4927260400246505 + 10.28022621396022im
  16.999999999999975 + 1.532107773982714e-14im</code></pre><p>The same for <span>$q(x)$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; qvals = fft(vcat(q.coeffs, zeros(4)))</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{ComplexF64}:
                14.0 + 0.0im
  1.9285482675487435 - 8.967725221980002im
 -1.9324186608105642 - 0.01930258602426438im
                 0.5 + 2.598076211353316im
  6.0038703932618205 + 3.752270213249106im
  6.0038703932618205 - 3.752270213249106im
                 0.5 - 2.598076211353316im
 -1.9324186608105642 + 0.01930258602426438im
  1.9285482675487435 + 8.967725221980002im</code></pre><p>Step 2: Compute <span>$p(x) q(x)$</span> at <span>$2n-1$</span> points.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pqvals = pvals .* qvals</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{ComplexF64}:
               238.0 + 0.0im
 -100.85468292765191 + 20.463620169633234im
  -3.270411622817098 - 8.822936568953224im
                16.0 - 1.7320508075688772im
 -17.374905449530996 + 4.488434009006639im
 -17.374905449530996 - 4.488434009006639im
                16.0 + 1.7320508075688772im
  -3.270411622817098 + 8.822936568953224im
 -100.85468292765191 - 20.463620169633234im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ifft(pqvals)</code><code class="nohighlight hljs ansi" style="display:block;">9-element Vector{ComplexF64}:
                3.0 + 0.0im
 10.000000000000002 + 0.0im
 15.000000000000002 - 5.950848353424417e-16im
               37.0 + 0.0im
               43.0 - 6.837200662697115e-16im
               46.0 + 6.837200662697115e-16im
               50.0 + 0.0im
 21.999999999999996 + 7.441926703969614e-16im
 11.999999999999998 + 0.0im</code></pre><p>Summarize:</p><pre><code class="language-julia hljs">function fast_polymul(p::AbstractVector, q::AbstractVector)
    pvals = fft(vcat(p, zeros(length(q)-1)))
    qvals = fft(vcat(q, zeros(length(p)-1)))
    pqvals = pvals .* qvals
    return real.(ifft(pqvals))
end

function fast_polymul(p::Polynomial, q::Polynomial)
    Polynomial(fast_polymul(p.coeffs, q.coeffs))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">fast_polymul (generic function with 2 methods)</code></pre><p>A similar algorithm has already been implemented in package <code>Polynomials</code>. One can easily verify the correctness.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p * q</code><code class="nohighlight hljs ansi" style="display:block;">Polynomial(3 + 10*x + 15*x^2 + 37*x^3 + 43*x^4 + 46*x^5 + 50*x^6 + 22*x^7 + 12*x^8)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fast_polymul(p, q)</code><code class="nohighlight hljs ansi" style="display:block;">Polynomial(3.0 + 10.000000000000002*x + 15.000000000000002*x^2 + 37.0*x^3 + 43.0*x^4 + 46.0*x^5 + 50.0*x^6 + 21.999999999999996*x^7 + 11.999999999999998*x^8)</code></pre><h2 id="Application-2:-Image-compression"><a class="docs-heading-anchor" href="#Application-2:-Image-compression">Application 2: Image compression</a><a id="Application-2:-Image-compression-1"></a><a class="docs-heading-anchor-permalink" href="#Application-2:-Image-compression" title="Permalink"></a></h2><p>If you google the logo of the Hong Kong University of Science and Technology, you will probably find the following png of size <span>$2000 \times 3000$</span>.</p><pre><code class="language-julia hljs">using Images
img = Images.load(&quot;../assets/images/hkust-gz.png&quot;)</code></pre><img src="adf8f0bf.png" alt="Example block output"/><p>It is too large! We can compress it with the Fourier transformation algorithm. To simplify the discussion, let us using the gray scale image.</p><pre><code class="language-julia hljs">gray_image = Gray.(img)</code></pre><img src="305cce7b.png" alt="Example block output"/><p>The gray scale image uses 8-bit fixed point numbers as the pixel storage type.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(gray_image)</code><code class="nohighlight hljs ansi" style="display:block;">Matrix{Gray{N0f8}}<span class="sgr90"> (alias for Array{ColorTypes.Gray{FixedPointNumbers.Normed{UInt8, 8}}, 2})</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; img_data = Float32.(gray_image)</code><code class="nohighlight hljs ansi" style="display:block;">2000×3000 Matrix{Float32}:
 0.376471  0.376471  0.376471  0.376471  …  0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471  …  0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 ⋮                                       ⋱
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471  …  0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471
 0.376471  0.376471  0.376471  0.376471     0.376471  0.376471  0.376471</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; img_data_k = fftshift(fft(img_data))</code><code class="nohighlight hljs ansi" style="display:block;">2000×3000 Matrix{ComplexF32}:
  14.1177-9.69074f-7im  -16.5889+1.66456im  …  -16.5889-1.66456im
 -12.1824-10.0836im      19.6015+5.63716im      10.0119+14.3428im
  7.55086+13.5317im     -17.3148-3.91325im     -2.42017-22.694im
 -3.00379-9.20718im       11.248-1.95294im     -4.79038+19.1743im
  1.09106+1.94913im     -5.93928+3.75958im      11.0074-5.10588im
 -2.26381+2.12877im      5.33122+2.14914im  …  -14.9784-10.0922im
  4.27849-0.864077im    -8.88375-11.6353im       14.901+16.4903im
 -3.59109-2.92389im      11.5189+16.8775im     -10.5282-11.4876im
 -1.89706+4.89608im     -8.13688-13.6709im      4.82196+1.34339im
  10.6636-3.25829im     -1.22232+4.9903im      -2.45761+4.52942im
         ⋮                                  ⋱
  10.6636+3.25828im     -2.45761-4.52942im     -1.22232-4.9903im
 -1.89706-4.89609im      4.82196-1.34339im     -8.13687+13.6709im
  -3.5911+2.9239im      -10.5282+11.4876im      11.5189-16.8775im
  4.27848+0.864073im      14.901-16.4903im     -8.88375+11.6353im
 -2.26382-2.12877im     -14.9784+10.0922im  …   5.33123-2.14914im
  1.09106-1.94913im      11.0074+5.10589im     -5.93928-3.75958im
  -3.0038+9.20717im     -4.79038-19.1743im       11.248+1.95294im
  7.55085-13.5317im     -2.42017+22.694im      -17.3148+3.91326im
 -12.1824+10.0836im      10.0119-14.3429im      19.6015-5.63716im</code></pre><p>it is sparse!</p><pre><code class="language-julia hljs">Gray.(abs2.(img_data_k) ./ length(img_data_k))</code></pre><img src="718c39ec.png" alt="Example block output"/><p>We can store it in the sparse matrix format.</p><pre><code class="language-julia hljs"># let us discard all variables smaller than 1e-5
img_data_k[abs.(img_data_k) .&lt; 1e-5] .= 0
sparse_img = sparse(img_data_k)
compression_ratio = nnz(sparse_img) / (2000 * 3000)
recovered_img = ifft(fftshift(Matrix(sparse_img)))
Gray.(abs.(recovered_img))</code></pre><img src="0f32e8f1.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../qr/">« QR Factorization: Bottom-up</a><a class="docs-footer-nextpage" href="../sensitivity/">Sensitivity Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 27 March 2024 09:27">Wednesday 27 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
