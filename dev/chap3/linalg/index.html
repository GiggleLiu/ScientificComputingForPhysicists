<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Linear Algebra · Scientific Computing For Physicists</title><meta name="title" content="Basic Linear Algebra · Scientific Computing For Physicists"/><meta property="og:title" content="Basic Linear Algebra · Scientific Computing For Physicists"/><meta property="twitter:title" content="Basic Linear Algebra · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap3/linalg/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap3/linalg/"/><link rel="canonical" href="https://book.jinguo-group.science/chap3/linalg/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../../chap2/julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../../chap2/julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../../chap2/julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../../chap2/julia-release/">My First Package</a></li><li><a class="tocitem" href="../../chap2/julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Tensors (×)</span><ul><li><a class="tocitem" href="../array/">Array and Broadcasting</a></li><li class="is-active"><a class="tocitem" href>Basic Linear Algebra</a><ul class="internal"><li><a class="tocitem" href="#Matrix-multiplication"><span>Matrix multiplication</span></a></li><li><a class="tocitem" href="#System-of-Linear-Equations"><span>System of Linear Equations</span></a></li></ul></li><li><a class="tocitem" href="../lu/">LU Decomposition</a></li><li><a class="tocitem" href="../sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../factorization/">Matrix factorization</a></li><li><a class="tocitem" href="../fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../tensors/">Tensor Operations</a></li><li><a class="tocitem" href="../cuda/">Arrays on GPU</a></li></ul></li><li><span class="tocitem">Optimization (×)</span><ul><li><a class="tocitem" href="../../chap4/combinatorial/">Combinatorial Optimization</a></li><li><a class="tocitem" href="../../chap4/optimization/">Optimization</a></li><li><a class="tocitem" href="../../chap4/ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Randomness (×)</span><ul><li><a class="tocitem" href="../../chap5/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Sparsity (×)</span><ul><li><a class="tocitem" href="../../chap6/sparse/">Sparse Matrices</a></li><li><a class="tocitem" href="../../chap6/compressedsensing/">Compressed sensing</a></li></ul></li><li><span class="tocitem">High Performance Computing (×)</span><ul><li><a class="tocitem" href="../../chap7/hpc/">MPI and OpenMP</a></li><li><a class="tocitem" href="../../chap7/cuda/">CUDA programming</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tensors (×)</a></li><li class="is-active"><a href>Basic Linear Algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic Linear Algebra</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap3/linalg.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Linear-Algebra"><a class="docs-heading-anchor" href="#Basic-Linear-Algebra">Basic Linear Algebra</a><a id="Basic-Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Linear-Algebra" title="Permalink"></a></h1><h2 id="Matrix-multiplication"><a class="docs-heading-anchor" href="#Matrix-multiplication">Matrix multiplication</a><a id="Matrix-multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-multiplication" title="Permalink"></a></h2><p>Matrix multiplication is a fundamental operation in linear algebra. Given two matrices <span>$A\in \mathbb{R}^{m\times n}$</span> and <span>$B\in \mathbb{R}^{n\times p}$</span>, the product <span>$C = AB$</span> is defined as</p><p class="math-container">\[C_{ij} = \sum_{k=1}^n A_{ik}B_{kj}.\]</p><p>The time complexity of matrix multiplication is <span>$O(mnp)$</span>.</p><p>In Julia, we can implement the matrix multiplication as follows.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function mymatmul_rowmajor(A::AbstractMatrix, B::AbstractMatrix)
           m, n = size(A)
           n, p = size(B)
           @assert size(A, 2) == size(B, 1) &quot;size mismatch&quot;
           C = zeros(promote_type(eltype(A), eltype(B)), m, p)
           @inbounds for i = 1:m
               for k = 1:n
                   for j = 1:p
                       C[i, j] += A[i, k] * B[k, j]
                   end
               end
           end
           return C
       end</code><code class="nohighlight hljs ansi" style="display:block;">mymatmul_rowmajor (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A, B = randn(1000, 1000), randn(1000, 1000);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: Package BenchmarkTools not found in current path.
- Run `import Pkg; Pkg.add(&quot;BenchmarkTools&quot;)` to install the BenchmarkTools package.</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @benchmark mymatmul_rowmajor($A, $B)
BenchmarkTools.Trial: 9 samples with 1 evaluation.
 Range (min … max):  616.256 ms … 621.271 ms  ┊ GC (min … max): 0.00% … 0.19%
 Time  (median):     618.576 ms               ┊ GC (median):    0.00%
 Time  (mean ± σ):   618.502 ms ±   1.597 ms  ┊ GC (mean ± σ):  0.02% ± 0.06%

  ▁        ▁    █             ▁       ▁    █                  ▁  
  █▁▁▁▁▁▁▁▁█▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁█▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁
  616 ms           Histogram: frequency by time          621 ms &lt;

 Memory estimate: 7.63 MiB, allocs estimate: 2.</code></pre><p>Alternatively, we can iterate over the columns of the matrices first.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function mymatmul_colmajor(A::AbstractMatrix, B::AbstractMatrix)
           m, n = size(A)
           n, p = size(B)
           @assert size(A, 2) == size(B, 1) &quot;size mismatch&quot;
           C = zeros(promote_type(eltype(A), eltype(B)), m, p)
           @inbounds for j = 1:p
               for k = 1:n
                   for i = 1:m
                       C[i, j] += A[i, k] * B[k, j]
                   end
               end
           end
           return C
       end</code><code class="nohighlight hljs ansi" style="display:block;">mymatmul_colmajor (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @benchmark mymatmul_colmajor($A, $B)
BenchmarkTools.Trial: 34 samples with 1 evaluation.
 Range (min … max):  146.371 ms … 149.116 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     146.895 ms               ┊ GC (median):    0.00%
 Time  (mean ± σ):   147.138 ms ± 680.122 μs  ┊ GC (mean ± σ):  0.08% ± 0.27%

        ▁█▄ ▄█▄▁ ▁                                               
  ▆▁▁▁▁▁███▆████▆█▆▆▁▁▁▁▁▁▁▁▁▁▁▆▁▁▁▁▁▆▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆▆▆▁▁▁▁▁▁▁▆ ▁
  146 ms           Histogram: frequency by time          149 ms &lt;

 Memory estimate: 7.63 MiB, allocs estimate: 2.</code></pre><pre><code class="language-julia-repl hljs">julia&gt; @benchmark $A * $B
BenchmarkTools.Trial: 383 samples with 1 evaluation.
 Range (min … max):  12.089 ms … 38.311 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     12.873 ms              ┊ GC (median):    0.00%
 Time  (mean ± σ):   13.052 ms ±  1.418 ms  ┊ GC (mean ± σ):  1.20% ± 3.41%

       ▄▆▅ ▂▄▇█▇▅▅▄                                            
  ▆▁▁▁▁████████████▆▆▁▄▁▁▄▁▄▁▆▆▇▄▇▄▇█▇▇▁▁▇▁▆▁▆▄▁▄▁▁▁▁▁▁▁▁▁▁▁▄ ▇
  12.1 ms      Histogram: log(frequency) by time      15.8 ms &lt;

 Memory estimate: 7.63 MiB, allocs estimate: 2.</code></pre><p>The performance of a CPU is measured by the number of <strong>floating point operations per second</strong> (FLOPS) it can perform. The floating point operations include addition, subtraction, multiplication and division. The FLOPS can be related to multiple factors, such as the clock frequency, the number of cores, the number of instructions per cycle, and the number of floating point units. A simple way to measure the FLOPS is to benchmarking the speed of matrix multiplication. The number of FLOPS in a <span>$n\times n\times n$</span> matrix multiplication is <span>$2n^3$</span>. The FLOPS can be calculated as: <span>$2 \times 1000^3 / (12.089 \times 10^{-3}) \approx 165~{\rm GFLOPS}$</span>.</p><h2 id="System-of-Linear-Equations"><a class="docs-heading-anchor" href="#System-of-Linear-Equations">System of Linear Equations</a><a id="System-of-Linear-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#System-of-Linear-Equations" title="Permalink"></a></h2><p>Let <span>$A\in \mathbb{R}^{n\times n}$</span> be a invertible square matrix and <span>$b \in \mathbb{R}^n$</span> be a vector. Solving a linear equation means finding a vector <span>$x\in\mathbb{R}^n$</span> such that</p><p class="math-container">\[A x = b\]</p><p>One can solve a linear equation by following these steps:</p><ol><li><p>Decompose the matrix <span>$A \in \mathbb{R}^{n\times n}$</span> into <span>$L \in \mathbb{R}^{n\times n}$</span> and <span>$U \in \mathbb{R}^{n\times n}$</span> matrices using a method such as <a href="../lu/#Gaussian-elimination">Gaussian elimination</a> or Crout&#39;s method.</p></li><li><p>Rewrite the equation <span>$Ax = b$</span> as <span>$LUx = b$</span>.</p></li><li><p>Solve for y in <span>$Ly = b$</span> by <a href="../lu/#Forward-substitution">Forward-substitution</a>. This involves substituting the values of <span>$y$</span> into the equation one at a time, starting with the first row and working downwards.</p></li><li><p>Solve for <span>$x$</span> in <span>$Ux = y$</span> by <a href="../lu/#Back-substitution">Back-substitution</a> (link TBA). This involves substituting the values of <span>$x$</span> into the equation one at a time, starting with the last row and working upwards.</p></li></ol><p>In Julia, we can solve a linear equation using the backslash operator <code>\</code> or the <code>lu</code> function.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = [1 2; 3 4]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Int64}:
 1  2
 3  4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = [2, 3.0]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 2.0
 3.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../array/">« Array and Broadcasting</a><a class="docs-footer-nextpage" href="../lu/">LU Decomposition »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 1 March 2024 06:34">Friday 1 March 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
