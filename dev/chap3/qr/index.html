<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QR Factorization: Bottom-up · Scientific Computing For Physicists</title><meta name="title" content="QR Factorization: Bottom-up · Scientific Computing For Physicists"/><meta property="og:title" content="QR Factorization: Bottom-up · Scientific Computing For Physicists"/><meta property="twitter:title" content="QR Factorization: Bottom-up · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap3/qr/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap3/qr/"/><link rel="canonical" href="https://book.jinguo-group.science/chap3/qr/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../../chap2/julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../../chap2/julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../../chap2/julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../../chap2/julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../../chap2/julia-release/">My First Package</a></li><li><a class="tocitem" href="../../chap2/julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li class="is-active"><a class="tocitem" href>QR Factorization: Bottom-up</a><ul class="internal"><li><a class="tocitem" href="#Householder-Reflection"><span>Householder Reflection</span></a></li><li><a class="tocitem" href="#QR-factoriaztion-by-Householder-reflection."><span>QR factoriaztion by Householder reflection.</span></a></li><li><a class="tocitem" href="#Givens-Rotations"><span>Givens Rotations</span></a></li><li><a class="tocitem" href="#QR-Factorization-by-Givens-Rotations"><span>QR Factorization by Givens Rotations</span></a></li><li><a class="tocitem" href="#Gram-Schmidt-Orthogonalization"><span>Gram-Schmidt Orthogonalization</span></a></li><li><a class="tocitem" href="#Modified-Gram-Schmidt-Orthogonalization"><span>Modified Gram-Schmidt Orthogonalization</span></a></li></ul></li><li><a class="tocitem" href="../fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../tensors/">Tensor Operations</a></li><li><a class="tocitem" href="../cuda/">Arrays on GPU</a></li><li><a class="tocitem" href="../sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Linear Algebra</a></li><li class="is-active"><a href>QR Factorization: Bottom-up</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QR Factorization: Bottom-up</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap3/qr.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="QR-Factorization:-Bottom-up"><a class="docs-heading-anchor" href="#QR-Factorization:-Bottom-up">QR Factorization: Bottom-up</a><a id="QR-Factorization:-Bottom-up-1"></a><a class="docs-heading-anchor-permalink" href="#QR-Factorization:-Bottom-up" title="Permalink"></a></h1><p>The QR factorization of a matrix <span>$A \in \mathbb{R}^{m\times n}$</span> is a factorization of the form</p><p class="math-container">\[A = QR\]</p><p>where <span>$Q \in \mathbb{R}^{m\times m}$</span> is an orthogonal matrix and <span>$R \in \mathbb{R}^{m\times n}$</span> is an upper triangular matrix.</p><h2 id="Householder-Reflection"><a class="docs-heading-anchor" href="#Householder-Reflection">Householder Reflection</a><a id="Householder-Reflection-1"></a><a class="docs-heading-anchor-permalink" href="#Householder-Reflection" title="Permalink"></a></h2><p>Let <span>$v \in \mathbb{R}^m$</span> be nonzero, An <span>$m$</span>-by-<span>$m$</span> matrix <span>$P$</span> of the form</p><p class="math-container">\[P = 1-\beta vv^T, ~~~\beta = \frac{2}{v^Tv}\]</p><p>is a Householder reflection, which is both symmetric and orthogonal. Suppose we want to project a vector <span>$x$</span> to <span>$e_1$</span>, i.e. <span>$Px = \beta e_1$</span>. Then we can choose</p><p class="math-container">\[\begin{align*}
&amp;v = x \pm \|x\|_2 e_1\\
&amp;H = I - \beta vv^T
\end{align*}\]</p><p>Let us define a Householder matrix in Julia.</p><pre><code class="language-julia hljs">struct HouseholderMatrix{T} &lt;: AbstractArray{T, 2}
    v::Vector{T}
    β::T
end
function HouseholderMatrix(v::Vector{T}) where T
    HouseholderMatrix(v, 2/norm(v, 2)^2)
end

# array interfaces
Base.size(A::HouseholderMatrix) = (length(A.v), length(A.v))
Base.size(A::HouseholderMatrix, i::Int) = i == 1 || i == 2 ? length(A.v) : 1
function Base.getindex(A::HouseholderMatrix, i::Int, j::Int)
    (i == j ? 1 : 0) - A.β * A.v[i] * conj(A.v[j])
end

# Householder matrix is unitary
Base.inv(A::HouseholderMatrix) = A
# Householder matrix is Hermitian
Base.adjoint(A::HouseholderMatrix) = A

# Left and right multiplication
function left_mul!(B, A::HouseholderMatrix)
    B .-= (A.β .* A.v) * (A.v&#39; * B)
    return B
end
function right_mul!(A, B::HouseholderMatrix)
    A .= A .- (A * (B.β .* B.v)) * B.v&#39;
    return A
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">right_mul! (generic function with 1 method)</code></pre><p>In this example, we define a <code>HouseholderMatrix</code> type, which is a subtype of <code>AbstractArray</code>. The <code>v</code> field is the vector <span>$v$</span> and the <code>β</code> field is the scalar <span>$\beta$</span>. To define the array interfaces, we need to define the <code>size</code> and <code>getindex</code> functions. Please check the <a href="https://docs.julialang.org/en/v1/manual/interfaces/">Julia manual</a> for more details.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LinearAlgebra, Test</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;householder property&quot; begin
           v = randn(3)
           H = HouseholderMatrix(v)
           # symmetric
           @test H&#39; ≈ H
           # reflexive
           @test H^2 ≈ I
           # orthogonal
           @test H&#39; * H ≈ I
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Test Summary:        | <span class="sgr32">Pass  </span><span class="sgr36">Total  </span>Time</span>
householder property | <span class="sgr32">   3  </span><span class="sgr36">    3  </span>0.7s
Test.DefaultTestSet(&quot;householder property&quot;, Any[], 3, false, false, true, 1.711597953113055e9, 1.71159795378653e9, false, &quot;REPL[2]&quot;)</code></pre><p>Let us define a function to compute the Householder matrix that projects a vector to <span>$e_1$</span>.</p><pre><code class="language-julia hljs">function householder_e1(v::AbstractVector{T}) where T
    v = copy(v)
    v[1] -= norm(v, 2)
    return HouseholderMatrix(v, 2/norm(v, 2)^2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">householder_e1 (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = Float64[1 2 2; 4 4 2; 4 6 4]</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 1.0  2.0  2.0
 4.0  4.0  2.0
 4.0  6.0  4.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hm = householder_e1(view(A,:,1))</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Main.HouseholderMatrix{Float64}:
 0.174078   0.696311   0.696311
 0.696311   0.412961  -0.587039
 0.696311  -0.587039   0.412961</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hm * A</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 5.74456       7.31126    4.52602
 8.88178e-16  -0.477767  -0.129612
 8.88178e-16   1.52223    1.87039</code></pre><h2 id="QR-factoriaztion-by-Householder-reflection."><a class="docs-heading-anchor" href="#QR-factoriaztion-by-Householder-reflection.">QR factoriaztion by Householder reflection.</a><a id="QR-factoriaztion-by-Householder-reflection.-1"></a><a class="docs-heading-anchor-permalink" href="#QR-factoriaztion-by-Householder-reflection." title="Permalink"></a></h2><p>Let <span>$H_k$</span> be a Householder reflection that zeros out the <span>$k$</span>-th column below the diagonal. Then we have</p><p class="math-container">\[H_n \ldots H_2H_1 A = R\]</p><p>where <span>$R$</span> is an upper triangular matrix. Then we can define the <span>$Q$</span> matrix as</p><p class="math-container">\[Q = H_1^{T} H_2 ^{T}\ldots H_n^{T},\]</p><p>which is a unitary matrix.</p><pre><code class="language-julia hljs">function householder_qr!(Q::AbstractMatrix{T}, a::AbstractMatrix{T}) where T
    m, n = size(a)
    @assert size(Q, 2) == m
    if m == 1
        return Q, a
    else
        # apply householder matrix
        H = householder_e1(view(a, :, 1))
        left_mul!(a, H)
        # update Q matrix
        right_mul!(Q, H&#39;)
        # recurse
        householder_qr!(view(Q, 1:m, 2:m), view(a, 2:m, 2:n))
    end
    return Q, a
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">householder_qr! (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;householder QR&quot; begin
           A = randn(3, 3)
           Q = Matrix{Float64}(I, 3, 3)
           R = copy(A)
           householder_qr!(Q, R)
           @info R
           @test Q * R ≈ A
           @test Q&#39; * Q ≈ I
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">[ Info: </span></span>[0.6077902360644047 -0.49690241650269273 0.3144061972738786; -1.1102230246251565e-16 1.417881173790984 0.3524623610342723; -2.7755575615628914e-17 0.0 -0.44524485192407753]
<span class="sgr1">Test Summary:  | <span class="sgr32">Pass  </span><span class="sgr36">Total  </span>Time</span>
householder QR | <span class="sgr32">   2  </span><span class="sgr36">    2  </span>2.6s
Test.DefaultTestSet(&quot;householder QR&quot;, Any[], 2, false, false, true, 1.711597954075326e9, 1.711597956660718e9, false, &quot;REPL[1]&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = randn(3, 3)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 -0.397361  -1.1059     0.841569
  2.53651   -0.955003   2.42292
 -2.37955   -0.472337  -1.1527</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = givens_matrix(A, 2, 3)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `givens_matrix` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; left_mul!(copy(A), g)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `g` not defined</code></pre><h2 id="Givens-Rotations"><a class="docs-heading-anchor" href="#Givens-Rotations">Givens Rotations</a><a id="Givens-Rotations-1"></a><a class="docs-heading-anchor-permalink" href="#Givens-Rotations" title="Permalink"></a></h2><p class="math-container">\[G = \left(\begin{matrix}
\cos\theta &amp; -\sin\theta\\
\sin\theta &amp; \cos\theta
\end{matrix}\right)\]</p><pre><code class="language-julia hljs">rotation_matrix(angle) = [cos(angle) -sin(angle); sin(angle) cos(angle)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">rotation_matrix (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle = π/4</code><code class="nohighlight hljs ansi" style="display:block;">0.7853981633974483</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; initial_vector = [1.0, 0.0]</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 1.0
 0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; final_vector = rotation_matrix(angle) * initial_vector
       # eliminating the y element</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
 0.7071067811865476
 0.7071067811865475</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; atan(0.1, 0.5)</code><code class="nohighlight hljs ansi" style="display:block;">0.19739555984988078</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; initial_vector = randn(2)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
  0.18365800797954732
 -0.4335752156449619</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; angle = atan(initial_vector[2], initial_vector[1])</code><code class="nohighlight hljs ansi" style="display:block;">-1.1701207979654704</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; final_vector = rotation_matrix(-angle) * initial_vector</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Float64}:
  0.4708691235540834
 -2.7755575615628914e-17</code></pre><p class="math-container">\[\left(
\begin{matrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; c &amp; 0 &amp; s &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\
0 &amp; -s &amp; 0 &amp; c &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right)
\left(
\begin{matrix}
a_1\\a_2\\a_3\\a_4\\a_5
\end{matrix}
\right)=
\left(
\begin{matrix}
a_1\\\alpha\\a_3\\0\\a_5
\end{matrix}
\right)\]</p><p>where <span>$s = \sin(\theta)$</span> and <span>$c = \cos(\theta)$</span>.</p><h2 id="QR-Factorization-by-Givens-Rotations"><a class="docs-heading-anchor" href="#QR-Factorization-by-Givens-Rotations">QR Factorization by Givens Rotations</a><a id="QR-Factorization-by-Givens-Rotations-1"></a><a class="docs-heading-anchor-permalink" href="#QR-Factorization-by-Givens-Rotations" title="Permalink"></a></h2><pre><code class="language-julia hljs">struct GivensMatrix{T} &lt;: AbstractArray{T, 2}
    c::T
    s::T
    i::Int
    j::Int
    n::Int
end

Base.size(g::GivensMatrix) = (g.n, g.n)
Base.size(g::GivensMatrix, i::Int) = i == 1 || i == 2 ? g.n : 1
function Base.getindex(g::GivensMatrix{T}, i::Int, j::Int) where T
    @boundscheck i &lt;= g.n &amp;&amp; j &lt;= g.n
    if i == j
        return i == g.i || i == g.j ? g.c : one(T)
    elseif i == g.i &amp;&amp; j == g.j
        return g.s
    elseif i == g.j &amp;&amp; j == g.i
        return -g.s
    else
        return i == j ? one(T) : zero(T)
    end
end

function left_mul!(A::AbstractMatrix, givens::GivensMatrix)
    for col in 1:size(A, 2)
        vi, vj = A[givens.i, col], A[givens.j, col]
        A[givens.i, col] = vi * givens.c + vj * givens.s
        A[givens.j, col] = -vi * givens.s + vj * givens.c
    end
    return A
end
function right_mul!(A::AbstractMatrix, givens::GivensMatrix)
    for row in 1:size(A, 1)
        vi, vj = A[row, givens.i], A[row, givens.j]
        A[row, givens.i] = vi * givens.c + vj * givens.s
        A[row, givens.j] = -vi * givens.s + vj * givens.c
    end
    return A
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">right_mul! (generic function with 2 methods)</code></pre><pre><code class="language-julia hljs">function givens_matrix(A, i, j)
    x, y = A[i, 1], A[j, 1]
    norm = sqrt(x^2 + y^2)
    c = x/norm
    s = y/norm
    return GivensMatrix(c, s, i, j, size(A, 1))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">givens_matrix (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">function givens_qr!(Q::AbstractMatrix, A::AbstractMatrix)
    m, n = size(A)
    if m == 1
        return Q, A
    else
        for k = m:-1:2
            g = givens_matrix(A, k-1, k)
            left_mul!(A, g)
            right_mul!(Q, g)
        end
        givens_qr!(view(Q, :, 2:m), view(A, 2:m, 2:n))
        return Q, A
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">givens_qr! (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;givens QR&quot; begin
           n = 3
           A = randn(n, n)
           R = copy(A)
           Q, R = givens_qr!(Matrix{Float64}(I, n, n), R)
           @test Q * R ≈ A
           @test Q * Q&#39; ≈ I
           @info R
       end</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr36"><span class="sgr1">[ Info: </span></span>[0.6077902360644049 -0.49690241650269273 0.31440619727387853; -2.7755575615628914e-17 1.4178811737909842 0.3524623610342723; 1.3877787807814457e-17 0.0 -0.44524485192407737]
<span class="sgr1">Test Summary: | <span class="sgr32">Pass  </span><span class="sgr36">Total  </span>Time</span>
givens QR     | <span class="sgr32">   2  </span><span class="sgr36">    2  </span>0.2s
Test.DefaultTestSet(&quot;givens QR&quot;, Any[], 2, false, false, true, 1.711597956705859e9, 1.711597956862897e9, false, &quot;REPL[1]&quot;)</code></pre><h2 id="Gram-Schmidt-Orthogonalization"><a class="docs-heading-anchor" href="#Gram-Schmidt-Orthogonalization">Gram-Schmidt Orthogonalization</a><a id="Gram-Schmidt-Orthogonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Gram-Schmidt-Orthogonalization" title="Permalink"></a></h2><p>The Gram-Schmidt orthogonalization is a method to compute the QR factorization of a matrix <span>$A$</span> by constructing an orthogonal matrix <span>$Q$</span> and an upper triangular matrix <span>$R$</span>.</p><p class="math-container">\[q_k = \left(a_k - \sum_{i=1}^{k-1} r_{ik}q_i\right)/r_{kk}\]</p><pre><code class="language-julia hljs">function classical_gram_schmidt(A::AbstractMatrix{T}) where T
    m, n = size(A)
    Q = zeros(T, m, n)
    R = zeros(T, n, n)
    R[1, 1] = norm(view(A, :, 1))
    Q[:, 1] .= view(A, :, 1) ./ R[1, 1]
    for k = 2:n
        Q[:, k] .= view(A, :, k)
        # project z to span(A[:, 1:k-1])⊥
        for j = 1:k-1
            R[j, k] = view(Q, :, j)&#39; * view(A, :, k)
            Q[:, k] .-= view(Q, :, j) .* R[j, k]
        end
        # normalize the k-th column
        R[k, k] = norm(view(Q, :, k))
        Q[:, k] ./= R[k, k]
    end
    return Q, R
end

@testset &quot;classical GS&quot; begin
    n = 10
    A = randn(n, n)
    Q, R = classical_gram_schmidt(A)
    @test Q * R ≈ A
    @test Q * Q&#39; ≈ I
    @info R
end</code></pre><h2 id="Modified-Gram-Schmidt-Orthogonalization"><a class="docs-heading-anchor" href="#Modified-Gram-Schmidt-Orthogonalization">Modified Gram-Schmidt Orthogonalization</a><a id="Modified-Gram-Schmidt-Orthogonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Modified-Gram-Schmidt-Orthogonalization" title="Permalink"></a></h2><pre><code class="language-julia hljs">function modified_gram_schmidt!(A::AbstractMatrix{T}) where T
    m, n = size(A)
    Q = zeros(T, m, n)
    R = zeros(T, n, n)
    for k = 1:n
        R[k, k] = norm(view(A, :, k))
        Q[:, k] .= view(A, :, k) ./ R[k, k]
        for j = k+1:n
            R[k, j] = view(Q, :, k)&#39; * view(A, :, j)
            A[:, j] .-= view(Q, :, k) .* R[k, j]
        end
    end
    return Q, R
end

@testset &quot;modified GS&quot; begin
    n = 10
    A = randn(n, n)
    Q, R = modified_gram_schmidt!(copy(A))
    @test Q * R ≈ A
    @test Q * Q&#39; ≈ I
    @info R
end

let
    n = 100
    A = randn(n, n)
    Q1, R1 = classical_gram_schmidt(A)
    Q2, R2 = modified_gram_schmidt!(copy(A))
    @info norm(Q1&#39; * Q1 - I)
    @info norm(Q2&#39; * Q2 - I)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lu/">« Solving linear equations by LU factorization: Bottom-up</a><a class="docs-footer-nextpage" href="../fft/">Fast Fourier transform »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 28 March 2024 03:55">Thursday 28 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
