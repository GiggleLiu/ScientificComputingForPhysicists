<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse Matrices and Graphs · Scientific Computing For Physicists</title><meta name="title" content="Sparse Matrices and Graphs · Scientific Computing For Physicists"/><meta property="og:title" content="Sparse Matrices and Graphs · Scientific Computing For Physicists"/><meta property="twitter:title" content="Sparse Matrices and Graphs · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap3/sparse/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap3/sparse/"/><link rel="canonical" href="https://book.jinguo-group.science/chap3/sparse/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../../chap2/julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../../chap2/julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../../chap2/julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../../chap2/julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../../chap2/julia-release/">My First Package</a></li><li><a class="tocitem" href="../../chap2/julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../qr/">QR Factorization: Bottom-up</a></li><li><a class="tocitem" href="../fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../sensitivity/">Sensitivity Analysis</a></li><li class="is-active"><a class="tocitem" href>Sparse Matrices and Graphs</a><ul class="internal"><li><a class="tocitem" href="#Sparse-Matrices"><span>Sparse Matrices</span></a></li><li><a class="tocitem" href="#COOrdinate-(COO)-format"><span>COOrdinate (COO) format</span></a></li><li><a class="tocitem" href="#Compressed-Sparse-Column-(CSC)-format"><span>Compressed Sparse Column (CSC) format</span></a></li><li><a class="tocitem" href="#Dominant-eigenvalue-problem"><span>Dominant eigenvalue problem</span></a></li><li><a class="tocitem" href="#The-Krylov-subspace-method"><span>The Krylov subspace method</span></a></li><li><a class="tocitem" href="#The-Lanczos-algorithm"><span>The Lanczos algorithm</span></a></li><li><a class="tocitem" href="#The-Arnoldi-algorithm"><span>The Arnoldi algorithm</span></a></li><li><a class="tocitem" href="#Graphs"><span>Graphs</span></a></li></ul></li></ul></li><li><span class="tocitem">Tensors and Tensor Networks</span><ul><li><a class="tocitem" href="../tensors/">Tensor Operations</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../chap4/optimization/">Optimization</a></li><li><a class="tocitem" href="../../chap4/ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Randomness</span><ul><li><a class="tocitem" href="../../chap5/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Linear Algebra</a></li><li class="is-active"><a href>Sparse Matrices and Graphs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparse Matrices and Graphs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap3/sparse.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-Matrices-and-Graphs"><a class="docs-heading-anchor" href="#Sparse-Matrices-and-Graphs">Sparse Matrices and Graphs</a><a id="Sparse-Matrices-and-Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Matrices-and-Graphs" title="Permalink"></a></h1><h2 id="Sparse-Matrices"><a class="docs-heading-anchor" href="#Sparse-Matrices">Sparse Matrices</a><a id="Sparse-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-Matrices" title="Permalink"></a></h2><p>Matrices are often sparse. Consider the matrix that we used in the <a href="../linalg/#Eigenvalues-and-Eigenvectors">spring chain example</a>, the stiffness matrix is tridiagonal and has only <span>$3n-2$</span> nonzero elements.</p><p class="math-container">\[\begin{align*}
A = \begin{pmatrix}
-C &amp; C &amp; 0 &amp; \ldots &amp; 0\\
C &amp; -2C &amp; C &amp; \ldots &amp; 0\\
0 &amp; C &amp; -2C &amp; \ldots &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
0 &amp; 0 &amp; 0 &amp; C &amp; -C
\end{pmatrix}
\end{align*}\]</p><p>Storing such a matrix in a dense format requires <span>$n^2$</span> elements, which is very memory inefficient since it has only <span>$3n-2$</span> nonzero elements.</p><h2 id="COOrdinate-(COO)-format"><a class="docs-heading-anchor" href="#COOrdinate-(COO)-format">COOrdinate (COO) format</a><a id="COOrdinate-(COO)-format-1"></a><a class="docs-heading-anchor-permalink" href="#COOrdinate-(COO)-format" title="Permalink"></a></h2><p>The coordinate format means storing nonzero matrix elements into triples</p><p class="math-container">\[\begin{align*}
&amp;(i_1, j_1, v_1)\\
&amp;(i_2, j_2, v_2)\\
&amp;\vdots\\
&amp;(i_k, j_k, v_k)
\end{align*}\]</p><p>To store the stiffness matrix in COO format, we only need to store <span>$3n-2$</span> triples.</p><p>To implement a COO matrix in Julia, we need to define a new data type and implement the <a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-array"><code>AbstractArray</code></a> interface.</p><ul><li><code>size</code>: return the size of the matrix</li><li><code>getindex</code>: return the element at the given index</li></ul><p>Let the number of nonzero elements in a COO matrix <span>$A$</span> be <span>${\rm nnz}(A)$</span>. The indexing operation requires enumerating over all <span>${\rm nnz}(A)$</span> elements.</p><pre><code class="language-julia hljs">using LinearAlgebra

struct COOMatrix{Tv, Ti} &lt;: AbstractArray{Tv, 2}   # Julia does not have a COO data type
    m::Ti                   # number of rows
    n::Ti                 # number of columns
    colval::Vector{Ti}   # column indices
    rowval::Vector{Ti}   # row indices
    nzval::Vector{Tv}        # values
    function COOMatrix(m::Ti, n::Ti, colval::Vector{Ti}, rowval::Vector{Ti}, nzval::Vector{Tv}) where {Tv, Ti}
        @assert length(colval) == length(rowval) == length(nzval)
        new{Tv, Ti}(m, n, colval, rowval, nzval)
    end
end

Base.size(coo::COOMatrix) = (coo.m, coo.n)
Base.size(coo::COOMatrix, i::Int) = getindex((coo.m, coo.n), i)
# the number of non-zero elements
nnz(coo::COOMatrix) = length(coo.nzval)

# implement get index for CSC matrix, call with A[i, j]
function Base.getindex(coo::COOMatrix{Tv}, i::Integer, j::Integer) where Tv
    @boundscheck checkbounds(coo, i, j)
    v = zero(Tv)
    for (i2, j2, v2) in zip(coo.rowval, coo.colval, coo.nzval)
        if i == i2 &amp;&amp; j == j2
            v += v2  # accumulate the value, since repeated indices are allowed.
        end
    end
    return v
end

function Base.:(*)(A::COOMatrix{T1}, B::COOMatrix{T2}) where {T1, T2}
    @assert size(A, 2) == size(B, 1)
    rowval = Int[]
    colval = Int[]
    nzval = promote_type(T1, T2)[]
    for (i, j, v) in zip(A.rowval, A.colval, A.nzval)
        for (i2, j2, v2) in zip(B.rowval, B.colval, B.nzval)
            if j == i2
                push!(rowval, i)
                push!(colval, j2)
                push!(nzval, v * v2)
            end
        end
    end
    return COOMatrix(size(A, 1), size(B, 2), colval, rowval, nzval)
end</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Test</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; stiffmatrix = COOMatrix(3, 3, [1, 1, 2, 2, 2, 3, 3], [1, 2, 1, 2, 3, 2, 3], [-1.0, 1, 1, -2, 1, 1, -1])</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Main.COOMatrix{Float64, Int64}:
 -1.0   1.0   0.0
  1.0  -2.0   1.0
  0.0   1.0  -1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; size(stiffmatrix)</code><code class="nohighlight hljs ansi" style="display:block;">(3, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nnz(stiffmatrix)</code><code class="nohighlight hljs ansi" style="display:block;">7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dense_matrix = Matrix(stiffmatrix)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 -1.0   1.0   0.0
  1.0  -2.0   1.0
  0.0   1.0  -1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test stiffmatrix * stiffmatrix ≈ dense_matrix ^ 2</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>Most operations on COO matrices are computational expensive. For example, multiplying two COO matrices requires <span>$O({\rm nnz}(A)^2)$</span> computing time.</p><h2 id="Compressed-Sparse-Column-(CSC)-format"><a class="docs-heading-anchor" href="#Compressed-Sparse-Column-(CSC)-format">Compressed Sparse Column (CSC) format</a><a id="Compressed-Sparse-Column-(CSC)-format-1"></a><a class="docs-heading-anchor-permalink" href="#Compressed-Sparse-Column-(CSC)-format" title="Permalink"></a></h2><p>A CSC format sparse matrix can be constructed with the <code>SparseArrays.sparse</code> function. However, here we will implement a simple CSC matrix from scratch.</p><pre><code class="language-julia hljs">struct CSCMatrix{Tv,Ti} &lt;: AbstractMatrix{Tv}
    m::Int
    n::Int
    colptr::Vector{Ti}
    rowval::Vector{Ti}
    nzval::Vector{Tv}
    function CSCMatrix(m::Int, n::Int, colptr::Vector{Ti}, rowval::Vector{Ti}, nzval::Vector{Tv}) where {Tv, Ti}
        @assert length(colptr) == n + 1
        @assert length(rowval) == length(nzval) == colptr[end] - 1
        new{Tv, Ti}(m, n, colptr, rowval, nzval)
    end
end
Base.size(A::CSCMatrix) = (A.m, A.n)
Base.size(A::CSCMatrix, i::Int) = getindex((A.m, A.n), i)
# the number of non-zero elements
nnz(csc::CSCMatrix) = length(csc.nzval)

# convert a COO matrix to a CSC matrix
function CSCMatrix(coo::COOMatrix{Tv, Ti}) where {Tv, Ti}
    m, n = size(coo)
    # sort the COO matrix by column
    order = sortperm(1:nnz(coo); by=i-&gt;coo.rowval[i] + m * (coo.colval[i]-1))
    colptr, rowval, nzval = similar(coo.rowval, n+1), similar(coo.rowval), similar(coo.nzval)
    k = 0
    ipre, jpre = 0, 0
    colptr[1] = 1
    for idx in order
        i, j, v = coo.rowval[idx], coo.colval[idx], coo.nzval[idx]
        # values with the same indices are accumulated
        if i == ipre &amp;&amp; j == jpre
            nzval[k] += v
        else
            k += 1
            if j != jpre
                # a new column starts
                colptr[jpre+1:j+1] .= k
            end
            rowval[k] = i
            nzval[k] = v
            ipre, jpre = i, j
        end
    end
    colptr[jpre+1:end] .= k + 1
    resize!(rowval, k)
    resize!(nzval, k)
    return CSCMatrix(m, n, colptr, rowval, nzval)
end

# implement get index for CSC matrix, call with A[i, j]
function Base.getindex(A::CSCMatrix{T}, i::Int, j::Int) where T
    @boundscheck checkbounds(A, i, j)
    for k in nzrange(A, j)
        if A.rowval[k] == i
            return A.nzval[k]
        end
    end
    return zero(T)
end

function Base.:*(A::CSCMatrix{T1}, B::CSCMatrix{T2}) where {T1, T2}
    T = promote_type(T1, T2)
    @assert size(A, 2) == size(B, 1)
    rowval, colval, nzval = Int[], Int[], T[]
    for j2 in 1:size(B, 2)  # enumerate the columns of B
        for k2 in nzrange(B, j2)  # enumerate the rows of B
            v2 = B.nzval[k2]
            for k1 in nzrange(A, B.rowval[k2])  # enumerate the rows of A
                push!(rowval, A.rowval[k1])
                push!(colval, j2)
                push!(nzval, A.nzval[k1] * v2)
            end
        end
    end
    return CSCMatrix(COOMatrix(size(A, 1), size(B, 2), colval, rowval, nzval))
end

# return the range of non-zero elements in the j-th column
nzrange(A::CSCMatrix, j::Int) = A.colptr[j]:A.colptr[j+1]-1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">nzrange (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; coo_matrix = COOMatrix(5, 4, [1, 1, 2, 2, 4, 4], [2, 3, 1, 4, 3, 4], [1, 2, 3, 4, 5, 6])</code><code class="nohighlight hljs ansi" style="display:block;">5×4 Main.COOMatrix{Int64, Int64}:
 0  3  0  0
 1  0  0  0
 2  0  0  5
 0  4  0  6
 0  0  0  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; csc_matrix = CSCMatrix(coo_matrix)</code><code class="nohighlight hljs ansi" style="display:block;">5×4 Main.CSCMatrix{Int64, Int64}:
 0  3  0  0
 1  0  0  0
 2  0  0  5
 0  4  0  6
 0  0  0  0</code></pre><p>The <code>csc_matrix</code> has type <code>CSCMatrix</code>, which contains 5 fields</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; fieldnames(csc_matrix |&gt; typeof)</code><code class="nohighlight hljs ansi" style="display:block;">(:m, :n, :colptr, :rowval, :nzval)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; csc_matrix.m, csc_matrix.n</code><code class="nohighlight hljs ansi" style="display:block;">(5, 4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; csc_matrix.colptr</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Int64}:
 1
 3
 5
 5
 7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; csc_matrix.rowval</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Int64}:
 2
 3
 1
 4
 3
 4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; csc_matrix.nzval</code><code class="nohighlight hljs ansi" style="display:block;">6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre><p><img src="../../assets/images/csc.png" alt/></p><p>The <code>m</code>, <code>n</code>, <code>rowval</code> and <code>nzval</code> have the same meaning as those in the COO format. <code>colptr</code> is an integer vector of size <span>$n+1$</span>, where <code>colptr[j]</code> is the index in <code>rowval</code> and <code>nzval</code> of the first nonzero element in the <span>$j$</span>-th column, and <code>colptr[j+1]</code> is the index of the first nonzero element in the <span>$(j+1)$</span>-th column. Hence the <span>$j$</span>-th column of the matrix is stored in <code>rowval[colptr[j]:colptr[j+1]-1]</code> and <code>nzval[colptr[j]:colptr[j+1]-1]</code>.</p><p>The number of operations required to index an element in the <span>$j$</span>-th column of a CSC matrix is linear to the nonzero elements in the <span>$j$</span>-th column. To get an element from the 2nd row and 3rd column of a CSC matrix, we can use the following code</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; csc_matrix[2, 3]</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>The row indices and values of nonzero elements in the 3rd column can be obtained by</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; rows3 = csc_matrix.rowval[csc_matrix.colptr[3]:csc_matrix.colptr[4]-1]</code><code class="nohighlight hljs ansi" style="display:block;">Int64[]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; val3 = csc_matrix.nzval[csc_matrix.colptr[3]:csc_matrix.colptr[4]-1]</code><code class="nohighlight hljs ansi" style="display:block;">Int64[]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; csc_matrix.rowval[nzrange(csc_matrix, 3)] # or equivalently, we can use `nzrange`</code><code class="nohighlight hljs ansi" style="display:block;">Int64[]</code></pre><p>Multiplying two CSC matrices is much faster than multiplying two COO matrices. The time complexity of multiplying two CSC matrices <span>$A$</span> and <span>$B$</span> is <span>$O({\rm nnz}(A){\rm nnz}(B)/n)$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; csc_matrix2 = CSCMatrix(COOMatrix(coo_matrix.n, coo_matrix.m, coo_matrix.rowval, coo_matrix.colval, coo_matrix.nzval))  # transpose</code><code class="nohighlight hljs ansi" style="display:block;">4×5 Main.CSCMatrix{Int64, Int64}:
 0  1  2  0  0
 3  0  0  4  0
 0  0  0  0  0
 0  0  5  6  0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test Matrix(csc_matrix) * Matrix(csc_matrix2) ≈ csc_matrix * csc_matrix2</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><h2 id="Dominant-eigenvalue-problem"><a class="docs-heading-anchor" href="#Dominant-eigenvalue-problem">Dominant eigenvalue problem</a><a id="Dominant-eigenvalue-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Dominant-eigenvalue-problem" title="Permalink"></a></h2><p>Given a matrix <span>$A \in \mathbb{R}^{n \times n}$</span>, the dominant eigenvalue problem is to find the largest eigenvalue <span>$\lambda_1$</span> and its corresponding eigenvector <span>$x_1$</span> such that</p><p class="math-container">\[A x_1 = \lambda_1 x_1.\]</p><p>The power method is a simple iterative algorithm to solve the dominant eigenvalue problem. The algorithm starts with a random vector <span>$v_0$</span> and repeatedly multiplies it with the matrix <span>$A$</span>.</p><p class="math-container">\[v_k = A^k v_0\]</p><p>By representing the initial vector <span>$v_0$</span> as a linear combination of eigenvectors of <span>$A$</span>, i.e. <span>$v_0 = \sum_{i=1}^n c_i x_i$</span>, we have</p><p class="math-container">\[v_k = \sum_{i=1}^n \lambda_i^k c_i x_i\]</p><p>where <span>$\lambda_1 &gt; \lambda_2 \geq \ldots \geq \lambda_n$</span> are the eigenvalues of <span>$A$</span> and <span>$x_i$</span> are the corresponding eigenvectors. The power method converges to the eigenvector corresponding to the largest eigenvalue as <span>$k \rightarrow \infty$</span>. The rate of convergence is dedicated by <span>$|\lambda_2/\lambda_1|^k$</span>. The Julia code for the power method is as follows.</p><pre><code class="language-julia hljs">function power_method(A::AbstractMatrix{T}, n::Int) where T
    n = size(A, 2)
    x = normalize!(randn(n))
    for i=1:n
        x = A * x
        normalize!(x)
    end
    return x&#39; * A * x&#39;, x
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">power_method (generic function with 1 method)</code></pre><p>By inverting the sign, <span>$A\rightarrow -A$</span>, we can use the same method to obtain the smallest eigenvalue.</p><h2 id="The-Krylov-subspace-method"><a class="docs-heading-anchor" href="#The-Krylov-subspace-method">The Krylov subspace method</a><a id="The-Krylov-subspace-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Krylov-subspace-method" title="Permalink"></a></h2><p>Let <span>$A \in \mathbb{C}^{n \times n}$</span> be a large sparse matrix, the Arnoldi and Lanczos algorithms can be used to obtain its largest/smallest eigenvalue, with much faster convergence speed comparing with the power method.</p><p>The key idea of these algorithms is to generate an orthogonal matrix <span>$Q \in \mathbb{C}^{n\times k}$</span>, <span>$Q^\dagger Q = I$</span>, such that</p><p class="math-container">\[Q^\dagger A Q = B.\]</p><p>We have the following property</p><p class="math-container">\[\lambda_1(B) \leq \lambda_1(A),\]</p><p>where <span>$\lambda_1(A)$</span> is the largest eigenvalue of <span>$A$</span>. By chooing <span>$Q$</span> carefully, such that <span>${\rm span}(Q)$</span> contains the dominant eigenvectors of <span>$A$</span>, then <span>$\lambda_1(B) = \lambda_1(A)$</span>. When the equality holds, we have</p><p class="math-container">\[By_1 = \lambda_1(B)y_1\]</p><p>where <span>$y_i$</span> is the <span>$i$</span>-th eigenvector of <span>$B$</span>. By multiplying <span>$y^\dagger$</span> on the left, we have</p><p class="math-container">\[y_1^\dagger Q^\dagger A Q y_1 = \lambda_1(B)\]</p><p>Hence, the eigenvectors of <span>$B$</span> are related to the eigenvectors of <span>$A$</span> by the orthogonal matrix <span>$Q$</span>.</p><p>Inspired by the power method, we can define the <span>$Q$</span> as the <em>Krylov subspace</em> that generated from a random initial vector <span>$q_1$</span>.</p><p class="math-container">\[\mathcal{K}(A, q_1, k) = {\rm span}\{q_1, Aq_1, A^2q_1, \ldots, A^{k-1}q_1\}\]</p><p>The Arnoldi and Lanczos algorithm are two special cases of the Krylov subspace method. The Arnoldi algorithm is used to solve the eigenvalue problem, while the Lanczos algorithm is used to solve the symmetric eigenvalue problem.</p><h3 id="KrylovKit.jl"><a class="docs-heading-anchor" href="#KrylovKit.jl">KrylovKit.jl</a><a id="KrylovKit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#KrylovKit.jl" title="Permalink"></a></h3><p>The Julia package <a href="https://github.com/Jutho/KrylovKit.jl"><code>KrylovKit.jl</code></a> contains many Krylov space based algorithms. <code>KrylovKit.jl</code> accepts general functions or callable objects as linear maps, and general Julia objects with vector like behavior (as defined in the docs) as vectors. The high level interface of KrylovKit is provided by the following functions:</p><ul><li><code>linsolve</code>: solve linear systems</li><li><code>eigsolve</code>: find a few eigenvalues and corresponding eigenvectors</li><li><code>geneigsolve</code>: find a few generalized eigenvalues and corresponding vectors</li><li><code>svdsolve</code>: find a few singular values and corresponding left and right singular vectors</li><li><code>exponentiate</code>: apply the exponential of a linear map to a vector</li><li><code>expintegrator</code>: <a href="https://en.wikipedia.org/wiki/Exponential_integrator">exponential integrator</a>   for a linear non-homogeneous ODE, computes a linear combination of the <code>ϕⱼ</code> functions which generalize <code>ϕ₀(z) = exp(z)</code>.</li></ul><h2 id="The-Lanczos-algorithm"><a class="docs-heading-anchor" href="#The-Lanczos-algorithm">The Lanczos algorithm</a><a id="The-Lanczos-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Lanczos-algorithm" title="Permalink"></a></h2><p>The Lanczos algorithm is used to solve the symmetric eigenvalue problem. Given a symmetric matrix <span>$A \in \mathbb{R}^{n \times n}$</span>, the Lanczos algorithm generates an orthogonal matrix <span>$Q \in \mathbb{R}^{n \times k}$</span>, such that</p><p class="math-container">\[Q^T A Q = T\]</p><p>where <span>$T$</span> is a tridiagonal matrix</p><p class="math-container">\[T = \left(\begin{matrix}
\alpha_1 &amp; \beta_1 &amp; 0 &amp; \ldots &amp; 0\\
\beta_1 &amp; \alpha_2 &amp; \beta_2 &amp; \ldots &amp; 0\\
0 &amp; \beta_2 &amp; \alpha_3 &amp; \ldots &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
0 &amp; 0 &amp; 0 &amp; \beta_{k-1} &amp; \alpha_k
\end{matrix}\right),\]</p><p>Let <span>$Q = [q_1 | q_2 | \ldots | q_n],$</span> and <span>${\rm span}(\{q_1, q_2, \ldots, q_k\}) = \mathcal{K}(A, q_1, k)$</span>. We have <span>$Aq_k = \beta_{k-1}q_{k-1} + \alpha_k q_k + \beta_k q_{k+1}$</span>, or equivalently in the recursive style</p><p class="math-container">\[q_{k+1} = (Aq_k - \beta_{k-1}q_{k-1} - \alpha_k q_k)/\beta_k.\]</p><p>By multiplying <span>$q_k^T$</span> on the left, we have</p><p class="math-container">\[\alpha_k  = q_k^T A q_k.\]</p><p>Since <span>$q_{k+1}$</span> is normalized, we have</p><p class="math-container">\[\beta_k = \|Aq_k - \beta_{k-1}q_{k-1} - \alpha_k q_k\|_2\]</p><p>If at any moment, <span>$\beta_k = 0$</span>, the interation stops due to convergence of a subspace. We have the following reducible form</p><p class="math-container">\[T(\beta_2 = 0) = \left(\begin{array}{cc|ccc}
\alpha_1 &amp; \beta_1 &amp; 0 &amp; \ldots &amp; 0\\
\beta_1 &amp; \alpha_2 &amp; 0 &amp; \ldots &amp; 0\\
\hline
0 &amp; 0 &amp; \alpha_3 &amp; \ldots &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
0 &amp; 0 &amp; 0 &amp; \beta_{k-1} &amp; \alpha_k
\end{array}\right),\]</p><h3 id="A-Julia-implementation"><a class="docs-heading-anchor" href="#A-Julia-implementation">A Julia implementation</a><a id="A-Julia-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#A-Julia-implementation" title="Permalink"></a></h3><pre><code class="language-julia hljs">function lanczos(A, q1::AbstractVector{T}; abstol, maxiter) where T
    # normalize the input vector
    q1 = normalize(q1)
    # the first iteration
    q = [q1]
    Aq1 = A * q1
    α = [q1&#39; * Aq1]
    rk = Aq1 .- α[1] .* q1
    β = [norm(rk)]
    for k = 2:min(length(q1), maxiter)
        # the k-th orthonormal vector in Q
        push!(q, rk ./ β[k-1])
        Aqk = A * q[k]
        # compute the diagonal element as αₖ = qₖᵀ A qₖ
        push!(α, q[k]&#39; * Aqk)
        rk = Aqk .- α[k] .* q[k] .- β[k-1] * q[k-1]
        # compute the off-diagonal element as βₖ = |rₖ|
        nrk = norm(rk)
        # break if βₖ is smaller than abstol or the maximum number of iteration is reached
        if abs(nrk) &lt; abstol || k == length(q1)
            break
        end
        push!(β, nrk)
    end
    # returns T and Q
    return SymTridiagonal(α, β), hcat(q...)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">lanczos (generic function with 1 method)</code></pre><h3 id="Reorthogonalization"><a class="docs-heading-anchor" href="#Reorthogonalization">Reorthogonalization</a><a id="Reorthogonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Reorthogonalization" title="Permalink"></a></h3><p>Let <span>$r_0, \ldots, r_{k-1} \in \mathbb{C}_n$</span> be linearly independent vectors and the corresponding Householder matrices <span>$H_0, \ldots, H_{k-1}$</span> such that <span>$(H_0\ldots H_{k- 1})^T [r_0\mid\ldots\mid r_{k-1}]$</span> is an upper triangular matrix. Let <span>$[q_1 \mid \ldots \mid q_k ]$</span> denote the first <span>$k$</span> columns of the Householder product <span>$(H_0 \ldots H_{k-1})$</span>, then <span>$q_1, \ldots, q_k$</span> are orthonormal vectors up to machine precision. The Lanczos algorithm with complete reorthogonalization is as follows:</p><pre><code class="language-julia hljs">function lanczos_reorthogonalize(A, q1::AbstractVector{T}; abstol, maxiter) where T
    n = length(q1)
    # normalize the input vector
    q1 = normalize(q1)
    # the first iteration
    q = [q1]
    Aq1 = A * q1
    α = [q1&#39; * Aq1]
    rk = Aq1 .- α[1] .* q1
    β = [norm(rk)]
    householders = [householder_matrix(q1)]
    for k = 2:min(n, maxiter)
        # reorthogonalize rk: 1. compute the k-th householder matrix
        for j = 1:k-1
            left_mul!(view(rk, j:n), householders[j])
        end
        push!(householders, householder_matrix(view(rk, k:n)))
        # reorthogonalize rk: 2. compute the k-th orthonormal vector in Q
        qk = zeros(T, n); qk[k] = 1  # qₖ = H₁H₂…Hₖeₖ
        for j = k:-1:1
            left_mul!(view(qk, j:n), householders[j])
        end
        push!(q, qk)
        Aqk = A * q[k]
        # compute the diagonal element as αₖ = qₖᵀ A qₖ
        push!(α, q[k]&#39; * Aqk)
        rk = Aqk .- α[k] .* q[k] .- β[k-1] * q[k-1]
        # compute the off-diagonal element as βₖ = |rₖ|
        nrk = norm(rk)
        # break if βₖ is smaller than abstol or the maximum number of iteration is reached
        if abs(nrk) &lt; abstol || k == n
            break
        end
        push!(β, nrk)
    end
    return SymTridiagonal(α, β), hcat(q...)
end
struct HouseholderMatrix{T} &lt;: AbstractArray{T, 2}
    v::Vector{T}
    β::T
end

# the `mul!` interfaces can take two extra factors.
function left_mul!(B, A::HouseholderMatrix)
    B .-= (A.β .* A.v) * (A.v&#39; * B)
    return B
end

function householder_matrix(v::AbstractVector{T}) where T
    v = copy(v)
    v[1] -= norm(v, 2)
    return HouseholderMatrix(v, 2/norm(v, 2)^2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">householder_matrix (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Graphs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = 1000</code><code class="nohighlight hljs ansi" style="display:block;">1000</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; graph = random_regular_graph(n, 3)</code><code class="nohighlight hljs ansi" style="display:block;">{1000, 1500} undirected simple Int64 graph</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = laplacian_matrix(graph)</code><code class="nohighlight hljs ansi" style="display:block;">1000×1000 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4000 stored entries:
⎡⠕⣥⠹⡦⢧⠰⢀⢐⢠⠵⢂⢄⠸⠄⡡⠒⠶⠀⣙⣈⠔⠊⢦⢢⡰⢮⢢⠤⡁⢐⡀⢙⠵⢠⢀⢠⢑⡙⡣⢆⎤
⎢⠳⡦⠑⣤⡤⢽⠀⢈⠬⢒⡓⡐⠆⠔⣓⠃⠋⠊⠔⠨⠠⣤⡁⡲⢕⠈⢨⠯⡓⠅⢍⠬⢁⠿⡖⣐⠡⣞⢉⣁⎥
⎢⢉⡓⣄⣏⢟⢕⠅⢰⠰⢠⡘⢨⢬⣠⡹⢊⠠⣂⠄⠅⠾⡛⠆⢊⡓⠾⡆⡃⢀⢃⠚⢍⢠⠂⢕⠃⠂⢹⠌⠈⎥
⎢⢀⢐⡀⢀⢁⣁⡑⣬⠝⠃⣳⡂⡑⡾⢾⠒⢃⠫⠞⡪⡙⠈⠛⡑⠵⡀⡵⡨⠱⢜⠧⣌⢆⡐⢵⡠⡬⣏⠨⠅⎥
⎢⢄⡖⢢⢃⠐⣂⠷⠁⡟⢍⠭⠰⢡⢆⢀⣈⠔⡙⠀⠊⣢⢛⠄⠇⢣⣗⠆⠀⡚⠤⠴⡝⢕⢩⣀⢕⢩⠀⢘⠂⎥
⎢⠈⢔⢙⠨⡒⣈⠹⠺⢃⡃⠕⢅⢫⡩⣔⡛⢎⠹⡈⠪⠣⠎⢠⡠⠀⡢⢔⣼⡅⠜⢱⠰⡡⠤⡄⡢⢸⠡⢣⣂⎥
⎢⠒⠆⢈⠅⠂⣳⣱⡬⠡⢖⡏⡲⠟⢅⣮⠁⠨⡧⠫⠗⡻⠄⢂⣁⢐⠼⡠⠆⠒⣶⣈⣔⠐⠩⣤⡱⣪⢊⡙⢀⎥
⎢⢡⠊⠽⠘⡳⢊⢺⠓⡀⢰⣴⠹⠎⠛⢑⣴⣤⡘⠑⠪⣂⠀⡠⣀⠣⣮⣋⠐⣏⢀⢤⢀⠮⣌⡆⠑⠃⡐⠅⠍⎥
⎢⠘⠃⡫⠀⠠⢢⡭⡐⣔⠡⣎⡑⠦⡦⣀⠻⡕⢍⡻⢠⠒⡢⡫⠨⡋⢓⠈⠩⢁⡱⢉⠪⠙⣔⣖⣖⢰⣓⠰⠠⎥
⎢⡓⢸⡐⡁⠄⠅⡺⡡⡠⠀⡢⡈⢯⠆⡱⡀⠛⣊⡕⢍⢒⠠⢢⠏⠯⡘⢈⡇⡌⠎⠨⠦⣪⠀⣤⠼⣓⡃⡗⢏⎥
⎢⡰⠁⠀⣦⣾⠣⡓⠈⣬⢚⡩⠆⠛⠎⠈⠘⠸⡠⠘⡐⣕⢝⣔⠠⠗⠒⠀⡪⠜⣍⢍⡞⣉⡦⢀⡀⡮⡨⡜⡈⎥
⎢⠨⣓⢡⡨⡨⢁⢟⠠⠤⠅⠀⡲⠌⢰⠀⢪⡋⡊⡬⠖⠐⡙⠑⣤⠒⠰⢶⡥⡑⠴⢅⠌⢳⢺⠾⡌⠉⡜⢴⡆⎥
⎢⡰⣎⡑⠑⣹⡌⠑⠣⢭⢶⠠⡠⣐⡔⡩⣦⢯⢈⣋⠣⢹⠁⢘⡀⢑⣴⠸⠎⣈⠺⡛⣠⠡⠓⠭⣆⡄⡁⠄⠮⎥
⎢⠈⡖⡦⡖⠬⠩⡑⡫⠈⠁⣐⣵⠠⠎⢋⠘⡆⡀⠦⠴⡠⡠⠜⡷⡲⠆⢛⢔⣩⠠⡧⡁⠦⢈⣘⠚⠎⡀⢃⣒⎥
⎢⢁⢈⠝⠌⠤⢐⣑⢆⠚⡌⣁⠍⢸⣤⠋⢙⢅⡰⡢⠍⡖⢥⢑⡌⣢⡘⠃⡚⡱⣮⠑⡵⡎⡟⠆⣂⡕⡚⠙⠔⎥
⎢⣄⢈⡃⡕⡞⢄⡉⢧⣔⠧⢑⡒⢂⢼⠀⢓⡣⡐⠢⡆⣣⠵⡁⠕⠛⣨⠍⠫⢕⡤⡑⢌⠡⠢⠔⡌⢱⣀⠄⢇⎥
⎢⠑⣃⣥⡔⠠⠒⢈⠱⡕⣑⠁⡎⡔⡀⡊⢧⢓⢤⠊⠚⠣⡼⣹⣒⢥⠂⡈⢃⣮⠭⠡⡂⠕⣥⠇⠈⠶⠵⡘⠀⎥
⎢⠀⣐⢘⢩⠵⠑⠑⡳⢄⢜⠠⡩⢄⡻⢌⠉⢸⢽⣀⡟⠀⠰⡚⠧⠣⢧⣲⠘⠨⢡⡐⠥⡉⠁⡱⢎⢐⠰⡩⢀⎥
⎢⣕⠰⣡⢦⣌⣀⡦⢯⠃⠒⠖⡒⡪⢚⢉⠠⢴⢲⠽⠸⡊⡫⣃⠤⠄⠩⠊⠡⣱⠩⠑⢲⢜⡇⢐⡐⢱⢖⡙⡀⎥
⎣⠩⢎⠇⢰⡂⠁⠆⠆⠲⠐⠩⢲⠓⢈⡅⠅⠐⡂⡽⢍⡒⠩⠰⠷⡠⡅⢩⢰⢓⠄⠤⢅⠒⠈⠃⢊⠓⠨⢻⢖⎦</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q1 = randn(n)</code><code class="nohighlight hljs ansi" style="display:block;">1000-element Vector{Float64}:
 -0.8580629650435357
 -0.4114469432522041
  0.49580307717175276
 -0.19704093942977838
 -0.6703950142000373
 -0.9825214528260293
 -0.6127244021341566
  0.778520157976366
 -0.9696271559988995
 -0.49880086253595846
  ⋮
 -0.2685207133975352
  0.1462900921719605
 -0.5335073175983909
 -0.8317362166274628
  1.0820685999095407
  0.11747273627373073
 -0.9738538264158326
 -0.33935746562709324
  0.6926014889836709</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tr, Q = lanczos_reorthogonalize(A, q1; abstol=1e-5, maxiter=100)</code><code class="nohighlight hljs ansi" style="display:block;">([3.042687721672874 1.7232674727868498 … 0.0 0.0; 1.7232674727868498 2.9876312494508928 … 0.0 0.0; … ; 0.0 0.0 … 3.0184332118380204 1.4237550948440005; 0.0 0.0 … 1.4237550948440005 2.987251351584803], [-0.02728347648609889 0.025956359643438627 … -0.009955489024543521 0.010042551169149434; -0.013082609853612799 2.6814253906575674e-5 … -0.06247485849446367 -0.027736931297129477; … ; -0.01079041027408652 -0.002043588781857663 … -0.004463550473917862 0.07591962631393172; 0.022022365733922925 0.05924879959324121 … 0.04610883891651826 -0.005636613521228911])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eigen(tr)</code><code class="nohighlight hljs ansi" style="display:block;">LinearAlgebra.Eigen{Float64, Float64, Matrix{Float64}, Vector{Float64}}
values:
100-element Vector{Float64}:
 2.6645352591003757e-15
 0.17705161491426047
 0.19157380787188086
 0.19491213249927522
 0.20470330357096156
 0.21807186723591965
 0.23829179100236164
 0.2552956615962403
 0.282186792195942
 0.3029854601582693
 ⋮
 5.712396913855928
 5.731567603355036
 5.756037414511592
 5.769107456290023
 5.782344298777055
 5.79706834260568
 5.806699095327588
 5.815656640275432
 5.829152004537918
vectors:
100×100 Matrix{Float64}:
 -0.0290172    -0.0488648     0.022435    …  -0.0235535    0.0276649
  0.0512342     0.0812576    -0.0371183      -0.0379007    0.0447332
 -0.0720087    -0.100731      0.0455001      -0.0465285    0.0555003
  0.10392       0.12269      -0.0545179      -0.0542903    0.0657862
 -0.148542     -0.144193      0.0627707      -0.0644881    0.0796548
  0.20671       0.162112     -0.0688778   …  -0.0726779    0.0917344
 -0.270985     -0.165679      0.0682272      -0.0765925    0.0992363
  0.344218      0.154764     -0.0609379      -0.0742661    0.099564
 -0.395836     -0.115565      0.041914       -0.072938     0.102139
  0.397135      0.0498683    -0.013026       -0.0725566    0.106811
  ⋮                                       ⋱
  1.225e-13    -0.000422445  -0.0789661       0.00645977   0.000175945
 -8.71692e-14   0.000377991   0.0726449       0.00561715   0.000149643
  6.39152e-14  -0.000339258  -0.066691        0.00453052   0.000118244
 -4.15534e-14   0.000263161   0.0527156       0.00393851   0.000100867
  2.75787e-14  -0.00020711   -0.0422135   …   0.0031472    7.93498e-5
 -1.8362e-14    0.000160817   0.0332671       0.00237873   5.91656e-5
  1.15913e-14  -0.0001152    -0.0241083       0.00177167   4.35786e-5
 -6.85815e-15   7.52267e-5    0.0158797       0.00117888   2.8764e-5
  3.26867e-15  -3.81127e-5   -0.00808706      0.000593423  1.44104e-5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using KrylovKit</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eigsolve(A, q1, 2, :SR)</code><code class="nohighlight hljs ansi" style="display:block;">([2.8122548574259676e-15, 0.17705160529989256], [[0.03162277660168369, 0.03162277660168372, 0.03162277660168398, 0.031622776601683895, 0.03162277660168391, 0.031622776601683625, 0.03162277660168395, 0.0316227766016839, 0.031622776601683805, 0.03162277660168403  …  0.03162277660168402, 0.031622776601683944, 0.0316227766016836, 0.031622776601683854, 0.031622776601683715, 0.0316227766016839, 0.031622776601683965, 0.03162277660168399, 0.03162277660168374, 0.031622776601683875], [0.017249148352066954, -0.01392629616100503, -0.053308692630223246, -0.028813495540349513, -0.028610943740449847, -0.013191055617048414, -0.015466491579867207, -0.039200950833293925, -0.00412464376168556, -0.01460929286476443  …  0.0006267149262774352, -0.03341761653397744, 0.052825915183867166, -0.014774764538232624, 0.033610964487423546, -0.002067674082108428, -0.01676576021696109, -0.08153583026270185, 0.005109595932399323, -0.00599180867162349]], ConvergenceInfo: 2 converged values after 17 iterations and 222 applications of the linear map;
norms of residuals are given by (3.976241756596992e-34, 7.990138128087592e-13).
)</code></pre><h3 id="Notes-on-Lanczos"><a class="docs-heading-anchor" href="#Notes-on-Lanczos">Notes on Lanczos</a><a id="Notes-on-Lanczos-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-on-Lanczos" title="Permalink"></a></h3><p>A sophisticated Lanczos implementation should consider the following aspects:</p><ol><li>In practice, storing all <span>$q$</span> vectors is not necessary.</li><li>Blocking technique can be used to improve the solution, especially when the matrix has degenerate eigenvalues.</li><li>Restarting technique can be used to improve the solution without increasing the memory usage.</li></ol><p>These techniques could be found in Ref.<sup class="footnote-reference"><a id="citeref-Golub2013" href="#footnote-Golub2013">[Golub2013]</a></sup>.</p><h2 id="The-Arnoldi-algorithm"><a class="docs-heading-anchor" href="#The-Arnoldi-algorithm">The Arnoldi algorithm</a><a id="The-Arnoldi-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#The-Arnoldi-algorithm" title="Permalink"></a></h2><p>If <span>$A$</span> is not symmetric, then the orthogonal tridiagonalization <span>$Q^T A Q = T$</span> does not exist in general. The Arnoldi approach involves the column by column generation of an orthogonal <span>$Q$</span> such that <span>$Q^TAQ = H$</span> is a Hessenberg matrix.</p><p class="math-container">\[H = \left(\begin{matrix}
h_{11} &amp; h_{12} &amp; h_{13} &amp; \ldots &amp; h_{1k}\\
h_{21} &amp; h_{22} &amp; h_{23} &amp; \ldots &amp; h_{2k}\\
0 &amp; h_{32} &amp; h_{33} &amp; \ldots &amp; h_{3k}\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
0 &amp; 0 &amp; 0 &amp; \ldots &amp; h_{kk}
\end{matrix}\right)\]</p><p>That is, <span>$h_{ij} = 0$</span> for <span>$i&gt;j+1$</span>.</p><pre><code class="language-julia hljs">function arnoldi_iteration(A::AbstractMatrix{T}, x0::AbstractVector{T}; maxiter) where T
    h = Vector{T}[]
    q = [normalize(x0)]
    n = length(x0)
    @assert size(A) == (n, n)
    for k = 1:min(maxiter, n)
        u = A * q[k]    # generate next vector
        hk = zeros(T, k+1)
        for j = 1:k # subtract from new vector its components in all preceding vectors
            hk[j] = q[j]&#39; * u
            u = u - hk[j] * q[j]
        end
        hkk = norm(u)
        hk[k+1] = hkk
        push!(h, hk)
        if abs(hkk) &lt; 1e-8 || k &gt;=n # stop if matrix is reducible
            break
        else
            push!(q, u ./ hkk)
        end
    end

    # construct `h`
    kmax = length(h)
    H = zeros(T, kmax, kmax)
    for k = 1:length(h)
        if k == kmax
            H[1:k, k] .= h[k][1:k]
        else
            H[1:k+1, k] .= h[k]
        end
    end
    return H, hcat(q...)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">arnoldi_iteration (generic function with 1 method)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import SparseArrays</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n = 100</code><code class="nohighlight hljs ansi" style="display:block;">100</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = SparseArrays.sprand(n, n, 0.1)</code><code class="nohighlight hljs ansi" style="display:block;">100×100 SparseArrays.SparseMatrixCSC{Float64, Int64} with 982 stored entries:
⎡⢀⢃⠍⠀⠄⠠⠀⠑⠀⠀⠐⠐⡔⠄⠀⠂⠀⠀⠀⠢⡨⠀⠠⠡⠦⠀⠠⠠⠒⠤⠠⠀⠙⠀⠁⢀⠐⠀⠃⠀⎤
⎢⠃⢅⠂⠼⠀⠂⠀⠅⠀⠰⠀⢥⠠⠀⡠⡀⠀⠠⡀⡀⠐⠔⠄⠐⠈⢀⠤⠠⠀⠀⢠⠀⠀⢀⠰⠠⠘⠀⠜⠠⎥
⎢⠠⠄⠂⠈⡀⠭⠀⠀⠐⡃⢀⠘⠠⠀⠀⠌⠀⢄⠁⠀⠥⡕⠠⠔⠠⠀⠠⠀⢀⠀⠀⠀⢨⣃⠰⠀⢁⠀⠀⡀⎥
⎢⠠⠈⠂⠃⠠⠀⠠⡔⠡⠡⠔⢄⠄⠔⠀⠂⠐⠀⠂⠀⠐⠀⠐⠡⢀⢐⡈⢘⢈⠀⠘⢀⠀⠀⠨⠁⠠⠤⡁⡠⎥
⎢⠡⠄⠠⢀⢰⠄⠀⠀⢀⠠⠀⢂⠄⠀⠀⠀⡐⠀⠄⢄⠀⠠⠀⠁⡈⠀⠜⠀⠀⠀⠀⠀⢉⢄⠀⠄⢐⠠⠈⠀⎥
⎢⠠⠄⠡⠀⠀⠀⠂⠢⠀⠄⡀⠄⠀⠤⠐⣄⠠⢀⠀⠄⠂⠀⠤⠀⠐⠀⠈⠠⠄⠨⠡⠀⠈⠨⠁⡆⠠⣰⠀⠔⎥
⎢⠂⠀⠁⠀⢀⠢⠂⠂⡀⠁⠀⠄⠄⡠⠈⢀⠀⡠⠤⠀⠠⠠⠐⡀⠘⠀⠸⠄⡠⠀⠃⠀⠐⠀⠐⠀⠉⠄⢈⠀⎥
⎢⠂⠀⢀⡄⢠⠀⠀⡂⡔⠦⠌⢡⢄⠀⠀⠀⠀⠂⢀⣀⠨⠀⠘⠄⠄⠀⠀⠁⠔⠄⣀⠆⠀⠠⠰⠠⠒⠀⡸⠑⎥
⎢⠀⠢⠌⢄⡀⠠⠡⠇⠀⠤⠊⠅⡠⢄⠂⡄⠀⠤⠠⠀⠀⢀⠔⢠⠀⠐⢀⢂⠄⠅⠀⠀⠐⠃⠀⠀⢅⠀⠎⢂⎥
⎢⠀⠡⠀⠄⠠⠀⠄⠄⢐⠀⠀⠄⠠⠁⠀⡀⠠⠈⠀⠔⢠⠬⠀⠄⠁⠀⠄⠀⢠⡠⠠⠤⠠⠠⠄⠠⠀⠐⢂⠂⎥
⎢⠐⠢⠀⠁⠋⠐⠞⠨⢀⢠⠁⠂⠀⠄⢐⠡⠁⡀⠈⠀⢐⠴⠢⠐⠀⢀⢐⠄⠆⠄⠀⠀⠞⠀⠈⠀⠲⠀⠙⠁⎥
⎢⠡⠂⠰⠇⠄⠒⡀⠁⠢⠀⠄⠀⠂⠒⠀⠕⠐⠂⠘⠀⠀⡔⠐⠡⠀⠂⠔⠢⠰⠀⡀⠀⠀⠑⠒⠤⢐⣐⠀⠄⎥
⎢⢒⡆⠂⠄⠂⠁⠀⠰⢀⠐⠀⢀⠠⠄⢅⡀⠂⠖⠂⠀⠆⠀⠐⠐⠐⠀⠐⠂⠀⢘⢀⠀⠐⠠⢠⠂⠈⠈⠑⡀⎥
⎢⠀⠀⠂⠐⠀⡑⠈⠒⠂⠣⠄⠃⠈⡁⠃⠃⠀⡊⠀⡂⠀⠄⢈⠒⠂⢀⢀⠀⠥⠠⠀⠣⠀⢂⢂⢈⠐⠀⠀⠀⎥
⎢⢈⠈⠀⠀⠠⠐⠄⡈⠀⢓⠀⠒⠀⠇⠀⠘⢐⠀⠀⡤⢐⠀⠀⠄⠐⠄⡄⠈⠀⢀⠘⠌⠀⠀⠀⢀⠐⠀⢑⠊⎥
⎢⠐⠀⢀⠀⠠⠀⡤⠂⠀⢣⠀⠃⡀⠐⠁⠄⠀⠀⠀⠀⠔⠈⠀⠐⠐⠀⠠⠀⠐⠦⠁⠐⠒⠂⠈⠀⠂⠆⡂⠀⎥
⎢⡂⠀⠐⠂⠠⠀⠂⡒⠰⠀⠀⢀⠐⠠⡀⠜⠀⠂⠈⠆⣈⠑⠰⠀⢐⠀⠘⠠⣐⡂⠐⢘⠃⠄⠸⠉⠐⢊⠢⠄⎥
⎢⠀⡁⢐⠐⠀⡠⢀⠀⠀⠀⠓⠁⠂⠀⠠⠀⢠⢀⠠⢁⠘⠣⣀⡔⡠⠀⠢⠖⠄⢀⡀⠀⡘⢀⠈⢠⠐⠐⠀⠀⎥
⎢⠀⠂⠠⠐⠐⠀⠊⠀⡐⡀⠢⢆⠀⠀⠐⠀⠐⠔⠠⠈⣀⠑⠴⠀⠈⢀⠐⠀⠖⠀⠀⠓⠵⠀⢀⠐⠠⠀⠀⠀⎥
⎣⠊⢦⠨⢂⠀⡀⢄⠆⠂⠂⠐⠠⠀⠂⠃⡀⠀⢀⠀⠂⠀⠀⠚⠀⠉⠀⢐⠀⠀⠠⠀⠐⠀⠀⠐⠐⠂⠀⠄⠠⎦</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q1 = randn(n)</code><code class="nohighlight hljs ansi" style="display:block;">100-element Vector{Float64}:
 -0.8946404066719399
 -0.5322743804632531
 -0.30410527266208853
 -0.5307936592777158
  0.1045233203184996
  0.6928582810187822
 -0.16232407548581967
  0.21353654680379006
  2.0581232194655987
 -0.2297702315533176
  ⋮
  0.5870490091275399
 -1.1570475475348387
  0.8345911553494154
 -0.5391040459571802
 -0.3147839861568784
  0.8936308360791005
 -2.1942305858772557
  0.017600447725928062
  0.3641842454194623</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; h, q = arnoldi_iteration(A, q1; maxiter=20)</code><code class="nohighlight hljs ansi" style="display:block;">([0.051779888348413815 0.27545106198966346 … 0.04122070888343703 -0.11399452502767436; 1.70564851208952 0.13662413883563593 … -0.11753960108345968 0.233438469794272; … ; 0.0 0.0 … 0.0030515399543376634 -0.17821006183453442; 0.0 0.0 … 1.503714161382177 0.04130815299695893], [-0.09345539350951423 0.06277119091157582 … 0.1813545148564109 0.16375433273261014; -0.05560212942569121 -0.2097776117475308 … -0.21924071817964763 -0.11856216874229394; … ; 0.0018385674913668445 -0.03615355141157223 … -0.009698065213684708 0.010826466945986603; 0.03804319781648518 0.1186333177459459 … -0.042640826166878594 -0.00788902583721911])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eigen(h).values   # naive implementation</code><code class="nohighlight hljs ansi" style="display:block;">20-element Vector{ComplexF64}:
 -1.4946296922540176 - 0.5557795071538553im
 -1.4946296922540176 + 0.5557795071538553im
 -1.3323006043621566 - 0.9159882201229043im
 -1.3323006043621566 + 0.9159882201229043im
 -0.9247522924459417 - 1.2082688337550418im
 -0.9247522924459417 + 1.2082688337550418im
 -0.5303361176785528 - 1.0613618045696507im
 -0.5303361176785528 + 1.0613618045696507im
 -0.4623128726195568 - 1.6819312717078096im
 -0.4623128726195568 + 1.6819312717078096im
 0.36958701604503186 - 1.272570677717637im
 0.36958701604503186 + 1.272570677717637im
  0.7321631183490217 + 0.0im
  0.9102663169601101 - 1.220796131674147im
  0.9102663169601101 + 1.220796131674147im
  1.2295626267829798 - 1.0067333923191033im
  1.2295626267829798 + 1.0067333923191033im
   1.825615521131109 - 0.23007584162782915im
   1.825615521131109 + 0.23007584162782915im
   5.093184842816854 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eigsolve(A, q1, 2, :LR)  # KrylovKit.eigsolve</code><code class="nohighlight hljs ansi" style="display:block;">(ComplexF64[5.093184861038573 + 0.0im, 1.862394815529195 + 0.2589846299327596im, 1.862394815529195 - 0.2589846299327596im], Vector{ComplexF64}[[0.08058060288852814 + 0.0im, 0.16922368495883505 + 0.0im, 0.039338881151316014 + 0.0im, 0.12384285204778663 + 0.0im, 0.0588119141793984 + 0.0im, 0.06780137594432657 + 0.0im, 0.1071791889953834 + 0.0im, 0.0689051806339768 + 0.0im, 0.12474318657315961 + 0.0im, 0.09085053729138672 + 0.0im  …  0.03587333547404101 + 0.0im, 0.11854352556780924 + 0.0im, 0.11313794277727582 + 0.0im, 0.09387194964571005 + 0.0im, 0.07643343550260479 + 0.0im, 0.09007849495388262 + 0.0im, 0.06449321856830313 + 0.0im, 0.09929677297967691 + 0.0im, 0.05924819878136243 + 0.0im, 0.08343644159305998 + 0.0im], [-0.00565155238661665 - 0.06687299926201384im, 0.131681643323369 - 0.1981736617019438im, 0.04800952576472898 + 0.04510203384150797im, 0.0015242332816575812 + 0.03705886238149205im, -0.001033798346108218 - 0.08684750641946387im, 0.004704811670069392 + 0.0014187795533979744im, -0.04232084324105999 - 0.037804912171305584im, 0.006555820495386119 - 0.15868433267992932im, -0.00967040324705501 + 0.08031866284806193im, 0.025758332677481247 - 0.046393936081904515im  …  -0.010056609976084202 + 0.016491582880677223im, -0.0933228262723143 + 0.0762054113487752im, 0.01439441606944953 - 0.16818836150936506im, -0.03962157988269857 + 0.0913429511272643im, -0.020626703530963634 + 0.09291198172332586im, 0.07468239050788213 - 0.07466380989794659im, 0.016988319622387216 + 0.025951067518299425im, -0.016189294193490206 + 0.03139249916988605im, 0.036817164663511884 + 0.01047923221636096im, 0.10415305151258675 + 0.11027459188806064im], [-0.00565155238661665 + 0.06687299926201384im, 0.131681643323369 + 0.1981736617019438im, 0.04800952576472898 - 0.04510203384150797im, 0.0015242332816575812 - 0.03705886238149205im, -0.001033798346108218 + 0.08684750641946387im, 0.004704811670069392 - 0.0014187795533979744im, -0.04232084324105999 + 0.037804912171305584im, 0.006555820495386119 + 0.15868433267992932im, -0.00967040324705501 - 0.08031866284806193im, 0.025758332677481247 + 0.046393936081904515im  …  -0.010056609976084202 - 0.016491582880677223im, -0.0933228262723143 - 0.0762054113487752im, 0.01439441606944953 + 0.16818836150936506im, -0.03962157988269857 - 0.0913429511272643im, -0.020626703530963634 - 0.09291198172332586im, 0.07468239050788213 + 0.07466380989794659im, 0.016988319622387216 - 0.025951067518299425im, -0.016189294193490206 - 0.03139249916988605im, 0.036817164663511884 - 0.01047923221636096im, 0.10415305151258675 - 0.11027459188806064im]], ConvergenceInfo: 3 converged values after 7 iterations and 100 applications of the linear map;
norms of residuals are given by (0.0, 2.7276932734672934e-13, 2.7276932734672934e-13).
)</code></pre><h2 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h2><p>A graph is a pair <span>$G = (V, E)$</span>, where <span>$V$</span> is a set of vertices and <span>$E$</span> is a set of edges. In Julia, the package <a href="https://github.com/JuliaGraphs/Graphs.jl"><code>Graphs.jl</code></a> provides a simple graph data structure. The following code creates a simple graph with 10 vertices.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Graphs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = SimpleGraph(10)  # create an empty graph with 10 vertices</code><code class="nohighlight hljs ansi" style="display:block;">{10, 0} undirected simple Int64 graph</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_vertex!(g)  # add a vertex</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; add_edge!(g, 3, 11)  # add an edge between vertex 3 and 11</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; has_edge(g, 3, 11)  # check if there is an edge between vertex 3 and 11</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rem_vertex!(g, 7)  # remove vertex 7</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; has_edge(g, 3, 11)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; has_edge(g, 3, 7)  # vertex number 11 &quot;renamed&quot; to vertex number 7</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; neighbors(g, 3)   # get the neighbors of vertex 3</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Int64}:
 7</code></pre><p>A graph can be represented by an adjacency matrix <span>$A \in \mathbb{R}^{n \times n}$</span>, where <span>$n$</span> is the number of vertices. The element <span>$A_{ij}$</span> is 1 if there is an edge between vertex <span>$i$</span> and vertex <span>$j$</span>, and 0 otherwise.</p><p>For example, the adjacency matrix of the Petersen graph is</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Graphs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; graph = smallgraph(:petersen)</code><code class="nohighlight hljs ansi" style="display:block;">{10, 15} undirected simple Int64 graph</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; adj_matrix = adjacency_matrix(graph)</code><code class="nohighlight hljs ansi" style="display:block;">10×10 SparseArrays.SparseMatrixCSC{Int64, Int64} with 30 stored entries:
 ⋅  1  ⋅  ⋅  1  1  ⋅  ⋅  ⋅  ⋅
 1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅
 ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅
 ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅
 1  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  1
 1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1  ⋅
 ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1
 ⋅  ⋅  1  ⋅  ⋅  1  ⋅  ⋅  ⋅  1
 ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅</code></pre><p><img src="../../assets/images/petersen.png" alt/></p><p>The Laplacian matrix <span>$L_{n\times n}$</span> of a graph <span>$G$</span> is defined as <span>$L = D - A$</span>, where <span>$D$</span> is the degree matrix of the graph. The degree matrix is a diagonal matrix, where the diagonal element <span>$D_{ii}$</span> is the degree of vertex <span>$i$</span>. The Laplacian matrix is symmetric and positive semidefinite.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; lap_matrix = laplacian_matrix(graph)</code><code class="nohighlight hljs ansi" style="display:block;">10×10 SparseArrays.SparseMatrixCSC{Int64, Int64} with 40 stored entries:
  3  -1   ⋅   ⋅  -1  -1   ⋅   ⋅   ⋅   ⋅
 -1   3  -1   ⋅   ⋅   ⋅  -1   ⋅   ⋅   ⋅
  ⋅  -1   3  -1   ⋅   ⋅   ⋅  -1   ⋅   ⋅
  ⋅   ⋅  -1   3  -1   ⋅   ⋅   ⋅  -1   ⋅
 -1   ⋅   ⋅  -1   3   ⋅   ⋅   ⋅   ⋅  -1
 -1   ⋅   ⋅   ⋅   ⋅   3   ⋅  -1  -1   ⋅
  ⋅  -1   ⋅   ⋅   ⋅   ⋅   3   ⋅  -1  -1
  ⋅   ⋅  -1   ⋅   ⋅  -1   ⋅   3   ⋅  -1
  ⋅   ⋅   ⋅  -1   ⋅  -1  -1   ⋅   3   ⋅
  ⋅   ⋅   ⋅   ⋅  -1   ⋅  -1  -1   ⋅   3</code></pre><h3 id="The-spectral-graph-theory"><a class="docs-heading-anchor" href="#The-spectral-graph-theory">The spectral graph theory</a><a id="The-spectral-graph-theory-1"></a><a class="docs-heading-anchor-permalink" href="#The-spectral-graph-theory" title="Permalink"></a></h3><p><em>Theorem</em>: The number of connected components in the graph is the dimension of the nullspace of the Laplacian and the algebraic multiplicity of the 0 eigenvalue.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; graphsize = 1000</code><code class="nohighlight hljs ansi" style="display:block;">1000</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; graph = random_regular_graph(graphsize, 3)</code><code class="nohighlight hljs ansi" style="display:block;">{1000, 1500} undirected simple Int64 graph</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; lmat = laplacian_matrix(graph)</code><code class="nohighlight hljs ansi" style="display:block;">1000×1000 SparseArrays.SparseMatrixCSC{Int64, Int64} with 4000 stored entries:
⎡⠕⢅⡘⡚⢐⡂⠄⠠⢥⣀⢄⢥⡗⡵⣵⠄⠂⣍⢤⢐⢧⡀⠷⠒⣀⢨⡢⢦⠖⡜⣈⣄⡧⠰⣀⠜⣀⠔⣃⠝⎤
⎢⣲⠨⣵⢟⠞⢱⢰⢈⣊⢲⠊⡌⠖⡐⡓⢧⣨⠊⠁⣉⠸⠈⡰⠱⠨⡨⠁⣆⢂⠠⠈⢓⢃⡤⡅⠯⠶⡩⠥⠂⎥
⎢⠰⠰⢞⣁⡵⢏⠄⠂⠑⠚⠓⢄⢁⡘⠘⣅⠋⣁⠚⠕⣧⢰⠲⢀⠶⠇⡜⢪⡄⠳⡳⡂⢔⠅⠁⣫⠹⣀⢽⡩⎥
⎢⠀⡁⡐⢒⠠⠁⠑⢄⡢⡳⢄⠐⡥⠫⣃⡈⢻⡑⡸⢙⡣⣅⣁⣐⣾⡴⠚⠪⡛⡆⢥⠄⣣⠎⡬⢃⠨⠮⡝⢍⎥
⎢⠁⢳⢪⣘⣱⠀⢬⡪⡟⢍⢨⢖⢨⠖⠡⢘⢗⠡⣇⡕⠊⣱⡘⣆⣂⡫⠥⠜⠐⠲⠀⠔⣀⡋⠁⠃⡄⠹⢀⠉⎥
⎢⠄⣕⡊⠤⠙⢄⢀⠑⢢⢖⡻⢎⠂⠊⠲⠀⡀⢍⣉⣭⡅⣦⡐⣤⡏⡔⣼⢈⠃⠀⡂⢻⠦⢂⠙⠸⠉⡕⢦⢃⎥
⎢⢝⡭⢘⠡⣁⠰⡥⡋⢢⠖⡨⠀⡱⣮⠜⣁⠓⢉⢮⠦⡔⠾⠙⡋⠎⢄⡌⠊⠒⣊⡂⡤⠖⣂⢀⠢⡫⠋⠠⠅⎥
⎢⠑⠟⠽⣌⠖⢤⡉⠸⣁⢂⠘⠂⠖⢡⠑⢄⡳⣃⠿⢦⡌⡘⢨⠉⠂⢩⢴⣑⣜⠂⢀⡌⢙⠮⡪⣣⠬⣤⠂⢀⎥
⎢⡌⢤⡢⠚⠏⢠⢟⠲⠝⡑⡄⢌⡝⢀⠽⢪⠱⢆⠼⢁⢪⠁⡧⠏⣾⠚⠘⢢⠛⢴⣂⠢⢁⡀⣲⠀⠂⠦⣫⡁⎥
⎢⢀⢓⡅⢠⢞⠄⣖⢊⢍⠽⡇⣼⠪⡗⠻⣇⠖⢃⡕⣭⡈⠑⡐⠨⠃⠷⠏⣀⠇⣯⠅⡁⢅⣃⡀⠿⢂⢾⣁⡄⎥
⎢⠉⠳⡒⠂⢉⣛⠍⢮⢎⣠⠡⣭⣰⡍⣂⠩⠎⠒⢆⠈⠱⢆⠺⠆⠆⠐⡪⡆⣌⠴⢅⢀⢐⠐⣡⡏⡪⡄⢬⣉⎥
⎢⢹⠃⢔⡊⠘⢂⢁⢸⠲⢬⠐⣬⡷⠠⡆⠒⡭⠏⡐⡈⠺⠆⡛⣬⢦⢀⡤⠥⠊⣀⠷⠚⠁⣀⡙⢄⡐⡒⢣⡧⎥
⎢⡀⣘⡂⡢⠼⠇⢚⡿⡬⡸⢋⠭⠊⢅⡌⣀⣺⠛⢭⡄⢈⠁⠈⢓⠵⣧⢮⠼⢆⣈⠤⠈⢍⠡⠖⢸⢐⠐⠣⠂⎥
⎢⠨⣎⠡⢤⡲⣉⡺⡀⣁⠇⡒⢛⡢⠉⢔⢳⠲⣀⠋⢡⠪⠮⠄⡏⣊⡗⢱⢖⡘⠼⡜⣦⡀⠶⠲⠓⠌⠄⠔⠑⎥
⎢⣘⠥⠈⡐⢤⡉⠻⠬⢰⡀⠉⠀⡸⢠⠲⠙⢛⣄⡭⣥⢂⡝⠊⢠⡈⢱⣒⡌⡱⢎⡵⠋⣳⠡⠒⣸⡴⡰⡐⠈⎥
⎢⠂⢼⢦⢀⠹⠪⠁⠗⢀⠄⣬⣈⠈⡬⡀⠴⠨⡘⠅⠡⠁⢑⣹⠃⡀⠃⠲⣭⡵⠋⠟⣥⣂⠔⡒⢓⢣⠓⢸⠂⎥
⎢⢉⡋⠉⡴⠔⠕⡩⠞⡤⠸⠨⢃⠸⢡⡳⡔⠁⠰⠥⢱⢐⠐⠁⢠⠇⡑⢠⡌⠝⡚⢈⠜⡑⣬⡎⠂⢁⣞⡜⣂⎥
⎢⣀⠜⡥⡍⡥⣠⠦⢋⠥⠀⣓⡀⠠⡐⠮⣪⠘⠚⣤⡌⡥⠾⠓⢌⣘⣁⢼⠂⣘⣠⢼⢈⠪⠉⡕⣭⠧⡐⡂⠵⎥
⎢⢀⠜⡜⡣⠓⢢⡢⡆⣄⡉⢇⠤⡯⠊⠂⣧⠨⡄⣨⣔⠊⠮⢰⠨⢐⠐⠂⠅⢐⡫⢭⠒⣡⢴⢉⠣⠟⢅⡓⠂⎥
⎣⣍⠜⠡⠃⡗⡳⡗⢍⡄⠐⠬⢓⠄⠆⠈⢀⠏⠺⠁⠼⡆⢳⠭⡶⠩⠂⢔⠁⡐⠈⠲⠒⠲⢩⢌⡌⠹⠈⠑⢄⎦</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; q1 = randn(graphsize)</code><code class="nohighlight hljs ansi" style="display:block;">1000-element Vector{Float64}:
 -0.48912906001987155
 -0.18578033262871796
  1.1490407258346873
  2.8559628032623072
  2.1399409728928456
 -1.1967019596050141
 -1.4866356071429492
 -1.1232144103618469
 -0.4125862797111172
  1.1198533557837649
  ⋮
  0.18049436191748372
  0.16466637970730172
  0.4892565123024259
 -1.3683808579322116
  0.012598015816432532
 -0.450277820097874
 -0.9005077412218836
 -0.330083003831299
 -0.737863055228323</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tri, Q = lanczos(lmat, q1; abstol=1e-8, maxiter=100)</code><code class="nohighlight hljs ansi" style="display:block;">([3.164903406886842 1.7152261046748676 … 0.0 0.0; 1.7152261046748676 2.9421087485831916 … 0.0 0.0; … ; 0.0 0.0 … 3.052403901462003 1.3732974573788232; 0.0 0.0 … 1.3732974573788232 2.9471338420162896], [-0.015308669147803605 0.05676026304956786 … -0.022010346863927388 -0.006386595138992075; -0.005814517841705015 -0.005264985112006548 … -0.020910938322655018 0.015484059453414332; … ; -0.010330875652248623 0.03385683941969212 … 0.056549817145581716 -0.02344887485744675; -0.023093498857784143 0.007312678609708654 … -0.0033194306412554692 0.001227611192981016])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; -eigen(-tri).values  # the eigenvalues of the tridiagonal matrix</code><code class="nohighlight hljs ansi" style="display:block;">100-element Vector{Float64}:
 5.831729711629271
 5.814306172730418
 5.805813014471995
 5.789213210995121
 5.778404800365127
 5.763826133376429
 5.744146943069416
 5.730058073680121
 5.70553632279454
 5.686518048646893
 ⋮
 0.2828758927457171
 0.2641886462235572
 0.24358600954224663
 0.23448019101385498
 0.2172639313956175
 0.20223205581830506
 0.19564704801013288
 0.18968563551232442
 4.440892098500626e-15</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Q&#39; * Q             # the orthogonality of the Krylov vectors</code><code class="nohighlight hljs ansi" style="display:block;">100×100 Matrix{Float64}:
  1.0          -3.59088e-16  -9.45424e-17  …   4.05177e-6   -6.19648e-6
 -3.59088e-16   1.0           3.51065e-16     -7.47624e-6    1.14336e-5
 -9.45424e-17   3.51065e-16   1.0              1.04808e-5   -1.60286e-5
  7.8236e-16   -2.70617e-16  -5.76796e-16     -1.4979e-5     2.29078e-5
 -1.30104e-16   2.08167e-17  -1.49186e-16      2.04101e-5   -3.12137e-5
 -8.58688e-16  -2.89753e-17   7.68482e-16  …  -2.853e-5      4.36316e-5
  7.67615e-17  -2.35922e-16  -1.5786e-16       4.13731e-5   -6.3273e-5
  5.6205e-16   -3.44234e-17  -7.04298e-16     -5.47421e-5    8.37186e-5
 -3.81639e-17   2.58474e-16   4.33681e-17      6.92014e-5   -0.000105832
 -2.8276e-16    1.14058e-16   8.88178e-16     -7.57395e-5    0.000115831
  ⋮                                        ⋱
 -2.97347e-7    5.48659e-7   -7.69154e-7       9.92262e-15   5.93275e-16
  4.50447e-7   -8.31156e-7    1.16518e-6       6.94236e-15  -4.1642e-15
 -6.75699e-7    1.24679e-6   -1.74785e-6      -7.53217e-15   6.95104e-15
  1.0141e-6    -1.87121e-6    2.62321e-6      -3.90313e-16   6.75501e-15
 -1.4226e-6     2.62496e-6   -3.67988e-6   …   8.67004e-15  -1.1434e-15
  2.06743e-6   -3.81478e-6    5.34787e-6       5.58321e-15  -5.71938e-15
 -2.78601e-6    5.14069e-6   -7.20663e-6      -6.72899e-15   5.74107e-15
  4.05177e-6   -7.47624e-6    1.04808e-5       1.0           6.86994e-15
 -6.19648e-6    1.14336e-5   -1.60286e-5       6.86994e-15   1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eigsolve(lmat, q1, 2, :SR)  # using function `KrylovKit.eigsolve`</code><code class="nohighlight hljs ansi" style="display:block;">([4.7097753942923064e-15, 0.18964759733655145], [[-0.03162277660168374, -0.03162277660168365, -0.03162277660168374, -0.03162277660168357, -0.031622776601683965, -0.03162277660168365, -0.03162277660168381, -0.03162277660168375, -0.03162277660168372, -0.03162277660168367  …  -0.031622776601684076, -0.03162277660168352, -0.03162277660168386, -0.031622776601683625, -0.031622776601683854, -0.031622776601683805, -0.03162277660168387, -0.03162277660168372, -0.03162277660168377, -0.031622776601683715], [-0.03776459294888834, 0.03759825022188046, -0.022040474613253456, -0.04045839638194015, 0.05201555326801285, 0.0024431597287803593, 0.021533092986346158, 0.003947754615934026, -0.02321337257417101, -0.014685365251434181  …  0.04746108636146554, -0.032423259205402406, 0.008973439328789917, -0.015144539399297425, -0.04230481058457265, 0.03793576717120889, -0.015395117638383329, 0.04033649357317359, -0.03433868579474887, 0.005311283688332886]], ConvergenceInfo: 2 converged values after 21 iterations and 270 applications of the linear map;
norms of residuals are given by (0.0, 4.506174003877872e-13).
)</code></pre><p>NOTE: with larger <code>graph_size</code>, you should see some &quot;ghost&quot; eigenvalues </p><h3 id="Graph-layout-and-clustering"><a class="docs-heading-anchor" href="#Graph-layout-and-clustering">Graph layout and clustering</a><a id="Graph-layout-and-clustering-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-layout-and-clustering" title="Permalink"></a></h3><p>Given a graph, we can use the spectral graph theory to detect the number of connected components and the clustering of the graph. What if we are interested in the clustering of the graph? The spectral clustering algorithm is a popular method to partition a graph into clusters<sup class="footnote-reference"><a id="citeref-Ng2001" href="#footnote-Ng2001">[Ng2001]</a></sup>. The algorithm is as follows:</p><p>Given a set of points <span>$S = \{s_1, \ldots,s_n\}$</span> in <span>$\mathbb{R^l}$</span> that we want to cluster into k subsets:</p><ol><li>Form the affinity matrix <span>$A \in \mathbb{R}^{n\times n}$</span> defined by <span>$A_{ij} = \exp(-\|s_i -s_j\|_2/2\sigma^2)$</span> if <span>$i \neq j$</span>, and <span>$A_{ii} = 0$</span>.</li><li>Define <span>$D$</span> to be the diagonal matrix whose <span>$(i, i)$</span>-element is the sum of <span>$A$</span>&#39;s <span>$i$</span>-th row, and construct the matrix <span>$L = D^{-1/2}AD^{-1/2}$</span>.</li><li>Find <span>$x_1 , x_2, \ldots ,x_k$</span>, the <span>$k$</span> largest eigenvectors of <span>$L$</span> (chosen to be orthogonal to each other in the case of repeated eigenvalues), and form the matrix <span>$X = [x_1x_2\ldots x_k] \in \mathbb{R}^{n\times n}$</span> by stacking the eigenvectors in columns.</li><li>Form the matrix <span>$Y$</span> from <span>$X$</span> by renormalizing each of <span>$X$</span>&#39;s rows to have unit length (i.e. <span>$Y_{ij} = X_{ij}/(\sum_j X_{i,j}^2)^{1/2}$</span>).</li><li>Treating each row of <span>$Y$</span> as a point in <span>$\mathbb{R}^k$</span>, cluster them into <span>$k$</span> clusters via K-means or any other algorithm (that attempts to minimize distortion).</li><li>Finally, assign the original point <span>$S_i$</span> to cluster <span>$j$</span> if and only if row <span>$i$</span> of the matrix <span>$Y$</span> was assigned to cluster <span>$j$</span>.</li></ol><p>Here, the scaling parameter <span>$\sigma^2$</span> controls how rapidly the affinity <span>$A_{ij}$</span> falls off with the distance between <span>$s_i$</span> and <span>$s_j$</span>, and we will later describe a method for choosing it automatically.</p><p>For an implementation of the spectral clustering algorithm, please check the <a href="https://github.com/GiggleLiu/ScientificComputingDemos/tree/main/GraphClustering">demo</a>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Golub2013"><a class="tag is-link" href="#citeref-Golub2013">Golub2013</a>Golub, Gene H., and Charles F. Van Loan. Matrix computations. JHU press, 2013.</li><li class="footnote" id="footnote-Ng2001"><a class="tag is-link" href="#citeref-Ng2001">Ng2001</a>Ng, Andrew, Michael Jordan, and Yair Weiss. &quot;On spectral clustering: Analysis and an algorithm.&quot; Advances in neural information processing systems 14 (2001).</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sensitivity/">« Sensitivity Analysis</a><a class="docs-footer-nextpage" href="../tensors/">Tensor Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 23 April 2024 11:48">Tuesday 23 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
