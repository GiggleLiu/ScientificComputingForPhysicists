<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computational complexity · Scientific Computing For Physicists</title><meta name="title" content="Computational complexity · Scientific Computing For Physicists"/><meta property="og:title" content="Computational complexity · Scientific Computing For Physicists"/><meta property="twitter:title" content="Computational complexity · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap5/complexity/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap5/complexity/"/><link rel="canonical" href="https://book.jinguo-group.science/chap5/complexity/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../../chap2/julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../../chap2/julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../../chap2/julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../../chap2/julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../../chap2/julia-release/">My First Package</a></li><li><a class="tocitem" href="../../chap2/julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../chap3/linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../../chap3/lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/qr/">QR Factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../chap3/sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Tensors and Tensor Networks</span><ul><li><a class="tocitem" href="../../chap3/tensors/">Tensor Operations</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../chap4/optimization/">Optimization</a></li><li><a class="tocitem" href="../../chap4/ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Randomness</span><ul><li><a class="tocitem" href="../montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Computational complexity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Computational complexity</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap5/complexity.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Computational-complexity"><a class="docs-heading-anchor" href="#Computational-complexity">Computational complexity</a><a id="Computational-complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-complexity" title="Permalink"></a></h1><p>This chapter introduces the basic concepts of computational complexity theory. We will discuss the complexity of algorithms and problems and the concept of NP-completeness and the P vs NP problem. We will also discuss several algorithms and techniques for solving hard problems, such as simulated annealing and branch-and-bound algorithms. The following two books are highly recommended for further reading:</p><ul><li><a href="https://books.google.com/books?hl=zh-CN&amp;lr=&amp;id=jnGKbpMV8xoC&amp;oi=fnd&amp;pg=PT8&amp;dq=the+nature+of+computation&amp;ots=9_Kzg7K6f1&amp;sig=kiFuaFuPQvtWYFCNsVAsG0DRWmE">The Nature of Computation</a> by Moore and Mertens<sup class="footnote-reference"><a id="citeref-Moore2011" href="#footnote-Moore2011">[Moore2011]</a></sup></li><li><a href="https://dl.acm.org/doi/fullHtml/10.1145/2428556.2428575">Exact Exponential Algorithms</a> by Fomin and Kaski<sup class="footnote-reference"><a id="citeref-Fomin2013" href="#footnote-Fomin2013">[Fomin2013]</a></sup>.</li><li>Github repo: <a href="https://github.com/QuantumBFS/SSSS">Deep Learning and Quantum Programming: A Spring School</a></li></ul><h2 id="Problems-that-can-be-verified-in-polynomial-time"><a class="docs-heading-anchor" href="#Problems-that-can-be-verified-in-polynomial-time">Problems that can be verified in polynomial time</a><a id="Problems-that-can-be-verified-in-polynomial-time-1"></a><a class="docs-heading-anchor-permalink" href="#Problems-that-can-be-verified-in-polynomial-time" title="Permalink"></a></h2><p>In this section, we want to discuss a seemingly trivially correct statement: <em>the hardness to solve a problem is not the same as the hardness to verify a solution.</em></p><p>To narrow the discussion we will focus on decision problems, which are problems that have a yes/no answer. We require that the answer can be verified in polynomial time. This means that given a solution to the problem, we can check whether it is correct in polynomial time. This is known as the class <span>$NP$</span> (non-deterministic polynomial time).</p><p>Even for <span>$NP$</span> problems, it is not proved that any of them cannot be solved in polynomial time (complexity class <span>$P$</span>). The question of whether <span>$P = NP$</span> is one of the most famous open problems in computer science. If <span>$P = NP$</span>, then every problem that can be verified in polynomial time can also be solved in polynomial time. If <span>$P \neq NP$</span>, then there are problems that can be verified in polynomial time but cannot be solved in polynomial time.</p><p>Maybe the most famous easy to verify but hard to solve problem is the factorization of a number, which is the basis of many cryptographic systems.</p><div class="admonition is-category-example"><header class="admonition-header">Factoring a number</header><div class="admonition-body"><p>Given a number and its factors, it is easy to verify that the factors are correct. However, finding the factors in the first place can be very difficult. This is an example of a problem that can be verified in polynomial time, but may not be solvable in time polynomial to the input size (number of bits).</p><p><strong>Example</strong> Given that <span>$x &gt; 1$</span> and <span>$y &gt; 1$</span> such that</p><p class="math-container">\[x \times y = 2033\]</p><p>find <span>$x$</span> and <span>$y$</span>.</p><p><strong>Solution</strong></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function factorize(n)
           for x in 2:floor(Int, sqrt(n))
               if n % x == 0
                   return x, n ÷ x
               end
           end
           return nothing   # no factors found
       end</code><code class="nohighlight hljs ansi" style="display:block;">factorize (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; factorize(2033)</code><code class="nohighlight hljs ansi" style="display:block;">(19, 107)</code></pre><p>This algorithm has a time complexity of <span>$O(\sqrt{n})$</span>. In terms of the number of bits of the input <span>$m \approx \log_2(n)$</span>, the time complexity is <span>$O(2^{m/2})$</span>, which is exponential in the input size.</p></div></div><p>Factoring a number is a hard problem, but is not as hard as some other problems in NP. It can be shown by <strong>reducing</strong> the factoring problem to a problem that is known to be <strong>NP-complete</strong> (a problem that is at least as hard as any other problem in NP). Here the reduction must be done in polynomial time and the with the solution of the NP-complete problem, we can solve the factoring problem in polynomial time.</p><p>In the following, we will discuss a well known NP-complete problem, the <strong>spin-glass problem</strong> and show how the factoring problem can be reduced to the spin-glass problem in polynomial time.</p><div class="admonition is-category-example"><header class="admonition-header">Spin-glass problem</header><div class="admonition-body"><p>The spin-glass problem is a problem in statistical mechanics and combinatorial optimization. It is a generalization of the Ising model, where the interactions between the spins are random. The goal is to find the ground state of the system, which is the configuration of spins that minimizes the energy of the system. For integer coupling strength, this problem is NP-complete, which means that it is believed to be computationally intractable in general. To make the statement more rigorous, the decision version of the problem is NP-complete, which means that it is NP-complete to determine whether the energy of the system is below a certain threshold.</p><p><strong>Example</strong> Given a spin-glass that defined on a Petersen graph, the coupling strength is 1. Consider that we use integer variables to store the coupling strength, the size of input is <span>$O(n^2)$</span> for a general graph of size <span>$n$</span>. Determine whether the energy of the system is below -8? <img src="../../assets/images/petersen.png" alt/></p><p><strong>Solution</strong> In the following, we use the generic tensor network approach to solve this problem.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using GenericTensorNetworks, Graphs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = smallgraph(:petersen)</code><code class="nohighlight hljs ansi" style="display:block;">{10, 15} undirected simple Int64 graph</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; J = ones(Int, 15)</code><code class="nohighlight hljs ansi" style="display:block;">15-element Vector{Int64}:
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; problem = SpinGlass(g, J)  # problem instance</code><code class="nohighlight hljs ansi" style="display:block;">GenericTensorNetworks.SpinGlass{Vector{Int64}}(10, [[1, 2], [1, 5], [1, 6], [2, 3], [2, 7], [3, 4], [3, 8], [4, 5], [4, 9], [5, 10]  …  [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tensor_network = GenericTensorNetwork(problem)  # the tensor network with optimized contraction order</code><code class="nohighlight hljs ansi" style="display:block;">GenericTensorNetworks.GenericTensorNetwork{GenericTensorNetworks.SpinGlass{Vector{Int64}}, OMEinsum.DynamicNestedEinsum{Int64}, Int64}(GenericTensorNetworks.SpinGlass{Vector{Int64}}(10, [[1, 2], [1, 5], [1, 6], [2, 3], [2, 7], [3, 4], [3, 8], [4, 5], [4, 9], [5, 10]  …  [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 2∘3∘7, 3∘7∘2 -&gt;
├─ 2∘6∘5, 3∘5∘6∘7 -&gt; 2∘3∘7
│  ├─ 2∘6∘1, 1∘5 -&gt; 2∘6∘5
│  │  ├─ 1∘2, 1∘6 -&gt; 2∘6∘1
│  │  │  ├─ 2, 2∘1 -&gt; 1∘2
│  │  │  │  ├─ 2
│  │  │  │  └─ 1, 1∘2 -&gt; 2∘1
│  │  │  │     ⋮
│  │  │  │
│  │  │  └─ 6, 1∘6 -&gt; 1∘6
│  │  │     ├─ 6
│  │  │     └─ 6, 1∘6 -&gt; 1∘6
│  │  │        ⋮
│  │  │
│  │  └─ 5, 1∘5 -&gt; 1∘5
│  │     ├─ 5
│  │     └─ 5, 1∘5 -&gt; 1∘5
│  │        ├─ 5
│  │        └─ 1∘5
│  └─ 3∘5∘6∘7, 3∘6∘5∘7 -&gt; 3∘5∘6∘7
│     ├─ 3∘5∘9, 6∘7∘9 -&gt; 3∘5∘6∘7
│     │  ├─ 3∘4, 5∘9∘4 -&gt; 3∘5∘9
│     │  │  ├─ 4, 3∘4 -&gt; 3∘4
│     │  │  │  ⋮
│     │  │  │
│     │  │  └─ 4∘5, 4∘9 -&gt; 5∘9∘4
│     │  │     ⋮
│     │  │
│     │  └─ 6∘9, 7∘9 -&gt; 6∘7∘9
│     │     ├─ 6∘9
│     │     └─ 7∘9
│     └─ 3∘6∘8, 5∘7∘8 -&gt; 3∘6∘5∘7
│        ├─ 3∘8, 6∘8 -&gt; 3∘6∘8
│        │  ├─ 8, 3∘8 -&gt; 3∘8
│        │  │  ⋮
│        │  │
│        │  └─ 6∘8
│        └─ 5∘10, 7∘8∘10 -&gt; 5∘7∘8
│           ├─ 10, 5∘10 -&gt; 5∘10
│           │  ⋮
│           │
│           └─ 7∘10, 8∘10 -&gt; 7∘8∘10
│              ⋮
│
└─ 2∘3, 2∘7 -&gt; 3∘7∘2
   ├─ 3, 2∘3 -&gt; 2∘3
   │  ├─ 3
   │  └─ 3, 2∘3 -&gt; 2∘3
   │     ├─ 3
   │     └─ 2∘3
   └─ 7, 2∘7 -&gt; 2∘7
      ├─ 7
      └─ 7, 2∘7 -&gt; 2∘7
         ├─ 7
         └─ 2∘7
, Dict{Int64, Int64}())</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; minimum_energy = solve(tensor_network, SizeMin())[]</code><code class="nohighlight hljs ansi" style="display:block;">-9.0ₜ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; optimal_config = solve(tensor_network, SingleConfigMin())[]</code><code class="nohighlight hljs ansi" style="display:block;">(-9.0, GenericTensorNetworks.ConfigSampler{10, 1, 1}(0101111100))ₜ</code></pre><p>The tensor network based algorithm has a time complexity of <span>$O(2^{{\rm tw}(G)})$</span>, which is exponential in the treewidth of the graph <span>$G$</span> - a quantity that upper bounded by the number of vertices. For the Petersen graph, the treewidth is 4. Since in the worst case, the treewidth is <span>$O(n)$</span>, the time complexity is <span>$O(2^n)$</span>, which is exponential in the input size.</p></div></div><div class="admonition is-category-example"><header class="admonition-header">Hard-core lattice gas</header><div class="admonition-body"><p>The hard-core lattice gas model is a simple model of a gas of particles that interact via hard-core repulsion. The goal is to find the ground state of the system, which is the configuration of particles that maximizes the distance between neighboring particles. The problem is NP-complete, which means that it is believed to be computationally intractable in general.</p></div></div><div class="admonition is-category-example"><header class="admonition-header">Circuit SAT</header><div class="admonition-body"><p>In theoretical computer science, the circuit satisfiability problem (also known as CIRCUIT-SAT, CircuitSAT, CSAT, etc.) is the decision problem of determining whether a given Boolean circuit has an assignment of its inputs that makes the output true. In other words, it asks whether the inputs to a given Boolean circuit can be consistently set to 1 or 0 such that the circuit outputs 1. If that is the case, the circuit is called satisfiable. Otherwise, the circuit is called unsatisfiable. In the figure to the right, the left circuit can be satisfied by setting both inputs to be 1, but the right circuit is unsatisfiable.</p></div></div><div class="admonition is-category-example"><header class="admonition-header">Proving a theorem</header><div class="admonition-body"><p>Given a statement and a proof of the statement, it is easy to verify that the proof is correct. However, finding the proof in the first place can be very difficult. This is an example of a problem that can be verified in polynomial time, but may not be solvable in polynomial time.</p></div></div><h2 id="Problem-reduction"><a class="docs-heading-anchor" href="#Problem-reduction">Problem reduction</a><a id="Problem-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-reduction" title="Permalink"></a></h2><div class="admonition is-category-example"><header class="admonition-header">Circuit SAT to Spin-glass</header><div class="admonition-body"><p>Please check the demo package: https://github.com/GiggleLiu/ScientificComputingDemos/tree/main/Spinglass <sup class="footnote-reference"><a id="citeref-Glover2019" href="#footnote-Glover2019">[Glover2019]</a></sup>.</p></div></div><div class="admonition is-category-example"><header class="admonition-header">Circuit SAT to Hard-core lattice gas</header><div class="admonition-body"><p>Please check the Ref.<sup class="footnote-reference"><a id="citeref-Nguyen2023" href="#footnote-Nguyen2023">[Nguyen2023]</a></sup>.</p></div></div><h2 id="Algorithm:-Tropical-tensor-network"><a class="docs-heading-anchor" href="#Algorithm:-Tropical-tensor-network">Algorithm: Tropical tensor network</a><a id="Algorithm:-Tropical-tensor-network-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm:-Tropical-tensor-network" title="Permalink"></a></h2><p>(WIP)<sup class="footnote-reference"><a id="citeref-Liu2021" href="#footnote-Liu2021">[Liu2021]</a></sup><sup class="footnote-reference"><a id="citeref-Liu2023" href="#footnote-Liu2023">[Liu2023]</a></sup></p><h2 id="Algorithm:-Branching-and-bounding"><a class="docs-heading-anchor" href="#Algorithm:-Branching-and-bounding">Algorithm: Branching and bounding</a><a id="Algorithm:-Branching-and-bounding-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm:-Branching-and-bounding" title="Permalink"></a></h2><p>The branching algorithm<sup class="footnote-reference"><a id="citeref-Fomin2013" href="#footnote-Fomin2013">[Fomin2013]</a></sup> is a general algorithm for solving optimization problems. It works by recursively dividing the search space into smaller subspaces and solving each subspace separately. The algorithm starts with the entire search space and divides it into smaller subspaces using a branching rule. It then solves each subspace separately and combines the solutions to find the optimal solution for the entire search space. The algorithm uses a bounding rule to determine when to stop dividing the search space and when to combine the solutions.</p><p>Let us use the independent set problem as an example, which is a well-known NP-complete problem. The independent set problem is to find a set of vertices in a graph such that no two vertices are adjacent. The goal is to find the largest independent set in the graph.</p><p>The branching algorithm for the independent set problem is as follows:</p><ol><li>Start with the entire graph <span>$G$</span>.</li><li>If <span>$G$</span> is empty, return the empty set.</li><li>If <span>$G$</span> has no edges, return all vertices in <span>$G$</span>.</li><li>Otherwise, choose a vertex <span>$v$</span> in <span>$G$</span>.</li><li>Recursively solve the independent set problem on <span>$G - \{v\}$</span> and <span>$G - N(v)$</span>, where <span>$N(v)$</span> is the set of neighbors of <span>$v$</span>.</li><li>Combine the solutions to find the largest independent set in <span>$G$</span>.</li></ol><div class="admonition is-category-example"><header class="admonition-header">Branching algorithm for independent set</header><div class="admonition-body"><p>Given a graph <span>$G$</span> with vertices and edges, find the largest independent set in the graph.</p><p><strong>Solution</strong></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Graphs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function mis1(g::SimpleGraph)
           N = nv(g)
           if N == 0
               return 0
           else
               dmin, vmin = findmin(v-&gt;degree(g, v), vertices(g))
               return 1 + mapreduce(y-&gt;mis1((gi = copy(g); rem_vertices!(gi, neighbors(g, y) ∪ [y]); gi)), max, neighbors(g, vmin) ∪ [vmin])
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">mis1 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mis1(smallgraph(:petersen))</code><code class="nohighlight hljs ansi" style="display:block;">4</code></pre><p>The algorithm has a time complexity of <span>$O(2^n)$</span>, which is exponential in the number of vertices in the graph. In the worst case, the algorithm may need to explore all possible subsets of vertices to find the largest independent set.</p></div></div><p>The algorithm works by dividing the search space into smaller subspaces by removing a vertex <span>$v$</span> and its neighbors from the graph. It then solves each subspace separately and combines the solutions to find the largest independent set in the original graph. The algorithm uses a bounding rule to determine when to stop dividing the search space and when to combine the solutions.</p><h2 id="Algorithm:-Simulated-Annealing"><a class="docs-heading-anchor" href="#Algorithm:-Simulated-Annealing">Algorithm: Simulated Annealing</a><a id="Algorithm:-Simulated-Annealing-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm:-Simulated-Annealing" title="Permalink"></a></h2><p>Simulated annealing<sup class="footnote-reference"><a id="citeref-Cain2023" href="#footnote-Cain2023">[Cain2023]</a></sup> is a probabilistic optimization algorithm that is used to find the global minimum of an energy function. It is inspired by the process of annealing in metallurgy, where a material is heated and then slowly cooled to increase its strength and reduce its defects. The algorithm starts with a thermal state, where the temperature is high and the system is in a random state. It then gradually cools the system, reducing the temperature and allowing the system to settle into a low-energy state. The algorithm uses a probabilistic acceptance criterion, usually based on the Metropolis-Hastings algorithm, to accept or reject moves that increase the energy of the system. This allows the algorithm to escape local minima and explore the energy landscape more effectively.</p><p>For the spin-glass problem, the energy function is given by</p><p class="math-container">\[E(\sigma) = \sum_{(i,j)\in E} J_{ij} \sigma_i \sigma_j\]</p><p>where <span>$\sigma_i$</span> is the spin at site <span>$i$</span>, <span>$J_{ij}$</span> is the coupling strength between sites <span>$i$</span> and <span>$j$</span>, and the sum is over all pairs of sites that are connected by an edge in the graph. The goal is to find the ground state of the system, which is the configuration of spins that minimizes the energy of the system.</p><p>The simulated annealing algorithm starts with a random initial configuration <span>$\sigma$</span> and a high temperature <span>$T_H$</span>. The temperature is gradually reduced according to a cooling schedule, such as exponential cooling or linear cooling. For each temperature <span>$T$</span>, the algorithm samples a new configuration <span>$\sigma&#39;$</span> by flipping a random spin in the current configuration <span>$\sigma$</span>. The algorithm then calculates the change in energy <span>$\Delta E = E(\sigma&#39;) - E(\sigma)$</span> and accepts the move with probability</p><p class="math-container">\[P(\sigma \to \sigma&#39;) = \exp(-\Delta E / T)\]</p><p>The algorithm repeats this process for a fixed number of steps or until the system reaches thermal equilibrium. The temperature is then reduced according to a cooling schedule, and the process is repeated until the system converges to a low-energy state.</p><h2 id="Hands-on"><a class="docs-heading-anchor" href="#Hands-on">Hands-on</a><a id="Hands-on-1"></a><a class="docs-heading-anchor-permalink" href="#Hands-on" title="Permalink"></a></h2><p>The following demo package contains the code for solving the spin-glass problem using the different approaches: https://github.com/GiggleLiu/ScientificComputingDemos/tree/main/Spinglass</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Moore2011"><a class="tag is-link" href="#citeref-Moore2011">Moore2011</a>Moore, Cristopher, and Stephan Mertens. The nature of computation. OUP Oxford, 2011.</li><li class="footnote" id="footnote-Fomin2013"><a class="tag is-link" href="#citeref-Fomin2013">Fomin2013</a>Fomin, Fedor V., and Petteri Kaski. &quot;Exact exponential algorithms.&quot; Communications of the ACM 56.3 (2013): 80-88.</li><li class="footnote" id="footnote-Liu2021"><a class="tag is-link" href="#citeref-Liu2021">Liu2021</a>Liu, Jin-Guo, Lei Wang, and Pan Zhang. <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.126.090506">Tropical tensor network for ground states of spin glasses.</a> Physical Review Letters 126.9 (2021): 090506.</li><li class="footnote" id="footnote-Liu2023"><a class="tag is-link" href="#citeref-Liu2023">Liu2023</a>Liu, Jin-Guo, et al. <a href="https://epubs.siam.org/doi/abs/10.1137/22M1501787">Computing solution space properties of combinatorial optimization problems via generic tensor networks.</a> SIAM Journal on Scientific Computing 45.3 (2023): A1239-A1270.</li><li class="footnote" id="footnote-Cain2023"><a class="tag is-link" href="#citeref-Cain2023">Cain2023</a>Cain, M., et al. &quot;Quantum speedup for combinatorial optimization with flat energy landscapes (2023).&quot; arXiv preprint arXiv:2306.13123.</li><li class="footnote" id="footnote-Nguyen2023"><a class="tag is-link" href="#citeref-Nguyen2023">Nguyen2023</a>Nguyen, Minh-Thi, et al. &quot;Quantum optimization with arbitrary connectivity using Rydberg atom arrays.&quot; PRX Quantum 4.1 (2023): 010316.</li><li class="footnote" id="footnote-Glover2019"><a class="tag is-link" href="#citeref-Glover2019">Glover2019</a>Glover, Fred, Gary Kochenberger, and Yu Du. &quot;Quantum Bridge Analytics I: a tutorial on formulating and using QUBO models.&quot; 4or 17.4 (2019): 335-371.</li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Wednesday 24 April 2024 09:40">Wednesday 24 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
