<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Markov Chain Monte Carlo · Scientific Computing For Physicists</title><meta name="title" content="Markov Chain Monte Carlo · Scientific Computing For Physicists"/><meta property="og:title" content="Markov Chain Monte Carlo · Scientific Computing For Physicists"/><meta property="twitter:title" content="Markov Chain Monte Carlo · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap5/montecarlo/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap5/montecarlo/"/><link rel="canonical" href="https://book.jinguo-group.science/chap5/montecarlo/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../../chap2/julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../../chap2/julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../../chap2/julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../../chap2/julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../../chap2/julia-release/">My First Package</a></li><li><a class="tocitem" href="../../chap2/julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../chap3/linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../../chap3/lu/">Solving linear equations by LU factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/qr/">QR Factorization: Bottom-up</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/sensitivity/">Sensitivity Analysis</a></li><li><a class="tocitem" href="../../chap3/sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Tensors and Tensor Networks</span><ul><li><a class="tocitem" href="../../chap3/tensors/">Tensor Operations</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../chap4/optimization/">Optimization</a></li><li><a class="tocitem" href="../../chap4/ad/">Automatic Differentiation</a></li></ul></li><li><span class="tocitem">Randomness</span><ul><li class="is-active"><a class="tocitem" href>Markov Chain Monte Carlo</a><ul class="internal"><li><a class="tocitem" href="#Ferromagnetic-Ising-Model"><span>Ferromagnetic Ising Model</span></a></li><li><a class="tocitem" href="#Metropolis-Hastings-Algorithm"><span>Metropolis-Hastings Algorithm</span></a></li><li><a class="tocitem" href="#Ergodicity-and-Detailed-Balance"><span>Ergodicity and Detailed Balance</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Randomness</a></li><li class="is-active"><a href>Markov Chain Monte Carlo</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Markov Chain Monte Carlo</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap5/montecarlo.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Markov-Chain-Monte-Carlo"><a class="docs-heading-anchor" href="#Markov-Chain-Monte-Carlo">Markov Chain Monte Carlo</a><a id="Markov-Chain-Monte-Carlo-1"></a><a class="docs-heading-anchor-permalink" href="#Markov-Chain-Monte-Carlo" title="Permalink"></a></h1><p>In this chapter, we will introduce the concept of Markov Chain Monte Carlo (MCMC) methods. MCMC methods are a class of algorithms that are used to sample from a probability distribution. They are particularly useful when the distribution is high-dimensional and it is difficult to sample from it directly. MCMC methods are widely used in Bayesian statistics, machine learning, and other fields.</p><p>In physics, MCMC methods are often used to sample from the Boltzmann distribution of a system. This is useful for studying the equilibrium properties of the system, such as the energy, magnetization, and other thermodynamic quantities. In this chapter, we will focus on the Ferromagnetic Ising Model, which is a simple model of a magnetic system. We will use MCMC methods to sample from the Boltzmann distribution of the Ising model and study its properties.</p><h2 id="Ferromagnetic-Ising-Model"><a class="docs-heading-anchor" href="#Ferromagnetic-Ising-Model">Ferromagnetic Ising Model</a><a id="Ferromagnetic-Ising-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Ferromagnetic-Ising-Model" title="Permalink"></a></h2><p>The Ferromagnetic Ising Model is a simple model of a magnetic system. It consists of a lattice of spins, which can be in one of two states: up or down. The energy of the system is given by the Hamiltonian:</p><p class="math-container">\[H = -J \sum_{\langle i, j \rangle} s_i s_j - h \sum_i s_i\]</p><p>where the first sum is over pairs of neighboring spins, <span>$s_i$</span> and <span>$s_j$</span>, <span>$J$</span> is the coupling constant, and <span>$h$</span> is the external magnetic field. The spins interact with each other through the first term, which favors alignment of neighboring spins. The second term represents the interaction of the spins with the external magnetic field.</p><p>The probability distribution of the Ising model is given by the Boltzmann distribution:</p><p class="math-container">\[P(\{s\}) = \frac{1}{Z} e^{-\beta H(\{s\})}\]</p><p>where <span>$\{s\}$</span> is the configuration of spins, <span>$Z$</span> is the partition function, <span>$\beta = 1/(k_B T)$</span> is the inverse temperature, and <span>$H(\{s\})$</span> is the Hamiltonian of the system. The partition function is given by:</p><p class="math-container">\[Z = \sum_{\{s\}} e^{-\beta H(\{s\})}\]</p><p>where the sum is over all possible configurations of spins.</p><h2 id="Metropolis-Hastings-Algorithm"><a class="docs-heading-anchor" href="#Metropolis-Hastings-Algorithm">Metropolis-Hastings Algorithm</a><a id="Metropolis-Hastings-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Metropolis-Hastings-Algorithm" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Why importance sampling?</header><div class="admonition-body"><p>Consider a target function <span>$f(x)$</span> that to be integrated over a domain <span>$D$</span>. The integral is given by:</p><p class="math-container">\[I = \int_D f(x) dx\]</p><p>If we can sample from a probability distribution <span>$p(x)$</span>, we can estimate the integral by averaging over the samples:</p><p class="math-container">\[I = \int_D \frac{f(x)}{p(x)} p(x)dx \approx \frac{1}{N} \sum_{i=1}^N \frac{f(x_i)}{p(x_i)}\]</p><p>where <span>$x_i$</span> are the samples drawn from the distribution <span>$p(x)$</span>. It can be shown that the standard deviation of the estimation scales as <span>$1/\sqrt{N}$</span>, and the result converges the faster the better the importance sampling distribution <span>$p(x)$</span> matches the target function <span>$f(x)$</span>.</p></div></div><p>The Metropolis-Hastings algorithm is a popular importance sampling method that is used to sample from a probability distribution. It works by constructing a Markov chain that has the desired distribution as its stationary distribution. The algorithm proceeds as follows:</p><ol><li>Start with an initial configuration of spins <span>$\{s\}$</span>.</li><li>Propose a new configuration <span>$\{s&#39;\}$</span> by flipping the spin of a randomly chosen site.</li><li>Calculate the change in energy <span>$\Delta E = H(\{s&#39;\}) - H(\{s\})$</span>.</li><li>If <span>$\Delta E &lt; 0$</span>, accept the new configuration <span>$\{s&#39;\}$</span> with probability 1.</li><li>If <span>$\Delta E &gt; 0$</span>, accept the new configuration <span>$\{s&#39;\}$</span> with probability <span>$e^{-\beta \Delta E}$</span>.</li><li>Repeat steps 2-5 for a large number of iterations to sample from the distribution.</li></ol><p>To study the equilibrium properties from the generated samples such as the energy, magnetization, and other thermodynamic quantities, we can use the generated samples to calculate the expectation value of the observable of interest. For example, the expectation value of an operator <span>$A$</span> is given by:</p><p class="math-container">\[\langle A \rangle = \sum_{\{s\}} A(\{s\}) P(\{s\}) = \frac{1}{Z} \sum_{\{s\}} A(\{s\}) e^{-\beta H(\{s\})}\]</p><p>where <span>$P(\{s\})$</span> is the probability distribution of the system. In practice, we can estimate the expectation value by averaging over the generated samples:</p><p class="math-container">\[\frac{1}{M} \sum_{i=1}^M A(s_i)\]</p><p>where <span>$M$</span> is the number of samples and <span>$\{s_i\}$</span> is the <span>$i$</span>-th sample. In this model, quantities of interest include</p><ul><li>Energy per site: <span>$E = \frac{1}{N} \sum_{i=1}^N H_i$</span>, where <span>$N$</span> is the number of spins.</li><li>Energy squared per site: <span>$E^2 = \frac{1}{N} \sum_{i=1}^N H_i^2$</span>.</li><li>Magnetization per site: <span>$M = \frac{1}{N} \sum_{i=1}^N s_i$</span>.</li><li>Magnetization squared per site: <span>$M^2 = \frac{1}{N} \sum_{i=1}^N s_i^2$</span>.</li><li>Magnetization quartic per site: <span>$M^4 = \frac{1}{N} \sum_{i=1}^N s_i^4$</span>, which is used to study the Binder ratio.</li></ul><h2 id="Ergodicity-and-Detailed-Balance"><a class="docs-heading-anchor" href="#Ergodicity-and-Detailed-Balance">Ergodicity and Detailed Balance</a><a id="Ergodicity-and-Detailed-Balance-1"></a><a class="docs-heading-anchor-permalink" href="#Ergodicity-and-Detailed-Balance" title="Permalink"></a></h2><p>The Metropolis-Hastings algorithm satisfies two important properties: ergodicity and detailed balance. Ergodicity means that the Markov chain can reach any state in the state space with a non-zero probability. Detailed balance means that the transition probabilities satisfy the condition:</p><p class="math-container">\[P(\{s\} \to \{s&#39;\}) P(\{s&#39;\}) = P(\{s&#39;\} \to \{s\}) P(\{s\})\]</p><p>where <span>$P(\{s\} \to \{s&#39;\})$</span> is the probability of transitioning from state <span>$\{s\}$</span> to state <span>$\{s&#39;\}$</span>, and <span>$P(\{s\})$</span> is the probability of being in state <span>$\{s\}$</span>. The Metropolis-Hastings algorithm satisfies detailed balance by construction, which ensures that the stationary distribution of the Markov chain is the desired distribution.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>Our implementation of the Metropolis-Hastings algorithm for solving the Ising model is based on Anders Sandvik&#39;s lecture note<sup class="footnote-reference"><a id="citeref-Sandvik" href="#footnote-Sandvik">[Sandvik]</a></sup>. We use a 2D square lattice with periodic boundary conditions and initialize the lattice with random spins. We then run the Metropolis-Hastings algorithm for a large number of iterations to sample from the Boltzmann distribution. The source code is also available in the <a href="https://github.com/GiggleLiu/ScientificComputingDemos/tree/main/IsingModel">demo repository</a>. Both simple update and Swendsen-Wang&#39;s cluster update<sup class="footnote-reference"><a id="citeref-Swendsen1987" href="#footnote-Swendsen1987">[Swendsen1987]</a></sup> are implemented.</p><pre><code class="language-julia hljs"># required interfaces: num_spin, energy
abstract type AbstractSpinModel end

# IsingSpinModel: a struct that represents the Ising model
struct IsingSpinModel{RT} &lt;: AbstractSpinModel
    l::Int  # lattice size
    h::RT   # magnetic field
    beta::RT  # inverse temperature 1/T
    pflp::NTuple{10, RT}  # precomputed flip probabilities
    neigh::Matrix{Int}  # neighbors
end
function IsingSpinModel(l::Int, h::RT, beta::RT) where RT
    pflp = ([exp(-2*s*(i + h) * beta) for s=-1:2:1, i in -4:2:4]...,)
    neigh = lattice(l)
    IsingSpinModel(l, h, beta, pflp, neigh)
end

# Constructs a list neigh[1:4,1:nn] of neighbors of each site
function lattice(ll)
    lis = LinearIndices((ll, ll))
    return reshape([lis[mod1(ci.I[1]+di, ll), mod1(ci.I[2]+dj, ll)] for (di, dj) in ((1, 0), (0, 1), (-1, 0), (0, -1)), ci in CartesianIndices((ll, ll))], 4, ll*ll)
end

# Returns the number of spins in the model
num_spin(model::IsingSpinModel) = model.l^2

# Computes the energy of the system
energy(model::IsingSpinModel, spin) = ferromagnetic_energy(model.neigh, model.h, spin)
function ferromagnetic_energy(neigh::AbstractMatrix, h::Real, spin::AbstractMatrix)
    @boundscheck size(neigh) == (4, length(spin))
    sum(1:length(spin)) do i
        s = spin[i]
        - s * (spin[neigh[1, i]] + spin[neigh[2, i]] + h)
    end
end

# Computes the probability of flipping a spin
@inline function pflip(model::IsingSpinModel, s::Integer, field::Integer)
    return @inbounds model.pflp[(field + 5) + (1 + s) &gt;&gt; 1]
end

# Updates the spin configuration using the Metropolis-Hastings algorithm
function mcstep!(model::IsingSpinModel, spin)
    nn = num_spin(model)
    @inbounds for _ = 1:nn
        s = rand(1:nn)
        field = spin[model.neigh[1, s]] + spin[model.neigh[2, s]] + spin[model.neigh[3, s]] + spin[model.neigh[4, s]]
        if rand() &lt; pflip(model, spin[s], field)
           spin[s] = -spin[s]
        end
    end
end

# Simulation result
struct SimulationResult{RT}
    nbins::Int  # number of bins
    nsteps_eachbin::Int  # number of steps in each bin
    current_bin::Base.RefValue{Int}  # current bin
    energy::Vector{RT}  # energy/spin
    energy2::Vector{RT}  # (energy/spin)^2
    m::Vector{RT}  # |m|
    m2::Vector{RT}  # m^2
    m4::Vector{RT}  # m^4
end
SimulationResult(nbins, nsteps_eachbin) = SimulationResult(nbins, nsteps_eachbin, Ref(0), zeros(nbins), zeros(nbins), zeros(nbins), zeros(nbins), zeros(nbins))

# Measures the energy and magnetization of the system
function measure!(result::SimulationResult, model::AbstractSpinModel, spin)
    @boundscheck checkbounds(result.energy, result.current_bin[])
    m = sum(spin)
    e = energy(model, spin)
    n = num_spin(model)
    k = result.current_bin[]
    @inbounds result.energy[k] += e/n
    @inbounds result.energy2[k] += (e/n)^2
    @inbounds result.m[k] += abs(m/n)
    @inbounds result.m2[k] += (m/n)^2
    @inbounds result.m4[k] += (m/n)^4
end

# Simulates the Ising model and measures the energy and magnetization of the system
function simulate!(model::IsingSpinModel, spin; nsteps_heatbath, nsteps_eachbin, nbins)
    # heat bath
    for _ = 1:nsteps_heatbath
        mcstep!(model, spin)
    end
    result = SimulationResult(nbins, nsteps_eachbin)
    for j=1:nbins
        result.current_bin[] = j
        for _ = 1:nsteps_eachbin
            mcstep!(model, spin)
            measure!(result, model, spin)
        end
    end
    return result
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">simulate! (generic function with 1 method)</code></pre><p>The following code snippet demonstrates how to use the Ising model implementation to simulate the Ising model and measure the energy and magnetization of the system.</p><pre><code class="language-julia hljs">using CairoMakie
# an example for testing
lattice_size = 100
temperature = 2.0
magnetic_field = 0.0
model = IsingSpinModel(lattice_size, magnetic_field, 1/temperature)

# Constructs the initial random spin configuration
spin = rand([-1,1], model.l, model.l);

nsteps_heatbath = 1000
nsteps_eachbin = 100
nbins = 100
result = simulate!(model, spin; nsteps_heatbath, nsteps_eachbin, nbins)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.SimulationResult{Float64}(100, 100, Base.RefValue{Int64}(100), [-169.20800000000003, -169.61359999999993, -170.13680000000005, -170.13199999999995, -170.15, -170.47240000000005, -171.2212, -171.0492, -171.61560000000003, -173.7476  …  -174.3432, -175.0164, -174.52800000000002, -173.95879999999985, -174.75240000000002, -173.64399999999998, -174.49599999999998, -174.20199999999997, -174.632, -175.0056], [286.33744447999993, 287.71308832000005, 289.48471488, 289.46964864, 289.53171696000004, 290.63695952000006, 293.1970507199998, 292.59562511999997, 294.5417396799999, 301.91318576000003  …  303.97415264000006, 306.3305828800002, 304.6258902399999, 302.6408398400001, 305.42064080000006, 301.54688576000024, 304.5077504000001, 303.48704975999993, 304.98533152000016, 306.2928208], [66.136, 65.16659999999999, 68.32319999999999, 69.70899999999999, 67.49880000000002, 69.0364, 75.9166, 80.152, 84.8208, 89.16180000000004  …  91.00500000000007, 91.27839999999992, 91.11559999999999, 90.65180000000001, 91.14500000000001, 90.55179999999999, 91.03340000000001, 90.85140000000004, 91.38020000000003, 91.461], [43.76022760000003, 42.502143959999984, 46.69387944000001, 48.61101244, 45.59060727999999, 47.669539920000005, 57.732789720000014, 64.25595448000001, 71.97513008, 79.51023275999997  …  82.82384539999997, 83.32289048, 83.02603608000001, 82.18382604000004, 83.08516468, 82.00267452000001, 82.87597844000003, 82.54538308000002, 83.50848683999997, 83.65896524000001], [19.185208039381607, 18.124773046282463, 21.827708926737397, 23.66453465527181, 20.84006029964275, 22.74181572706659, 33.55991990660956, 41.32068592670001, 51.88930607726737, 63.2567864913399  …  68.6136504258871, 69.44513498236343, 68.95148495133631, 67.56264307491986, 69.06821292342282, 67.2652705076499, 68.7014626378265, 68.15594321982952, 69.75363755644406, 70.01418934303817])</code></pre><p>The result contains the energy and magnetization of the system for each bin. We can use this data to calculate the mean energy and magnetization of the system and study its properties. The following code visualizes the energy and magnetization of the system over time.</p><pre><code class="language-julia hljs">fig = Figure()
ax = Axis(fig[1, 1], xlabel=&quot;time&quot;)

for (op, legend) in zip([:energy, :energy2, :m, :m2, :m4], [L&quot;energy/spin&quot;, L&quot;(energy/spin)^2&quot;, L&quot;|m|&quot;, L&quot;m^2&quot;, L&quot;m^4&quot;])
    lines!(ax, getfield(result, op), label=legend)
end
axislegend(ax)
fig</code></pre><img src="537f83dc.png" alt="Example block output"/><h3 id="Phase-transition"><a class="docs-heading-anchor" href="#Phase-transition">Phase transition</a><a id="Phase-transition-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-transition" title="Permalink"></a></h3><h4 id="Simple-update,-temperature-1.0"><a class="docs-heading-anchor" href="#Simple-update,-temperature-1.0">Simple update, temperature = 1.0</a><a id="Simple-update,-temperature-1.0-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-update,-temperature-1.0" title="Permalink"></a></h4><p>We first set the temperature to 1.0, which is below the phase transition point <span>$T_c = 2.269$</span>. The video below shows the evolution of the spins over update steps. The spins tend to align with each other due to the ferromagnetic interaction, resulting in large clusters of aligned spins.</p><pre><code class="language-julia hljs">temperature = 1.0
model = IsingSpinModel(lattice_size, magnetic_field, 1/temperature)
# animation
fig = Figure()
spin = rand([-1,1], model.l, model.l)
spinobs = Observable(spin)
ax1 = Axis(fig[1, 1]; aspect = DataAspect()); hidedecorations!(ax1); hidespines!(ax1)  # hides ticks, grid and lables, and frame
Makie.heatmap!(ax1, spinobs, camera=campixel!)
txt = Observable(&quot;t = 0&quot;)
Makie.text!(ax1, -30, lattice_size-10; text=txt, color=:black, fontsize=30, strokecolor=:white)
filename = joinpath(@__DIR__, &quot;ising-spins-$temperature.mp4&quot;)
record(fig, filename, 2:1000; framerate = 24) do i
    mcstep!(model, spin)
    spinobs[] = spin
    txt[] = &quot;t = $(i-1)&quot;
end</code></pre><video width="320" height="240" controls style="margin-bottom:30px">
  <source src="../../assets/images/ising-spins-1.0.mp4" type="video/mp4">
</video><h4 id="Simple-update,-temperature-3.0"><a class="docs-heading-anchor" href="#Simple-update,-temperature-3.0">Simple update, temperature = 3.0</a><a id="Simple-update,-temperature-3.0-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-update,-temperature-3.0" title="Permalink"></a></h4><p>Next, we set the temperature to 3.0, which is above the phase transition point. The video below shows the evolution of the spins over update steps. The spins are disordered and do not align with each other, resulting in small clusters of aligned spins.</p><video width="320" height="240" controls style="margin-bottom:30px">
  <source src="../../assets/images/ising-spins-3.0.mp4" type="video/mp4">
</video>
<br><h4 id="Cluster-update,-temperature-1.0"><a class="docs-heading-anchor" href="#Cluster-update,-temperature-1.0">Cluster update, temperature = 1.0</a><a id="Cluster-update,-temperature-1.0-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-update,-temperature-1.0" title="Permalink"></a></h4><p>The cluster update, or the Swendsen-Wang algorithm, is a more efficient way to update the spins in the Ising model. It works by grouping the spins into clusters of aligned spins and flipping the clusters with a certain probability. The implementation of the cluster update could be found in the <a href="https://github.com/GiggleLiu/ScientificComputingDemos/tree/main/IsingModel">demo repository</a>. The video below shows the evolution of the spins using the cluster update. The spins align with each other more quickly compared to the simple update.</p><video width="320" height="240" controls style="margin-bottom:30px">
  <source src="../../assets/images/swising-spins-1.0.mp4" type="video/mp4">
</video>
<br><h4 id="Cluster-update,-temperature-3.0"><a class="docs-heading-anchor" href="#Cluster-update,-temperature-3.0">Cluster update, temperature = 3.0</a><a id="Cluster-update,-temperature-3.0-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-update,-temperature-3.0" title="Permalink"></a></h4><p>Similarly, we set the temperature to 3.0 and use the cluster update. The video below shows the evolution of the spins over update steps. The spins are disordered and do not align with each other, resulting in small clusters of aligned spins.</p><video width="320" height="240" controls>
  <source src="../../assets/images/swising-spins-3.0.mp4" type="video/mp4">
</video><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Sandvik"><a class="tag is-link" href="#citeref-Sandvik">Sandvik</a>Lecture note: Monte Carlo simulations in classical statistical physics, Anders Sandvik (<a href="https://physics.bu.edu/~py502/lectures5/mc.pdf">PDF</a>)</li><li class="footnote" id="footnote-Swendsen1987"><a class="tag is-link" href="#citeref-Swendsen1987">Swendsen1987</a>Swendsen, Robert H., and Jian-Sheng Wang. &quot;Nonuniversal critical dynamics in Monte Carlo simulations.&quot; Physical review letters 58.2 (1987): 86.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../chap4/ad/">« Automatic Differentiation</a><a class="docs-footer-nextpage" href="../../append/plotting/">Plotting recipes with CairoMakie »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Wednesday 24 April 2024 09:40">Wednesday 24 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
