<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Computational complexity (WIP) · Scientific Computing For Physicists</title><meta name="title" content="Computational complexity (WIP) · Scientific Computing For Physicists"/><meta property="og:title" content="Computational complexity (WIP) · Scientific Computing For Physicists"/><meta property="twitter:title" content="Computational complexity (WIP) · Scientific Computing For Physicists"/><meta name="description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:description" content="Documentation for Scientific Computing For Physicists."/><meta property="twitter:description" content="Documentation for Scientific Computing For Physicists."/><meta property="og:url" content="https://book.jinguo-group.science/chap6/complexity/"/><meta property="twitter:url" content="https://book.jinguo-group.science/chap6/complexity/"/><link rel="canonical" href="https://book.jinguo-group.science/chap6/complexity/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Computing For Physicists</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Become an Open-source Developer</span><ul><li><a class="tocitem" href="../../chap1/terminal/">Get a Terminal!</a></li><li><a class="tocitem" href="../../chap1/git/">Maintainability - Version Control</a></li><li><a class="tocitem" href="../../chap1/ci/">Correctness - Unit Tests</a></li></ul></li><li><span class="tocitem">Julia Programming Language</span><ul><li><a class="tocitem" href="../../chap2/julia-setup/">Setup Julia</a></li><li><a class="tocitem" href="../../chap2/julia-why/">Why Julia?</a></li><li><a class="tocitem" href="../../chap2/julia-type/">Types and Multiple-dispatch</a></li><li><a class="tocitem" href="../../chap2/julia-array/">Array and Broadcasting</a></li><li><a class="tocitem" href="../../chap2/julia-release/">My First Package</a></li><li><a class="tocitem" href="../../chap2/julia-fluid/">Project: Fluid dynamics</a></li></ul></li><li><span class="tocitem">Linear Algebra</span><ul><li><a class="tocitem" href="../../chap3/linalg/">Matrix Computation</a></li><li><a class="tocitem" href="../../chap3/linalg-impl/">Matrix Computation (Implementation)</a></li><li><a class="tocitem" href="../../chap3/fft/">Fast Fourier transform</a></li><li><a class="tocitem" href="../../chap3/sensitivity/">Sensitivity Analysis</a></li></ul></li><li><span class="tocitem">Sparse Matrices</span><ul><li><a class="tocitem" href="../../chap4/sparse/">Sparse Matrices and Graphs</a></li></ul></li><li><span class="tocitem">Tensors and Tensor Networks</span><ul><li><a class="tocitem" href="../../chap5/tensors/">Tensor Operations</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../optimization/">Optimization</a></li><li><a class="tocitem" href="../ad/">Automatic Differentiation</a></li><li class="is-active"><a class="tocitem" href>Computational complexity (WIP)</a><ul class="internal"><li><a class="tocitem" href="#Problems-that-can-be-verified-in-polynomial-time"><span>Problems that can be verified in polynomial time</span></a></li><li><a class="tocitem" href="#Problem-reduction"><span>Problem reduction</span></a></li><li><a class="tocitem" href="#Algorithm:-Tropical-tensor-network"><span>Algorithm: Tropical tensor network</span></a></li><li><a class="tocitem" href="#Algorithm:-Branching-and-bounding"><span>Algorithm: Branching and bounding</span></a></li><li><a class="tocitem" href="#Algorithm:-Simulated-Annealing"><span>Algorithm: Simulated Annealing</span></a></li><li><a class="tocitem" href="#Hands-on"><span>Hands-on</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Randomness</span><ul><li><a class="tocitem" href="../../chap7/montecarlo/">Markov Chain Monte Carlo</a></li></ul></li><li><span class="tocitem">Appendix</span><ul><li><a class="tocitem" href="../../append/plotting/">Plotting recipes with CairoMakie</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Optimization</a></li><li class="is-active"><a href>Computational complexity (WIP)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Computational complexity (WIP)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/GiggleLiu/ScientificComputingForPhysicists/blob/main/docs/src/chap6/complexity.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Computational-complexity-(WIP)"><a class="docs-heading-anchor" href="#Computational-complexity-(WIP)">Computational complexity (WIP)</a><a id="Computational-complexity-(WIP)-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-complexity-(WIP)" title="Permalink"></a></h1><p>In the previous chapter, we discussed the spin-glass problem and mentioned that it is a hard problem to solve but did not explain why it is widely believed to be hard. In this chapter, we will introduce the basic concepts of computational complexity theory, which is the study of when and why some problems are <em>hard</em> to solve. Here, <em>hard</em> in the context of computational complexity theory means that the time or space required to solve the problem grows faster than polynomial (e.g. exponential) with the size of the input. We will discuss the complexity of algorithms and problems and the concept of NP-completeness and the P vs NP problem. We will also discuss several algorithms and techniques for solving hard problems, such as simulated annealing and branch-and-bound algorithms. The following two books are highly recommended for further reading:</p><ul><li><a href="https://books.google.com/books?hl=zh-CN&amp;lr=&amp;id=jnGKbpMV8xoC&amp;oi=fnd&amp;pg=PT8&amp;dq=the+nature+of+computation&amp;ots=9_Kzg7K6f1&amp;sig=kiFuaFuPQvtWYFCNsVAsG0DRWmE">The Nature of Computation</a> by Moore and Mertens<sup class="footnote-reference"><a id="citeref-Moore2011" href="#footnote-Moore2011">[Moore2011]</a></sup></li><li><a href="https://dl.acm.org/doi/fullHtml/10.1145/2428556.2428575">Exact Exponential Algorithms</a> by Fomin and Kaski<sup class="footnote-reference"><a id="citeref-Fomin2013" href="#footnote-Fomin2013">[Fomin2013]</a></sup>.</li></ul><h2 id="Problems-that-can-be-verified-in-polynomial-time"><a class="docs-heading-anchor" href="#Problems-that-can-be-verified-in-polynomial-time">Problems that can be verified in polynomial time</a><a id="Problems-that-can-be-verified-in-polynomial-time-1"></a><a class="docs-heading-anchor-permalink" href="#Problems-that-can-be-verified-in-polynomial-time" title="Permalink"></a></h2><p>In this section, we want to discuss a seemingly trivially correct but unproved statement: <em>the hardness to solve a problem is not the same as the hardness to verify a solution.</em></p><p>To narrow the discussion we will focus on decision problems, which are problems that have a yes/no answer. We require that the answer can be verified in polynomial time. This means that given a solution to the problem, we can check whether it is correct in polynomial time. This is known as the class <span>$NP$</span> (non-deterministic polynomial time).</p><p>Interestingly, it is not yet proved that any problem in <span>$NP$</span> cannot be solved in polynomial time (complexity class <span>$P$</span>). The question of whether <span>$P = NP$</span> is one of the most famous open problems in computer science. If <span>$P = NP$</span>, then every problem that can be verified in polynomial time can also be solved in polynomial time.</p><p>Maybe the most famous problem that easy to verify but hard to solve is the integer factorization problem, which is the basis of many cryptographic systems.</p><div class="admonition is-category-example"><header class="admonition-header">Factoring a number</header><div class="admonition-body"><p><em>Input</em>: A <span>$n$</span> bit integer <span>$x$</span>.</p><p><em>Question</em>: Is there a non-trivial factoring of <span>$x$</span>? i.e. <span>$p \times q = x$</span> where <span>$p&gt;1$</span> and <span>$q&gt;1$</span> are integers.</p><p>Given a number and its factors, it is easy to verify that the factors are correct. However, finding the factors in the first place can be very difficult.</p><p><strong>Example</strong> Given that <span>$x &gt; 1$</span> and <span>$y &gt; 1$</span> such that</p><p class="math-container">\[x \times y = 2033\]</p><p>find <span>$x$</span> and <span>$y$</span>.</p><p>Solving this problem is not easy. One simple algorithm is to iterate over all possible factors of <span>$x$</span> and check if they are factors of <span>$n$</span>. The following Julia code shows how to factorize a number using this algorithm:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function factorize(n)
           for x in 2:floor(Int, sqrt(n))
               if n % x == 0
                   return x, n ÷ x
               end
           end
           return nothing   # no factors found
       end</code><code class="nohighlight hljs ansi" style="display:block;">factorize (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; factorize(2033)</code><code class="nohighlight hljs ansi" style="display:block;">(19, 107)</code></pre><p>This algorithm has a time complexity of <span>$O(\sqrt{n})$</span>. In terms of the number of bits of the input <span>$m \approx \log_2(n)$</span>, the time complexity is <span>$O(2^{m/2})$</span>, which is exponential in the input size.</p></div></div><p>Factoring a number is a hard problem, but is not as hard as some other problems in NP. It can be shown by <strong>reducing</strong> the factoring problem to another problem in NP. In computational complexity theory, a problem <span>$A$</span> is said to be <strong>reducible</strong> to another problem <span>$B$</span> if an algorithm for any instance of <span>$A$</span>, there is a polynomial-time algorithm that maps the instance of <span>$A$</span> to an instance of <span>$B$</span> such that the solution of the instance of <span>$B$</span> can be used to solve the instance of <span>$A$</span> in polynomial time. If <span>$A$</span> is reducible to <span>$B$</span>, we write <span>$A \leq_p B$</span>.</p><p>In the following, we show <span>${\rm Factoring} \leq_p {\rm Circuit SAT}$</span>, where Circuit SAT is a well-known NP-complete problem (the hardest problems in NP).</p><div class="admonition is-category-example"><header class="admonition-header">Circuit SAT</header><div class="admonition-body"><p><em>Input</em>: A Boolean circuit <span>$C$</span>.</p><p><em>Question</em>: Is there an assignment of the inputs to the circuit that makes the output true?</p><p><strong>Example</strong> Given a Boolean circuit</p><p class="math-container">\[x_3 = (x_1 \lor x_2) \land (\neg (x_1 \land x_2))\]</p><p>where <span>$\lor$</span> is the logical OR, <span>$\land$</span> is the logical AND, and <span>$\neg$</span> is the logical NOT. Find an assignment of the inputs <span>$(x_1, x_2)$</span> that makes the output <span>$x_3 = 1$</span>.</p><p>It is easy to verify that the solution is given by the assignment <span>$(x_1, x_2) = (1, 0)$</span> or <span>$(x_1, x_2) = (0, 1)$</span>. For larger circuits, the problem becomes harder to solve.</p></div></div><p>Given the fact that any problem in NP can be verified in polynomial time, and any verification program can be encoded as a Boolean circuit. By definition, solving a problem in NP is equivalent to solving the Circuit SAT problem that encodes the verification program. Therefore, the Circuit SAT problem is in NP-complete.</p><p>In the following, we will discuss another well known NP-complete problem, the <strong>spin-glass problem</strong> and show <span>${\rm Circuit SAT} \leq_p \text{Spin-glass}$</span>.</p><div class="admonition is-category-example"><header class="admonition-header">Spin-glass problem</header><div class="admonition-body"><p><em>Input</em>: A graph <span>$G = (V, E)$</span> and a set of integer coupling strengths <span>$J_{ij}$</span> for each edge <span>$(i, j) \in E$</span>.</p><p><em>Question</em>: Is there a configuration of spins <span>$\sigma_i \in \{-1, 1\}$</span> that has an energy below a certain threshold <span>$E_t$</span>? The energy of the system is given by</p><p class="math-container">\[E(\sigma) = \sum_{(i,j)\in E} J_{ij} \sigma_i \sigma_j\]</p><p>The spin-glass problem is a problem in statistical mechanics and combinatorial optimization. It is a generalization of the Ising model, where the interactions between the spins are random. The goal is to find the ground state of the system, which is the configuration of spins that minimizes the energy of the system. This problem could be decomposed into finite yes/no questions - the decision problem above.</p><p><strong>Example</strong> Given a spin-glass that defined on a Petersen graph, the coupling strength is 1. Consider that we use integer variables to store the coupling strength, the size of input is <span>$O(n^2)$</span> for a general graph of size <span>$n$</span>. Determine whether the energy of the system is below -8? <img src="../../assets/images/petersen.png" alt/></p><p><strong>Method 1: Generic tensor networks</strong> In the following, we use the generic tensor network approach to solve this problem.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using GenericTensorNetworks, Graphs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = smallgraph(:petersen)</code><code class="nohighlight hljs ansi" style="display:block;">{10, 15} undirected simple Int64 graph</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; J = ones(Int, 15)</code><code class="nohighlight hljs ansi" style="display:block;">15-element Vector{Int64}:
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; problem = SpinGlass(g, J)  # problem instance</code><code class="nohighlight hljs ansi" style="display:block;">GenericTensorNetworks.SpinGlass{Vector{Int64}}(10, [[1, 2], [1, 5], [1, 6], [2, 3], [2, 7], [3, 4], [3, 8], [4, 5], [4, 9], [5, 10]  …  [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tensor_network = GenericTensorNetwork(problem)  # the tensor network with optimized contraction order</code><code class="nohighlight hljs ansi" style="display:block;">GenericTensorNetworks.GenericTensorNetwork{GenericTensorNetworks.SpinGlass{Vector{Int64}}, OMEinsum.DynamicNestedEinsum{Int64}, Int64}(GenericTensorNetworks.SpinGlass{Vector{Int64}}(10, [[1, 2], [1, 5], [1, 6], [2, 3], [2, 7], [3, 4], [3, 8], [4, 5], [4, 9], [5, 10]  …  [1], [2], [3], [4], [5], [6], [7], [8], [9], [10]], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), 2∘4∘3, 2∘4∘3 -&gt;
├─ 2∘6∘4∘10, 3∘6∘10 -&gt; 2∘4∘3
│  ├─ 2∘6∘4∘10, 2∘10∘4∘6 -&gt; 2∘6∘4∘10
│  │  ├─ 2∘5∘6, 4∘10∘5 -&gt; 2∘6∘4∘10
│  │  │  ├─ 1∘2, 5∘6∘1 -&gt; 2∘5∘6
│  │  │  │  ├─ 2, 2∘1 -&gt; 1∘2
│  │  │  │  │  ⋮
│  │  │  │  │
│  │  │  │  └─ 1∘5, 1∘6 -&gt; 5∘6∘1
│  │  │  │     ⋮
│  │  │  │
│  │  │  └─ 4∘5, 5∘10 -&gt; 4∘10∘5
│  │  │     ├─ 4∘5
│  │  │     └─ 10, 5∘10 -&gt; 5∘10
│  │  │        ⋮
│  │  │
│  │  └─ 2∘10∘7, 4∘6∘7 -&gt; 2∘10∘4∘6
│  │     ├─ 2∘7, 7∘10 -&gt; 2∘10∘7
│  │     │  ├─ 7, 2∘7 -&gt; 2∘7
│  │     │  │  ⋮
│  │     │  │
│  │     │  └─ 7∘10
│  │     └─ 4∘6∘9, 7∘9 -&gt; 4∘6∘7
│  │        ├─ 4∘9, 6∘9 -&gt; 4∘6∘9
│  │        │  ⋮
│  │        │
│  │        └─ 7∘9
│  └─ 3∘8, 6∘10∘8 -&gt; 3∘6∘10
│     ├─ 8, 3∘8 -&gt; 3∘8
│     │  ├─ 8
│     │  └─ 8, 3∘8 -&gt; 3∘8
│     │     ├─ 8
│     │     └─ 3∘8
│     └─ 6∘8, 8∘10 -&gt; 6∘10∘8
│        ├─ 6∘8
│        └─ 8∘10
└─ 2∘3, 3∘4 -&gt; 2∘4∘3
   ├─ 3, 2∘3 -&gt; 2∘3
   │  ├─ 3
   │  └─ 3, 2∘3 -&gt; 2∘3
   │     ├─ 3
   │     └─ 2∘3
   └─ 4, 3∘4 -&gt; 3∘4
      ├─ 4
      └─ 4, 3∘4 -&gt; 3∘4
         ├─ 4
         └─ 3∘4
, Dict{Int64, Int64}())</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; minimum_energy = solve(tensor_network, SizeMin())[]</code><code class="nohighlight hljs ansi" style="display:block;">-9.0ₜ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; optimal_config = solve(tensor_network, SingleConfigMin())[]</code><code class="nohighlight hljs ansi" style="display:block;">(-9.0, GenericTensorNetworks.ConfigSampler{10, 1, 1}(1011011001))ₜ</code></pre><p>The tensor network based algorithm has a time complexity of <span>$O(2^{{\rm tw}(G)})$</span>, which is exponential in the treewidth of the graph <span>$G$</span> - a quantity that upper bounded by the number of vertices. For the Petersen graph, the treewidth is 4. Since in the worst case, the treewidth is <span>$O(n)$</span>, the time complexity is <span>$O(2^n)$</span>, which is exponential in the input size.</p><p><strong>Method 2: Integer programming</strong> In the following, we use the integer programming approach to solve this problem.</p><pre><code class="nohighlight hljs"># To be added</code></pre><p>Many other algorithms can be used to solve the spin-glass problem. One good reference is the challenge in the GitGub repo: <a href="https://github.com/QuantumBFS/SSSS">Deep Learning and Quantum Programming: A Spring School</a></p></div></div><div class="admonition is-category-example"><header class="admonition-header">Hard-core lattice gas</header><div class="admonition-body"><p><em>Input</em>: A graph <span>$G = (V, E)$</span> and weights associated with vertices <span>$\{\mu_{i} \mid i\in V\}$</span>.</p><p><em>Question</em>: Is there a configuration of particles <span>$n_i \in \{0, 1\}$</span> that has a hard-core lattice gas energy below a certain threshold <span>$E_t$</span>? The hard-core lattice gas energy is given by</p><p class="math-container">\[E(\mathbf n) = \sum_{(i,j)\in E} U_{ij} n_i n_j + \sum_{i\in V} \mu_i n_i\]</p><p>where <span>$\mathbf n$</span> is the configuration of the particles, <span>$n_i$</span> is the occupation number of site <span>$i$</span>, <span>$U_{ij} \rightarrow \infty$</span> is the interaction strength between sites <span>$i$</span> and <span>$j$</span>, and <span>$\mu_i$</span> is the chemical potential at site <span>$i$</span>.</p><p>The hard-core lattice gas energy model describes a gas of particles on a lattice that interact via hard-core repulsion. Each lattice site <span>$i \in V$</span> can be occupied by at most one particle, and two particles cannot occupy adjacent vertices.</p><p>It is a special case of the independent set problem, which asks what is the maximum set of mutually non-adjacent vertices on a graph. The only extra constraint is that the graph is a lattice graph. It turns out that the hard-core lattice gas model is also in NP-complete.</p><p><strong>Example</strong></p></div></div><div class="admonition is-category-example"><header class="admonition-header">Proving a theorem</header><div class="admonition-body"><p>Given a statement and a proof of the statement, it is easy to verify that the proof is correct. However, finding the proof in the first place can be very difficult. This is an example of a problem that can be verified in polynomial time, but may not be solvable in polynomial time.</p></div></div><h2 id="Problem-reduction"><a class="docs-heading-anchor" href="#Problem-reduction">Problem reduction</a><a id="Problem-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-reduction" title="Permalink"></a></h2><h3 id="The-composibility-of-Hamiltonians"><a class="docs-heading-anchor" href="#The-composibility-of-Hamiltonians">The composibility of Hamiltonians</a><a id="The-composibility-of-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#The-composibility-of-Hamiltonians" title="Permalink"></a></h3><p>The weighted MIS reduction in Ref.<sup class="footnote-reference"><a id="citeref-Nguyen2023" href="#footnote-Nguyen2023">[Nguyen2023]</a></sup> transforms a generic Boolean constraint satisfaction problem (CSP) to a weighted MIS problem. Each clause <span>$C$</span> in the CSP problem is mapped to a MIS problem on a weighted graph <span>$G=(V, E, \delta)$</span>, where <span>$V$</span> is the set of vertices, <span>$E$</span> is the set of edges, and <span>$\delta$</span> is a mapping from a vertex <span>$v\in V$</span> to the associated weight <span>$\delta(v)$</span>. An evaluation of a clause can be obtained from a vertex set of the corresponding <span>$G$</span> by identifying each boolean variable with a vertex <span>$v\in V$</span>. If the vertex <span>$v$</span> is in the set, the corresponding boolean variable is set to be true, otherwise it is set to be false. We require that any MIS of <span>$G$</span> corresponds to a solution (or a consistent and complete evaluation) of <span>$C$</span>, while any solution of <span>$C$</span> corresponds to a MIS of <span>$G$</span>.</p><p>We denote such a pair of <span>$(C, G)$</span> as a weighted MIS gadget. The energy model for the MIS problem on <span>$G$</span> is</p><p class="math-container">\[H_\text{MWIS}(G) = -\sum_{v \in V}\delta(v) n_v + \sum_{(u, v) \in E} \infty \, n_u n_v,\]</p><p>where <span>$n_v \in \{0, 1\}$</span> is a boolean variable for representing whether the vertex <span>$v$</span> is in the set or not. The weighted MISs of <span>$G$</span> are the ground states of <span>$H_\text{MWIS}(G)$</span>. The weighted MIS reduction scheme is based on the observation that weighted MIS problems corresponding to the various clauses are <em>composible</em>, i.e. by adding up the cost functions for each clause, one obtaines a cost function whose minimum that encodes the boolean variable assignment satisfies  all clauses. Formally, for any two weighted MIS gadgets <span>$(C_1, G_1)$</span> and <span>$(C_2, G_2)$</span>, their composition is defined as</p><p class="math-container">\[\begin{split}
    &amp;\texttt{compose}:((C_1, G_1), (C_2, G_2)) \mapsto (C_1\land C_2, G_1 + G_2),\\
    &amp;G_1 + G_2 = (V_1 \cup V_2, E_1\cup E_2, \delta:v\mapsto \delta_1(v)+\delta_2(v)).
\end{split}\]</p><p>The weight of a vertex in the composed graph is the sum of the weights in the original graphs. <span>$\delta_1$</span> and <span>$\delta_2$</span> are the weight functions for <span>$G_1$</span> and <span>$G_2$</span> respectively. If a vertex <span>$v$</span> is absent in <span>$G_1$</span> or <span>$G_2$</span>, <span>$\delta_1(v)$</span> or <span>$\delta_2(v)$</span> is set to <span>$0$</span>.</p><p>With composibility, any conjunction of local constraints can be mapped to the addition of the corresponding energy models. By solving the ground state of the composed model, the MISs of the composed graph can be obtained, which encodes the boolean variable assignment that all constraints are simultaneously satisfied.</p><div class="admonition is-category-example"><header class="admonition-header">Circuit SAT to Spin-glass</header><div class="admonition-body"><p>Please check the demo package: https://github.com/GiggleLiu/ScientificComputingDemos/tree/main/Spinglass <sup class="footnote-reference"><a id="citeref-Glover2019" href="#footnote-Glover2019">[Glover2019]</a></sup>.</p></div></div><div class="admonition is-category-example"><header class="admonition-header">Circuit SAT to Hard-core lattice gas</header><div class="admonition-body"><p>In Ref.<sup class="footnote-reference"><a id="citeref-Nguyen2023" href="#footnote-Nguyen2023">[Nguyen2023]</a></sup>, a universal set of weighted MIS gadgets are designed, which enables us to encode any Boolean constraint satisfaction problem to a weighted MIS problem. To further reduce the weighted MIS problem to that on a KSG, a pair of connected vertices must be made physically close to each other. This constraint can be fulfilled by introducing a <em>crossing lattice</em>, in which a vertex in the original graph is mapped to a chain or a tri-branched tree, namely the copy gadget. Copy gadgets are designed to copy the information of a vertex to the vicinity of other vertices, which enables us to equivalently add an edge between any two vertices. To further remove the non-unit-disk subgraphs like crossings from the crossing lattice, weighted crossing gadgets are introduced.</p></div></div><h2 id="Algorithm:-Tropical-tensor-network"><a class="docs-heading-anchor" href="#Algorithm:-Tropical-tensor-network">Algorithm: Tropical tensor network</a><a id="Algorithm:-Tropical-tensor-network-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm:-Tropical-tensor-network" title="Permalink"></a></h2><p>(WIP)<sup class="footnote-reference"><a id="citeref-Liu2021" href="#footnote-Liu2021">[Liu2021]</a></sup><sup class="footnote-reference"><a id="citeref-Liu2023" href="#footnote-Liu2023">[Liu2023]</a></sup></p><h2 id="Algorithm:-Branching-and-bounding"><a class="docs-heading-anchor" href="#Algorithm:-Branching-and-bounding">Algorithm: Branching and bounding</a><a id="Algorithm:-Branching-and-bounding-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm:-Branching-and-bounding" title="Permalink"></a></h2><p>The branching algorithm<sup class="footnote-reference"><a id="citeref-Fomin2013" href="#footnote-Fomin2013">[Fomin2013]</a></sup> is a general algorithm for solving optimization problems. It works by recursively dividing the search space into smaller subspaces and solving each subspace separately. The algorithm starts with the entire search space and divides it into smaller subspaces using a branching rule. It then solves each subspace separately and combines the solutions to find the optimal solution for the entire search space. The algorithm uses a bounding rule to determine when to stop dividing the search space and when to combine the solutions.</p><p>Let us use the independent set problem as an example, which is a well-known NP-complete problem. The independent set problem is to find a set of vertices in a graph such that no two vertices are adjacent. The goal is to find the largest independent set in the graph.</p><p>The branching algorithm for the independent set problem is as follows:</p><ol><li>Start with the entire graph <span>$G$</span>.</li><li>If <span>$G$</span> is empty, return the empty set.</li><li>If <span>$G$</span> has no edges, return all vertices in <span>$G$</span>.</li><li>Otherwise, choose a vertex <span>$v$</span> in <span>$G$</span>.</li><li>Recursively solve the independent set problem on <span>$G - \{v\}$</span> and <span>$G - N(v)$</span>, where <span>$N(v)$</span> is the set of neighbors of <span>$v$</span>.</li><li>Combine the solutions to find the largest independent set in <span>$G$</span>.</li></ol><div class="admonition is-category-example"><header class="admonition-header">Branching algorithm for independent set</header><div class="admonition-body"><p>Given a graph <span>$G$</span> with vertices and edges, find the largest independent set in the graph.</p><p><strong>Solution</strong></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Graphs</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function mis1(g::SimpleGraph)
           N = nv(g)
           if N == 0
               return 0
           else
               dmin, vmin = findmin(v-&gt;degree(g, v), vertices(g))
               return 1 + mapreduce(y-&gt;mis1((gi = copy(g); rem_vertices!(gi, neighbors(g, y) ∪ [y]); gi)), max, neighbors(g, vmin) ∪ [vmin])
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">mis1 (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mis1(smallgraph(:petersen))</code><code class="nohighlight hljs ansi" style="display:block;">4</code></pre><p>The algorithm has a time complexity of <span>$O(2^n)$</span>, which is exponential in the number of vertices in the graph. In the worst case, the algorithm may need to explore all possible subsets of vertices to find the largest independent set.</p></div></div><p>The algorithm works by dividing the search space into smaller subspaces by removing a vertex <span>$v$</span> and its neighbors from the graph. It then solves each subspace separately and combines the solutions to find the largest independent set in the original graph. The algorithm uses a bounding rule to determine when to stop dividing the search space and when to combine the solutions.</p><h2 id="Algorithm:-Simulated-Annealing"><a class="docs-heading-anchor" href="#Algorithm:-Simulated-Annealing">Algorithm: Simulated Annealing</a><a id="Algorithm:-Simulated-Annealing-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm:-Simulated-Annealing" title="Permalink"></a></h2><p>Simulated annealing<sup class="footnote-reference"><a id="citeref-Cain2023" href="#footnote-Cain2023">[Cain2023]</a></sup> is a probabilistic optimization algorithm that is used to find the global minimum of an energy function. It is inspired by the process of annealing in metallurgy, where a material is heated and then slowly cooled to increase its strength and reduce its defects. The algorithm starts with a thermal state, where the temperature is high and the system is in a random state. It then gradually cools the system, reducing the temperature and allowing the system to settle into a low-energy state. The algorithm uses a probabilistic acceptance criterion, usually based on the Metropolis-Hastings algorithm, to accept or reject moves that increase the energy of the system. This allows the algorithm to escape local minima and explore the energy landscape more effectively.</p><p>For the spin-glass problem, the energy function is given by</p><p class="math-container">\[E(\sigma) = \sum_{(i,j)\in E} J_{ij} \sigma_i \sigma_j\]</p><p>where <span>$\sigma_i$</span> is the spin at site <span>$i$</span>, <span>$J_{ij}$</span> is the coupling strength between sites <span>$i$</span> and <span>$j$</span>, and the sum is over all pairs of sites that are connected by an edge in the graph. The goal is to find the ground state of the system, which is the configuration of spins that minimizes the energy of the system.</p><p>The simulated annealing algorithm starts with a random initial configuration <span>$\sigma$</span> and a high temperature <span>$T_H$</span>. The temperature is gradually reduced according to a cooling schedule, such as exponential cooling or linear cooling. For each temperature <span>$T$</span>, the algorithm samples a new configuration <span>$\sigma&#39;$</span> by flipping a random spin in the current configuration <span>$\sigma$</span>. The algorithm then calculates the change in energy <span>$\Delta E = E(\sigma&#39;) - E(\sigma)$</span> and accepts the move with probability</p><p class="math-container">\[P(\sigma \to \sigma&#39;) = \exp(-\Delta E / T)\]</p><p>The algorithm repeats this process for a fixed number of steps or until the system reaches thermal equilibrium. The temperature is then reduced according to a cooling schedule, and the process is repeated until the system converges to a low-energy state.</p><h2 id="Hands-on"><a class="docs-heading-anchor" href="#Hands-on">Hands-on</a><a id="Hands-on-1"></a><a class="docs-heading-anchor-permalink" href="#Hands-on" title="Permalink"></a></h2><p>The following demo package contains the code for solving the spin-glass problem using the different approaches: https://github.com/GiggleLiu/ScientificComputingDemos/tree/main/Spinglass</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Moore2011"><a class="tag is-link" href="#citeref-Moore2011">Moore2011</a>Moore, Cristopher, and Stephan Mertens. The nature of computation. OUP Oxford, 2011.</li><li class="footnote" id="footnote-Fomin2013"><a class="tag is-link" href="#citeref-Fomin2013">Fomin2013</a>Fomin, Fedor V., and Petteri Kaski. &quot;Exact exponential algorithms.&quot; Communications of the ACM 56.3 (2013): 80-88.</li><li class="footnote" id="footnote-Liu2021"><a class="tag is-link" href="#citeref-Liu2021">Liu2021</a>Liu, Jin-Guo, Lei Wang, and Pan Zhang. <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.126.090506">Tropical tensor network for ground states of spin glasses.</a> Physical Review Letters 126.9 (2021): 090506.</li><li class="footnote" id="footnote-Liu2023"><a class="tag is-link" href="#citeref-Liu2023">Liu2023</a>Liu, Jin-Guo, et al. <a href="https://epubs.siam.org/doi/abs/10.1137/22M1501787">Computing solution space properties of combinatorial optimization problems via generic tensor networks.</a> SIAM Journal on Scientific Computing 45.3 (2023): A1239-A1270.</li><li class="footnote" id="footnote-Cain2023"><a class="tag is-link" href="#citeref-Cain2023">Cain2023</a>Cain, M., et al. &quot;Quantum speedup for combinatorial optimization with flat energy landscapes (2023).&quot; arXiv preprint arXiv:2306.13123.</li><li class="footnote" id="footnote-Nguyen2023"><a class="tag is-link" href="#citeref-Nguyen2023">Nguyen2023</a>Nguyen, Minh-Thi, et al. &quot;Quantum optimization with arbitrary connectivity using Rydberg atom arrays.&quot; PRX Quantum 4.1 (2023): 010316.</li><li class="footnote" id="footnote-Glover2019"><a class="tag is-link" href="#citeref-Glover2019">Glover2019</a>Glover, Fred, Gary Kochenberger, and Yu Du. &quot;Quantum Bridge Analytics I: a tutorial on formulating and using QUBO models.&quot; 4or 17.4 (2019): 335-371.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ad/">« Automatic Differentiation</a><a class="docs-footer-nextpage" href="../../chap7/montecarlo/">Markov Chain Monte Carlo »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Monday 29 April 2024 03:22">Monday 29 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
