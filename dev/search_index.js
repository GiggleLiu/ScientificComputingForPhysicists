var documenterSearchIndex = {"docs":
[{"location":"chap3/linalg/#Basic-Linear-Algebra","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"","category":"section"},{"location":"chap3/linalg/#Matrix-multiplication","page":"Basic Linear Algebra","title":"Matrix multiplication","text":"","category":"section"},{"location":"chap3/linalg/#Measure-your-device-performance-with-matrix-multiplication","page":"Basic Linear Algebra","title":"Measure your device performance with matrix multiplication","text":"","category":"section"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"The performance of a CPU is measured by the number of floating point operations per second (FLOPS) it can perform. The floating point operations include addition, subtraction, multiplication and division. The FLOPS can be related to multiple factors, such as the clock frequency, the number of cores, the number of instructions per cycle, and the number of floating point units. A simple way to measure the FLOPS is to benchmarking the speed of matrix multiplication.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A, B = rand(1000, 1000), rand(1000, 1000);","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"julia> using BenchmarkTools\n\njulia> @btime $A * $B;\n  12.122 ms (2 allocations: 7.63 MiB)","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"The number of FLOPS in a ntimes ntimes n matrix multiplication is 2n^3. The FLOPS can be calculated as: 2 times 1000^3  (12122 times 10^-3) = 165rm GFLOPS.","category":"page"},{"location":"chap1/git/#Maintainability-Version-Control","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Maintaining a software project is not easy, especially when it comes to multiple developers working on the same piece of code. When adding a new feature to the project, maintainers may encounter the following problems:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Multiple developers modify the same file at the same time, works can not be merged easily.\nNew code breaks an existing feature, downstream users are affected.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"The solution to the above problems is version-control. Among all version control software, git is the most popular one.","category":"page"},{"location":"chap1/git/#Create-a-git-repository","page":"Maintainability - Version Control","title":"Create a git repository","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"A git repository, also known as a repo, is basically a directory where your project lives and git keeps track of your file's history. To get started, you start with a terminal and type","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"cd path/to/working/directory\ngit init\necho \"Hello, World\" > README.md\ngit add -A\ngit commit -m 'this is my initial commit'\ngit status","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: changes the directory to the working directory, which can be either an existing directory or a new directory.\nLine 2: initializes a git repository in the working directory. A .git directory is created in the working directory, which contains all the necessary metadata for the repo.\nLine 3: creates a file README.md with the content Hello, World. The file README.md is a markdown file, which is a lightweight markup language with plain-text-formatting syntax. You can learn more about markdown from the markdown tutorial. This line can be omitted if the working directory already contains files.\nLine 4: line add files to the staging area (area that caches changes that to be committed).\nLine 5: commits the changes to the repository, which will create a snapshot of your current work.\nLine 6: shows the status of the working directory, staging area, and repository. If the above commands are executed correctly, the output should be nothing to commit, working tree clean.","category":"page"},{"location":"chap1/git/#Track-the-changes-checkout,-diff,-log","page":"Maintainability - Version Control","title":"Track the changes - checkout, diff, log","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Git enables developers to track changes in their codebase. Continuing the previous example, we can analyze the repository with the following commands:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"echo \"Bye Bye, World\" > README.md\ngit diff\ngit add -A\ngit commit -m 'a second commit'\ngit log\ngit checkout HEAD~1\ngit checkout main","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: makes changes to the file README.md.\nLine 2: shows the changes made to the file README.md.\nLine 3-4: adds the changes to the staging area and commits the changes to the repository.\nLine 5: shows the history of commits. The output should be something like this:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"commit 02cd535b6d78fca1713784c61eec86e67ce9010c (HEAD -> main)\nAuthor: GiggleLiu <cacate0129@gmail.com>\nDate:   Mon Feb 5 14:34:20 2024 +0800\n\n    a second commit\n\ncommit 570e390759617a7021b0e069a3fbe612841b3e50\nAuthor: GiggleLiu <cacate0129@gmail.com>\nDate:   Mon Feb 5 14:23:41 2024 +0800\n\n    this is my initial commit","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 6: Checkout the previous snapshot. Note HEAD is your current snapshot and HEAD~n is the nth snapshot counting back from the current snapshot.\nLine 7: Return to the main branch, which points to the latest snapshot. We will discuss more about branch later in this tutorial.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"You can use git reset to reset the current HEAD to the specified snapshot, which can be useful when you committed something bad by accident.","category":"page"},{"location":"chap1/git/#Work-on-cloud-remotes","page":"Maintainability - Version Control","title":"Work on cloud - remotes","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"A server to store git repository, or remote in git terminology, is required for the collaboration purpose. Remote repositories can be hosted on git hosting services like GitHub, GitLab, or Bitbucket. After creating a new empty repository (no README files) on a git hosting service (How to create a new github repo?), a URL for cloning the repo will show up, which that usually starts with git or https. Let us denote this URL as <url> and continue the previous example:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git remote add origin <url>\ngit remote -v\ngit push origin main","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: add a remote repository, where origin is a tag for the added remote.\nLine 2: shows the URL of all remotes, including the origin remote we just added.\nLine 3: push commits to the main branch of the remote repository origin. This command sometimes could fail due to another commit pushed to the remote earlier, where the commit may from another machine or another person. To resolve the issue, you can use git pull origin main to fetch the latest snapshot on the remote. git pull may also fail, because the remote commit may be incompatible with the local commit, e.g. the same file has been changed. In this worst case, you need to merge two commits manually (link).","category":"page"},{"location":"chap1/git/#Develop-features-safely-branches","page":"Maintainability - Version Control","title":"Develop features safely - branches","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"So far, we worked with a single branch main. A branch in git is a lightweight pointer to a specific commit. Working on a single branch is dangerous due to the following reasons:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"No usable code. Developers usually develop features based on the current main branch, so the main branch is expected to always usable. However, working on a single branch can easily break this rule.\nHard to resolve conflicts. when multiple developers modify the same file at the same time, works can not be merged easily. Multiple branches can make the feature development process independent of each other, which can avoid conflicts.\nHard to discard a feature. For some experimental features, you may want to discard it after testing. A commit on the main branch can not be easily reverted.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Understanding the branches is extremely useful when, multiple developers are working on different features.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout -b me/feature\necho \"Hello, World - Version 2\" > README.md\ngit add -A\ngit commit -m 'this is my feature'\ngit push origin me/feature","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: create and switch to the new branch me/feature. Here, we use the branch name me/feature to indicate that this branch is for the feature developed by me, which is a matter of convention.\nLine 2-5: makes some changes to the file README.md and commits the changes to the repository. Finally, the changes are pushed to the remote repository origin. The remote branch me/feature is created automatically.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"While developing a feature, you or another developer may want to develop another feature based on the current main branch. You can create another branch other/feature and develop the feature there.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout main\ngit checkout -b other/feature\necho \"Bye Bye, World - Version 2\" > feature.md\ngit add -A\ngit commit -m 'this is another feature'\ngit push origin other/feature","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"In the above example, we created a new branch other/feature based on the main branch, and made some changes to the file feature.md.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Finally, when the feature is ready, you can merge the feature branch to the main branch.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout main\ngit merge me/feature\ngit push origin main","category":"page"},{"location":"chap1/git/#Working-with-others-issues-and-pull-requests","page":"Maintainability - Version Control","title":"Working with others - issues and pull requests","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"When working with others, you may want to propose changes to a repository and discuss them with others. This is where issues and pull requests come in. Issues and pull requests are features of git hosting services like GitHub and GitLab.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Issue is relatively simple, it is a way to report a bug or request a feature.\nPull request (resource: how to create a pull request) is a way to propose changes to a repository and discuss them with others. It is also a way to merge code from source branch to target branch. The source branch can be a branch in the same repository or a branch in a forked repository - a copy of the repository in your account. Forking a repository is needed when you want to propose changes to a repository that you do not have write access to.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"note: Should I make a pull requests or push directly to main branch?\nTo update the main branch, one should use pull requests as much as possible, even if you have write access to the repository. It is a good practice to discuss the changes with others before merging them to the main branch. A pull request also makes the changes more traceable, which is useful when you want to revert the changes.","category":"page"},{"location":"chap1/git/#Git-cheat-sheet","page":"Maintainability - Version Control","title":"Git cheat sheet","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"It is not possible to cover all the feature of git. We will list a few useful commands and resources for git learning.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"# global config\ngit config  # Get and set repository or global options\n\n# initialize a repo\ngit init    # Create an empty Git repo or reinitialize an existing one\ngit clone   # Clone repository into new directory\n\n# info\ngit status  # Show the working tree status\ngit log     # Show commit logs\ngit diff    # Show changes between commits, commit and working tree, etc\n\n# work on a branch\ngit add     # Add file contents to the index\ngit rm      # Remove files from the working tree and from the index\ngit commit  # Record changes to the repository\ngit reset   # Reset current HEAD to the specified state\n\n# branch manipulation\ngit checkout # Switch branches or restore working tree files\ngit branch  # List, create, or delete branches\ngit merge   # Join two or more development histories together\n\n# remote synchronization\ngit remote  # Manage set of tracked repositories\ngit pull  # Fetch from and integrate with another repo or a local branch\ngit fetch   # Download objects and refs from another repository\ngit push    # Update remote refs along with associated objects","category":"page"},{"location":"chap1/git/#Resources","page":"Maintainability - Version Control","title":"Resources","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"The Official GitHub Training Manual\nMIT online course missing semester.","category":"page"},{"location":"chap3/array/#Array-and-Broadcasting","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"","category":"section"},{"location":"chap3/array/#Array-initialization-and-indexing","page":"Array and Broadcasting","title":"Array initialization and indexing","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Initializing an array in Julia is simple. You can initialize an array with different types of elements.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"zero_vector = zeros(3) # zero vector\ndirect_matrix = [5 2 1; 1 4 5; 2 4 9] # explicit\nrand_vector = randn(Float32, 3, 3) # random normal distribution\nstep_vector = collect(1:3)  # collect from a range\nuninitialized_vector = Vector{Int}(undef, 3) # uninitialized vector of size 3","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Julia array is fast. In memory, it is a contiguous block if the element type is bitstype - having a fixed size in memory.\nisbitstype(Int)\nisbitstype(Complex{Float64})   # complex number has a fixed size\nsizeof(Complex{Float64})\nisbitstype(typeof(('a', 2, false)))  # tuple has a fixed size\nsizeof(typeof(('a', 2, false)))\nisbitstype(typeof(randn(3)))   # array does not have a fixed size\nsizeof(typeof(randn(3)))  # an array of array may cause slow indexing.\nJulia array memory layout is column-major. Looping over the first index is faster than looping over the last index.\nfunction mysum_col(A::AbstractMatrix)\n    s = zero(eltype(A)) # zero of the element type of A\n    for j in 1:size(A, 2) # loop over the second index\n        for i in 1:size(A, 1)  # loop over the first index\n            s += A[i, j]\n        end\n    end\n    return s\nend\nfunction mysum_row(A::AbstractMatrix)\n    s = zero(eltype(A)) # zero of the element type of A\n    for i in 1:size(A, 1)  # loop over the first index\n       for j in 1:size(A, 2) # loop over the second index\n            s += A[i, j]\n        end\n    end\n    return s\nend\nFor small scale matrix, their performance is similar since the matrix can be cached well. However, for large scale matrix, the column-major layout is much faster due to the cache locality.\njulia> using BenchmarkTools\n\njulia> A = rand(10000, 10000);\n\njulia> @btime mysum_col($A)\n  85.885 ms (0 allocations: 0 bytes)\n4.999830721534851e7\n\njulia> @btime mysum_row($A)\n  189.794 ms (0 allocations: 0 bytes)\n4.9998307215344414e7\nJulia array indexing starts from 1. It is different from C, Python, and R, which start from 0. 😞\nA = [1, 2, 3]\nA[1]     # the first element\nA[end]   # the last element\nA[1:2]   # the first two elements\nA[2:-1:1] # the first two elements in the reversed order\nB = [1 2 3; 4 5 6; 7 8 9];\nB[1:2]   # the first two elements, returns B[1,1] and B[2,1] since B is column-major\nB[1:2, 1:2] # returns a submatrix","category":"page"},{"location":"chap3/array/#Broadcasting","page":"Array and Broadcasting","title":"Broadcasting","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Julia has a powerful broadcasting mechanism. It is a way to apply a function to each element of an array. The broadcasting is done by adding a dot . before the function name.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"x = 0:0.1:2π\ny = sin.(x) .+ cos.(3 .* x);","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"using Plots; gr(dpi=100)  # for high-quality plots, we suggest using `Makie.jl`\nPlots.plot(x, y; label=\"sin(x) + cos(3x)\")","category":"page"},{"location":"chap3/array/#Loop-fusion","page":"Array and Broadcasting","title":"Loop fusion","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"The broadcasting is very efficient due to loop fusion. In the above example, only one loop is needed to calculate sin and cos for each element of x and only one array is allocated to store the result.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Loop fused:","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"julia> using BenchmarkTools\njulia> @benchmark sin.($x) .+ cos.(3 .* $x);\nBenchmarkTools.Trial: 10000 samples with 107 evaluations.\n Range (min … max):  775.308 ns …  2.984 μs  ┊ GC (min … max): 0.00% … 62.53%\n Time  (median):     781.159 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   798.606 ns ± 78.472 ns  ┊ GC (mean ± σ):  0.28% ±  2.36%\n\n  ▅█▄    ▁ ▃▂ ▃▄▁      ▁                                       ▁\n  ███▆▆▇██▇██▆███▇▆▆▆▆▇██▆▆▅▆▅▅▅▆▅▇▆▅▅▅▄▅▄▅▆▅▅▅▄▄▄▅▅▅▄▄▄▄▃▄▅▅▆ █\n  775 ns        Histogram: log(frequency) by time       995 ns <\n\n Memory estimate: 576 bytes, allocs estimate: 1.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Loop not fused","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"julia> @benchmark sin.($x) + cos.(3 * $x);\nBenchmarkTools.Trial: 10000 samples with 107 evaluations.\n Range (min … max):  778.430 ns …  2.714 μs  ┊ GC (min … max): 0.00% … 66.36%\n Time  (median):     802.570 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   809.210 ns ± 66.113 ns  ┊ GC (mean ± σ):  0.26% ±  2.30%\n\n   ▃        ▅█▇▄        ▂   ▄▄                                 ▂\n  ███▄▁▁▁▃▄█████▇▆▇▇▇█▅███▆███▇▄▅▃▅▇▇▇▆▅▆▅▅▅▅▆▆▅▅▄▅▄▃▄▄▄▃▄▅▄▄▆ █\n  778 ns        Histogram: log(frequency) by time       900 ns <\n\n Memory estimate: 576 bytes, allocs estimate: 1.","category":"page"},{"location":"chap3/array/#When-shapes-do-not-match","page":"Array and Broadcasting","title":"When shapes do not match","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"A = [1 2 3; 4 5 6]\nB = [1 2 3]\nA .+ B   # B is broadcasted to match the size of A","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"B is a (column) vector, which means its shape is (3, 1). The broadcasting is done by repeating the vector to match the shape of A.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"With this trick, we can easily evaluate a function on a meshgrid.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"a = sin.(x) + cos.(3 * x);\nb = cos.(x);\nmesh = a' .* b # a has shape (1, length(x)), b has shape (length(x), 1)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"heatmap(mesh)","category":"page"},{"location":"chap3/array/#Unwanted-broadcasting","page":"Array and Broadcasting","title":"Unwanted broadcasting","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Consider we have a vector, and we want to scale it with factors 1, 2, 3 and store the results in to a vector, i.e. we will get a vector of vectors. The following code will not work as expected.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"[3,2,1,0] .* (1:3)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Note a range is an iterable object. The broadcasting operation works on any iterable object, hence it tries to broadcast over the elements of the vector. A shape mismatch error is raised, which is unwanted.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"In this case, we can use Ref to protect the vector from broadcasting.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Ref([3,2,1,0]) .* (1:3)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"We can see the vector is treated as a whole.","category":"page"},{"location":"chap3/array/#Example:-create-a-meshgrid-for-triangular-lattice","page":"Array and Broadcasting","title":"Example: create a meshgrid for triangular lattice","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"b1 = [1, 0]\nb2 = [0.5, sqrt(3)/2]\nn = 5\nmesh1 = [i * b1 + j * b2 for i in 1:n, j in 1:n]  # list comprehension\nmesh2= (1:n) .* Ref(b1) .+ (1:n)' .* Ref(b2)  # broadcasting","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"scatter(vec(getindex.(mesh2, 1)), vec(getindex.(mesh2, 2)), label=\"mesh2\", ratio=1, markersize=5)","category":"page"},{"location":"chap3/array/#Case-study:-Image-processing","page":"Array and Broadcasting","title":"Case study: Image processing","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Download an image from the internet:","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"url = \"https://avatars.githubusercontent.com/u/8445510?v=4\"\ntarget_path = tempname() * \".png\"\ndownload(url, target_path)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Load the image with Images.jl:","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"using Images\nimg = load(target_path)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Quiz:","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"How to invert the color of the image?","category":"page"},{"location":"chap3/array/#Array-performance-tips","page":"Array and Broadcasting","title":"Array performance tips","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Fix the type of an array","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Arrays with a fixed type are faster than arrays with abstract types. Any type vector is the most flexible, but it is also very slow.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"vany = Any[]  # same as vany = []\ntypeof(vany)\npush!(vany, \"a\")\npush!(vany, 1)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Fixed typed vector is more restrictive.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"vfloat64 = Float64[]\nvfloat64 |> typeof\npush!(vfloat64, \"a\")","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"The performance of the vector with a fixed type is much better than the vector with any type.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"julia> biganyv = collect(Any, 1:2:20000);\n\njulia> @benchmark for i=1:length($biganyv)\n    $biganyv[i] += 1\nend\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  117.833 μs …  1.090 ms  ┊ GC (min … max): 0.00% … 71.28%\n Time  (median):     124.458 μs              ┊ GC (median):    0.00%\n Time  (mean ± σ):   128.512 μs ± 39.121 μs  ┊ GC (mean ± σ):  1.55% ±  4.49%\n\n  ▁   ▃▇█▅▂▂▅▆▄▂▃▄▃▃▄▄▄▃▂▂▂▂▁▁▁▁▁▁                             ▂\n  █▆▄▄█████████████████████████████████▇█▇▇▇█▇▇▇▆▆▄▆▆▆▅▅▅▅▅▅▂▄ █\n  118 μs        Histogram: log(frequency) by time       155 μs <\n\n Memory estimate: 156.25 KiB, allocs estimate: 10000.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"julia> bigfloatv = collect(Float64, 1:2:20000);\n\njulia> @benchmark for i=1:length($bigfloatv)\n    $bigfloatv[i] += 1\nend\nBenchmarkTools.Trial: 10000 samples with 40 evaluations.\n Range (min … max):  908.325 ns …  2.020 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     936.475 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   955.204 ns ± 69.933 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▃   ▇█  ▂▅▁  ▁     ▂                                         ▁\n  █▄▃▃██▇▆███▇▆█▆█▇▄▆█▇▆▆▆█▇▇▆▇▇▇▇▆▅▅▆▆▆▅▅▅▅▃▄▅▄▅▄▄▃▄▄▄▄▄▄▅▅▄▆ █\n  908 ns        Histogram: log(frequency) by time      1.24 μs <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"We can see that the performance of the vector with a fixed type can be 100 times faster than the vector with any type.","category":"page"},{"location":"chap6/compressedsensing/#Compressed-sensing","page":"Compressed sensing","title":"Compressed sensing","text":"","category":"section"},{"location":"chap1/ci/#Correctness-Unit-Tests","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"In terms of scientific computing, accuracy of your result is most certainly more important than anything else. Checking the correctness is definitely one of the most challenging tasks in software development. Consider the following scenario:","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"question: The problem of code review\nSuppose you are one of the maintainers of the Julia programming language. One day, a GitHub user Oscar Smith submitted a 6k-line PR to the JuliaLang/julia repository: (Image: )You want to check if this huge PR did something expected, requiring the following conditions to be satisfied:The build is successfully on Linux, macOS and Windows.\nNo existing feature breaks.\nThe added feature does something expected.What would you do?Checking to the 128 changed files line-by-line with human eye.\nHire a part-time worker, try installing the PR on three fresh machines, and try using as many features as possible and see if anything breaks.\nSomething more efficient.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"In the above scenario, the first option is not reliable for a software project expected to be used by millions of users. The second option is too expensive and time-consuming. Clever software engineers have come up with a more efficient way to check the correctness of the code, which is to use Unit Tests and CI/CD.","category":"page"},{"location":"chap1/ci/#Unit-Test","page":"Correctness - Unit Tests","title":"Unit Test","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"Unit Tests is a software a testing method for the smallest testable unit of an application, e.g. functions. Unit tests are composed of a series of individual test cases, each of which is composed of:","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"a collection of inputs and expected outputs for a function.\nan assertion statement to verify the function returns the expected output for a given input.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"To verify the correctness of the code, we run the unit tests. If the tests pass and the coverage is high, we can be confident that the code is working as expected.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"Tests pass: all assertions in the test cases are true.\nTest coverage: the percentage of the code that is covered by tests, i.e. the higher the coverage, the more robust the code is.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"In Julia, Test is a built-in package for writing and running unit tests. We will learn how to write and run unit tests in the section My First Package.","category":"page"},{"location":"chap1/ci/#Automate-your-workflow-CI/CD","page":"Correctness - Unit Tests","title":"Automate your workflow - CI/CD","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"You still need to set up three clean machines to run the tests. What if you do not have three machines? The key to solving this problem is to automate the workflow on the cloud with the containerization technology, e.g. Docker. You do not need to configure the dockers on the cloud manually. Instead, you can use a Continuous Integration/Continuous Deployment (CI/CD) service to automate the workflow of","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"(CI) build, test and merge the code changes whenever a developer commits code to the repository.\n(CD) deploy the code or documentation to a cloud service and register the package to the package registry.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"CI/CD are often integrated with git hosting services, e.g. Github Actions. A typical CI/CD pipeline include the following steps:","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"code updated detected,\nfor each task, initialize a virtual machine on the cloud,\nthe virtual machine initializes the environment and runs the tests,\nthe virtual machine reports the test results.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"The tasks of CI/CD are often defined in a configuration file, e.g. .github/workflows/ci.yml. We will learn how to set up a CI/CD pipeline in the section My First Package.","category":"page"},{"location":"chap2/julia-release/#My-First-Package","page":"My First Package","title":"My First Package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"One of the most important features of Julia is its package manager. It allows one to create, manage, and publish his own packages. In this section, we will learn how to create a package and publish it to the Julia registry.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Julia package manager can install the correct version of a package and its dependencies because it knows the exact versions of all the packages that are compatible with each other. This information was stored in the General registry - a central GitHub repository of metadata about all registered Julia packages.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Everyone can register a package in the General registry. To do so, you need to:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Create a package.\nSpecify the dependency of your package in the Project.toml file, like which version of a package your package depends on.\nDevelop the package by writing the source code, tests, and documentation.\nOpen-source the package by pushing the package to a public repository on GitHub. GitHub Actions can be used to automate the process of testing, building the documentation, and tagging a release so that other developers can contribute to the package easily.\nRegister the package in the General registry by creating a pull request to the General registry.","category":"page"},{"location":"chap2/julia-release/#Create-a-package","page":"My First Package","title":"Create a package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"We use PkgTemplate. Open a Julia REPL and type the following commands to initialize a new package named MyFirstPackage:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"julia> using PkgTemplates\n\njulia> tpl = Template(;\n    user=\"GiggleLiu\",  # replace!\n    authors=\"GiggleLiu\",  # replace!\n    julia=v\"1.10\",\n    plugins=[\n        License(; name=\"MIT\"),\n        Git(; ssh=true),\n        GitHubActions(; x86=true),\n        Codecov(),\n        Documenter{GitHubActions}(),\n    ],\n)\n\njulia> tpl(\"MyFirstPackage\")","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"where the username \"GiggleLiu\" should be replaced with your GitHub username. Many plugins are used in the above example:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"License: to choose a license for the package. Here we use the MIT license, which is a permissive free software license. Popular licenses include:\nMIT: a permissive free software license, featured with a short and simple permissive license with conditions only requiring preservation of copyright and license notices.\nApache2: a permissive free software license, featured with a contributor license agreement and a patent grant.\nGPL: a copyleft free software license, featured with a strong copyleft license that requires derived works to be available under the same license.\nGit: to initialize a Git repository for the package. Here we use the SSH protocol for Git for convenience. Using two-factor authentication (2FA) can make your GitHub account more secure.\nGitHubActions: to enable continuous integration (CI) with GitHub Actions.\nCodecov: to enable code coverage tracking with Codecov. It is a tool that helps you to measure the test coverage of your code. A package with high test coverage is more reliable.\nDocumenter: to enable documentation building and deployment with Documenter.jl and GitHub pages.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"After running the above commands, a new directory named MyFirstPackage will be created in the folder ~/.julia/dev/ - the default location for Julia packages.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"note: What makes a good package name?\nFor a package that is intended to be registered in the General registry, it is recommended to use a name that follows the Julia package naming guidelines. Although the same registry may not have two packages with the same name, a package use the UUID rather than the name as its unique identifier, because name may not be unique when multiple registries are used together.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The file structure of the package is as follows:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"tree .   \n.\n├── .git\n│   ...\n├── .github\n│   ├── dependabot.yml\n│   └── workflows\n│       ├── CI.yml\n│       ├── CompatHelper.yml\n│       └── TagBot.yml\n├── .gitignore\n├── LICENSE\n├── Manifest.toml\n├── Project.toml\n├── README.md\n├── docs\n│   ├── Manifest.toml\n│   ├── Project.toml\n│   ├── make.jl\n│   └── src\n│       └── index.md\n├── src\n│   └── MyFirstPackage.jl\n└── test\n    └── runtests.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":".git and .gitignore: the files that are used by Git. The .gitingore file contains the files that should be ignored by Git. By default, the .gitignore file contains the following lines:\n*.jl.*.cov\n*.jl.cov\n*.jl.mem\n/Manifest.toml\n/docs/Manifest.toml\n/docs/build/\n.github: the folder that contains the GitHub Actions configuration files.\nLICENSE: the file that contains the license of the package. The MIT license is used in this package.\nREADME.md: the manual that shows up in the GitHub repository of the package, which contains the description of the package.\nProject.toml: the file that contains the metadata of the package, including the name, UUID, version, dependencies and compatibility of the package.\nManifest.toml: the file that contains the exact versions of all the packages that are compatible with each other. It is usually automatically resolved from the Project.toml file, and it is not recommended pushing it to the remote repository.\ndocs: the folder that contains the documentation of the package. It has its own Project.toml and Manifest.toml files, which are used to manage the documentation environment. The make.jl file is used to build the documentation and the src folder contains the source code of the documentation.\nsrc: the folder that contains the source code of the package.\ntest: the folder that contains the test code of the package, which contains the main test file runtests.jl.","category":"page"},{"location":"chap2/julia-release/#Specify-the-dependency","page":"My First Package","title":"Specify the dependency","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The file that contains the metadata of the package, including the name, UUID, version, dependencies and compatibility of the package. To add a new dependency, you can use the following command in the package path:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"$ cd ~/.julia/dev/MyFirstPackage\n\n$ julia --project","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"This will open a Julia REPL in the package environment. To check the package environment, you can type the following commands in the package mode (press ]) of the REPL:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> st\nProject MyFirstPackage v1.0.0-DEV\nStatus `~/.julia/dev/MyFirstPackage/Project.toml` (empty project)","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"After that, you can add a new dependency by typing:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> add LinearAlgebra\n\n(MyFirstPackage) pkg> st\nProject MyFirstPackage v1.0.0-DEV\nStatus `~/jcode/ScientificComputingForPhysicists/lib/MyFirstPackage/Project.toml`\n  [37e2e46d] LinearAlgebra","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The dependency is added correctly if no error is thrown. Press backspace to exit the package mode.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Type ; to enter the shell mode and then type","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"shell> cat Project.toml\nname = \"MyFirstPackage\"\nuuid = \"594718ca-da39-4ff3-a299-6d8961b2aa49\"\nauthors = [\"GiggleLiu\"]\nversion = \"1.0.0-DEV\"\n\n[deps]\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\n\n[compat]\njulia = \"1.10\"\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"You will see that the dependency LinearAlgebra is added to the [deps] section of the Project.toml file.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"We also need to specify which version of LinearAlgebra is compatible with the current package. To do so, you need to edit the [compat] section of the Project.toml file with your favorite editor.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"[compat]\njulia = \"1.10\"\nLinearAlgebra = \"1\"  # added line","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Here, we have used the most widely used dependency version specifier =, which means matching the first nonzero component of the version number. For example:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"1 matches 1.0.0, 1.1.0, 1.1.1, but not 2.0.0.\n0.8 matches 0.8.0, 0.8.1, 0.8.2, but not 0.9.0 or 0.7.0.\n1.2 matches 1.2.0, 1.3.1, but not 1.2.0 or 2.0.0.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The validity of specifying compatibility is based on the consensus among the developers:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"whenever an exported function is changed in a package, the first nonzero component of the version number should be increased.\nversion number starts with 0 is considered as a development version, and it is not stable.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Please check the Julia documentation about package compatibility for advanced usage.","category":"page"},{"location":"chap2/julia-release/#Develop-the-package","page":"My First Package","title":"Develop the package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Developers develop packages in the package environment. The package development process includes:","category":"page"},{"location":"chap2/julia-release/#1.-Edit-the-source-code","page":"My First Package","title":"1. Edit the source code","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The source code of the package is located in the src folder of the package path.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Let us add a simple function to the package. The source code of the package is as follows:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: src/MyFirstPackage.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"module MyFirstPackage\n# import packages\nusing LinearAlgebra\n\n# export interfaces\nexport Lorenz, integrate_step\nexport Point, Point2D, Point3D\nexport RungeKutta, Euclidean\n\n# `include` other source files into this module\ninclude(\"lorenz.jl\")\n\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"We implement the Lorenz system in the lorenz.jl file. The source code of the package is as follows:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: src/lorenz.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"\"\"\"\n    Point{D, T}\n\nA point in D-dimensional space, with coordinates of type T.\n\n# Examples\n```jldoctest\njulia> p1 = Point(1.0, 2.0)\nPoint{2, Float64}((1.0, 2.0))\n\njulia> p2 = Point(3.0, 4.0)\nPoint{2, Float64}((3.0, 4.0))\n\njulia> p1 + p2\nPoint{2, Float64}((4.0, 6.0))\n```\n\"\"\"\n# define a point in D-dimensional space\nstruct Point{D, T <: Real}\n    data::NTuple{D, T}  # a tuple of D elements of type T\nend\nPoint(x::Real...) = Point((x...,))  # `...` is the splat operator\n# define 2D and 3D points\nconst Point2D{T} = Point{2, T}\nconst Point3D{T} = Point{3, T}\n\n# define the dot product of two coordinate vectors\n# `mapreduce` is a high-order function that applies a function to each element \n# of an iterable and then reduces the result to a single value.\nLinearAlgebra.dot(x::Point, y::Point) = mapreduce(*, +, x.data, y.data)\n# implement the operations of the point\n# `Base` is the standard library of Julia\n# `Base.isapprox` is used to define a new method for the function `isapprox` in the `Base` module\n# for arithmetic operations like `*`, `*`, `+`, an extra `:` is required to avoid ambiguity\nBase.:*(x::Real, y::Point) = Point(x .* y.data) # `.` is the broadcast operator\nBase.:/(y::Point, x::Real) = Point(y.data ./ x)\nBase.:+(x::Point, y::Point) = Point(x.data .+ y.data)\nBase.isapprox(x::Point, y::Point; kwargs...) = all(isapprox.(x.data, y.data; kwargs...))\n# `all` returns true if all elements of the iterable are true\n\n# define the index and broadcastable functions\nBase.getindex(p::Point, i::Int) = p.data[i] # for `p[i]` like operations\nBase.broadcastable(p::Point) = p.data # for `x .+ y` like operations\nBase.iterate(p::Point, args...) = iterate(p.data, args...) # for `[p...]` like operations\n\n# the Lorenz system\nstruct Lorenz\n    σ::Float64\n    ρ::Float64\n    β::Float64\nend\n\n# the differential equation of the Lorenz system\nfunction field(p::Lorenz, u)\n    x, y, z = u\n    Point(p.σ*(y-x), x*(p.ρ-z)-y, x*y-p.β*z)\nend\n\n# abstract type for integrators, which allows us to switch between different integration methods\nabstract type AbstractIntegrator end\n# Runge-Kutta 4th order method\n# https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods\nstruct RungeKutta{K} <: AbstractIntegrator end\n# Euclidean method\nstruct Euclidean <: AbstractIntegrator end\n\nfunction integrate_step(f, ::RungeKutta{4}, t, y, Δt)\n    k1 = Δt * f(t, y)\n    k2 = Δt * f(t+Δt/2, y + k1 / 2)\n    k3 = Δt * f(t+Δt/2, y + k2 / 2)\n    k4 = Δt * f(t+Δt, y + k3)\n    return y + k1/6 + k2/3 + k3/3 + k4/6\nend\n\n# Euclidean integration\nfunction integrate_step(f, ::Euclidean, t, y, Δt)\n    return y + Δt * f(t, y)\nend\n\nfunction integrate_step(lz::Lorenz, int::AbstractIntegrator, u, Δt)\n    return integrate_step((t, u) -> field(lz, u), int, zero(Δt), u, Δt)\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"To use this function, you can type the following commands in the package environment:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"julia> using MyFirstPackage\n\njulia> Point(2.0, 3.0)\nPoint2D{Float64}((2.0, 3.0))","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"note: How to enter package environment?\nIn shell: type\n$ cd ~/.julia/dev/MyFirstPackage\n$ julia --project\nIn REPL: press ] to enter the package mode and then type\npkg> activate path/to/package\nto enter the package environment. To deactivate the package environment, type\npkg> activate\nIn VSCode: Click the Julia env: ... button in the bottom of the window and then select the package path.","category":"page"},{"location":"chap2/julia-release/#2.-Write-tests","page":"My First Package","title":"2. Write tests","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"We always need to write tests for the package. The test code of the package is located in the test folder of the package path.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: test/runtests.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"using Test\nusing MyFirstPackage\n\n@testset \"lorenz\" begin\n    include(\"lorenz.jl\")\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: test/lorenz.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"using Test, MyFirstPackage\n\n@testset \"Point\" begin\n    p1 = Point(1.0, 2.0)\n    p2 = Point(3.0, 4.0)\n    @test p1 + p2 ≈ Point(4.0, 6.0)\nend\n\n@testset \"step\" begin\n    lz = Lorenz(10.0, 28.0, 8/3)\n    int = RungeKutta{4}()\n    r1 = integrate_step(lz, int, Point(1.0, 1.0, 1.0), 0.0001)\n    eu = Euclidean()\n    r2 = integrate_step(lz, eu, Point(1.0, 1.0, 1.0), 0.0001)\n    @test isapprox(r1, r2; rtol=1e-5)\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"To run the tests, you can use the following command in the package environment:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> test\n  ... \n  [8e850b90] libblastrampoline_jll v5.8.0+1\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds. 2 already precompiled.\n     Testing Running tests...\nTest Summary: | Pass  Total  Time\nlorenz        |    2      2  0.1s\nTest Summary: | Pass  Total  Time\nfluid         |    1      1  0.1s\n     Testing MyFirstPackage tests passed","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Cheers! All tests passed.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"You might want to write some examples to visualize the results of the package with Makie. We create an examples folder in the package path and then write the following example code","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: examples/lorenz.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"using Makie, GLMakie, MyFirstPackage\nset_theme!(theme_black())\n\n# create a Lorenz system\nlz = Lorenz(10, 28, 8/3)\n\n# initial condition\ny = MyFirstPackage.Point(1.0, 1.0, 1.0)\n \n# `Observable` defines the signal that can be used to update plots efficiently\npoints = Observable(Point3f[])\ncolors = Observable(Int[])\n\n# create a figure\nfig, ax, l = lines(points, color = colors,\n    colormap = :inferno, transparency = true, \n    axis = (; type = Axis3, protrusions = (0, 0, 0, 0), \n              viewmode = :fit, limits = (-30, 30, -30, 30, 0, 50)))\n\nrecord(fig, \"lorenz.mp4\", 1:120) do frame\n    global y\n    for i in 1:50\n        # update arrays inplace\n        y = integrate_step(lz, RungeKutta{4}(), y, 0.01)\n        push!(points[], Point3f(y...))\n        push!(colors[], frame)\n    end\n    ax.azimuth[] = 1.7pi + 0.3 * sin(2pi * frame / 120) # set the view angle of the axis\n    notify(points); notify(colors) # tell points and colors that their value has been updated\n    l.colorrange = (0, frame) # update plot attribute directly\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"It output a video file lorenz.mp4 that visualizes the Lorenz system: (Image: )","category":"page"},{"location":"chap2/julia-release/#3.-Write-documentation","page":"My First Package","title":"3. Write documentation","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The documentation is built with Documenter.jl. The build script is docs/make.jl. To build the documentation, you can first enter the package environment and then type the following commands in a terminal:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"$ cd docs\n$ julia --project","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Instantiate or update the documentation environment if necessary. ","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(docs) pkg> dev ..\n\n(docs) pkg> instantiate # or `up`","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"where dev .. is used to add the MyFirstPackage under development to the documentation environment.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Then build the documentation by typing","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"julia> include(\"make.jl\")","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"where include is a built-in function in Julia that includes the source code of the documentation build file make.jl into the current environment.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The generated HTML files are located in the docs/build folder of the package path. To preview the documentation, just open the index.html file in a web browser.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"note: Live preview of documentation\nFor seamless previewing of documentation on updates, it is highly recommended using the LiveServer.jl package.","category":"page"},{"location":"chap2/julia-release/#Open-source-the-package","page":"My First Package","title":"Open-source the package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"To open-source the package, you need to push the package to a public repository on GitHub.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"First create a GitHub repository with the same name as the package. In this example, the repository name should be MyFirstPackage.jl. To check the remote repository of the package, you can use the following command in the package path:\n$ git remote -v\norigin\tgit@github.com:GiggleLiu/MyFirstPackage.jl.git (fetch)\norigin\tgit@github.com:GiggleLiu/MyFirstPackage.jl.git (push)\nThen push the package to the remote repository:\n$ git add -A\n$ git commit -m \"Initial commit\"\n$ git push\nAfter that, you need to check if all your GitHub Actions are passing. You can check the status of the GitHub Actions from the badge in the README.md file of the package repository. The configuration of GitHub Actions is located in the .github/workflows folder of the package path. Its file structure is as follows:\n.github\n├── dependabot.yml\n└── workflows\n    ├── CI.yml\n    ├── CompatHelper.yml\n    └── TagBot.yml\nThe CI.yml file contains the configuration for the CI of the package, which is used to automate the process of\nTesting the package after a pull request is opened, or the main branch is updated. This process can be automated with the julia-runtest action.\nBuilding the documentation after the main branch is updated. Please check the Documenter documentation for more information.\nThe TagBot.yml file contains the configuration for the TagBot, which is used to automate the process of tagging a release after a pull request is merged.\nThe CompatHelper.yml file contains the configuration for the CompatHelper, which is used to automate the process of updating the [compat] section of the Project.toml file after a pull request is merged.\nConfiguring GitHub Actions is a bit complicated. For beginners, it is a good practise to mimic the configuration of another package, e.g. OMEinsum.jl.","category":"page"},{"location":"chap2/julia-release/#Register-the-package","page":"My First Package","title":"Register the package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Once your package is ready to be published, you need to register the package in the General registry. The General registry is a central GitHub repository of metadata about all registered Julia packages. To register the package, you need to create a pull request to the General registry and wait for the pull request to be reviewed and merged. This process can be automated by the Julia registrator. If the pull request meets all guidelines, your pull request will be merged after a few days. Then, your package is available to the public. ","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"A good practice is to tag a release after the pull request is merged so that your package version update can be reflected in your GitHub repository. This process can be automated by the TagBot.","category":"page"},{"location":"chap2/julia-release/#Case-study:-The-file-structure-of-[OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl)","page":"My First Package","title":"Case study: The file structure of OMEinsum.jl","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(Image: )","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"OMEinsum.jl is a package for tensor contraction. The badges in the README.md file of the package repository are the following:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"build/passing: the tests executed by GitHub Actions are passing.\ncodecov/89%: the code coverage is 89%, meaning that 89% of the code is covered by tests.\ndocs/dev: the documentation is built and deployed with GitHub pages.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Now, let's take a look at the file structure of the package by running the following command in the package path (~/.julia/dev/OMEinsum):","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"$ tree . -L 1 -a\n.\n├── .git\n├── .github\n├── .gitignore\n├── LICENSE\n├── Project.toml\n├── README.md\n├── benchmark\n├── docs\n├── examples\n├── ext\n├── ome-logo.png\n├── src\n└── test","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: Project.toml","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"name = \"OMEinsum\"\nuuid = \"ebe7aa44-baf0-506c-a96f-8464559b3922\"\nauthors = [\"Andreas Peter <andreas.peter.ch@gmail.com>\"]\nversion = \"0.8.1\"\n\n[deps]\nAbstractTrees = \"1520ce14-60c1-5f80-bbc7-55ef81b5835c\"\nBatchedRoutines = \"a9ab73d0-e05c-5df1-8fde-d6a4645b8d8e\"\nChainRulesCore = \"d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4\"\nCombinatorics = \"861a8166-3701-5b0c-9a16-15d98fcdc6aa\"\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\nMacroTools = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\nOMEinsumContractionOrders = \"6f22d1fd-8eed-4bb7-9776-e7d684900715\"\nTupleTools = \"9d95972d-f1c8-5527-a6e0-b4b365fa01f6\"\n\n[weakdeps]\nCUDA = \"052768ef-5323-5732-b1bb-66c8b64840ba\"\n\n[extensions]\nCUDAExt = \"CUDA\"\n\n[compat]\nAbstractTrees = \"0.3, 0.4\"\nBatchedRoutines = \"0.2\"\nCUDA = \"4, 5\"\nChainRulesCore = \"1\"\nCombinatorics = \"1.0\"\nMacroTools = \"0.5\"\nOMEinsumContractionOrders = \"0.8\"\nTupleTools = \"1.2, 1.3\"\njulia = \"1\"\n\n[extras]\nDocumenter = \"e30172f5-a6a5-5a46-863b-614d45cd2de4\"\nDoubleFloats = \"497a8b3b-efae-58df-a0af-a86822472b78\"\nForwardDiff = \"f6369f11-7733-5829-9624-2563aa707210\"\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\nPolynomials = \"f27b6e38-b328-58d1-80ce-0feddd5e7a45\"\nProgressMeter = \"92933f4c-e287-5a05-a399-4b506db050ca\"\nRandom = \"9a3f8284-a2c9-5f02-9a11-845980a1fd5c\"\nSymEngine = \"123dc426-2d89-5057-bbad-38513e3affd8\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\nTropicalNumbers = \"b3a74e9c-7526-4576-a4eb-79c0d4c32334\"\nZygote = \"e88e6eb3-aa80-5325-afca-941959d7151f\"\n\n[targets]\ntest = [\"Test\", \"Documenter\", \"LinearAlgebra\", \"ProgressMeter\", \"SymEngine\", \"Random\", \"Zygote\", \"DoubleFloats\", \"TropicalNumbers\", \"ForwardDiff\", \"Polynomials\", \"CUDA\"]","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"It contains the following more sections:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"[weakdeps] and [extensions]: the sections that specify the extensions of the package, which is related with the files in the ext folder. A package \"extension\" is a module that is automatically loaded when a specified set of other packages (its \"extension dependencies\") are loaded in the current Julia session. As a using case, consider you want to add the CUDA support to your package, but you don't want to force all users to install CUDA package if they don't need it, then adding CUDA as a weak dependency and move this feature ext folder is a good choice. Please check the Julia documentation about package extensions for more information.\n[extras] and [targets]: the section that specifies the extra dependencies of the package that used to test the package. One can also specify the extra dependencies for the test environment in the test folder of the package path.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Quiz: ","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Is ChainRulesCore at version 1.2 compatible with OMEinsum?\nIf ChainRulesCore at version 2.0 is released, what should be done to make OMEinsum compatible with the new version of ChainRulesCore? Which GitHub Action is used to automate this process?\nIf an author of OMEinsum fixed a bug, what should be done to make the new version of OMEinsum available to the public?\nIf an author of OMEinsum changed an exported function, what should be done to make the new version of OMEinsum available to the public?","category":"page"},{"location":"chap1/opensource_scientist/#Becoming-an-Open-Source-Developer","page":"Becoming an Open-Source Developer","title":"Becoming an Open-Source Developer","text":"","category":"section"},{"location":"chap1/opensource_scientist/","page":"Becoming an Open-Source Developer","title":"Becoming an Open-Source Developer","text":"This section focuses on understanding the open source workflow, which is the foundation of scientific computing. Along the way, we will introduce to you our recommended tools for accomplishing each task. ","category":"page"},{"location":"chap2/julia-setup/#Setup-Julia","page":"Setup Julia","title":"Setup Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julia is a high-level, high-performance, dynamic programming language. From the designing stage, Julia is intended to address the needs of high-performance numerical analysis and computational science, without the typical need of separate compilation to be fast, while also being effective for general-purpose programming, web use or as a specification language. Julia is also a free and open-source language, with a large community and a rich ecosystem.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"We will devlve deeper into Julia later in the chapter. For now, we will just install Julia and setup the environment.","category":"page"},{"location":"chap2/julia-setup/#Step-1:-Installing-Julia","page":"Setup Julia","title":"Step 1: Installing Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"For Linux/Mac users, please open a terminal and type the following command to install Julia with juliaup. Juliaup is a tool to manage Julia versions and installations. It allows you to install multiple versions of Julia and switch between them easily.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"curl -fsSL https://install.julialang.org | sh # Linux and macOS","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"For Windows users, please open execute the following command in a cmd,","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"winget install julia -s msstore # Windows","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You can also install Juliaup directly from Windows Store.","category":"page"},{"location":"chap2/julia-setup/#For-users-suffering-from-the-slow-download-speed","page":"Setup Julia","title":"For users suffering from the slow download speed","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Network connectivity can be an issue for some users, especially for those who are in China. You may need to specify another server for installing Juliaup and Julia packages. To do so, execute the following command in your terminal before running the script above.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Linux and macOS","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"export JULIAUP_SERVER=https://mirror.nju.edu.cn/julia-releases/ # Linux & macOS\nexport JULIA_PKG_SERVER=https://mirrors.nju.edu.cn/julia","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Windows","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"$env:JULIAUP_SERVER=\"https://mirror.nju.edu.cn/julia-releases/\" # Windows\n$env:JULIA_PKG_SERVER=\"https://mirrors.nju.edu.cn/julia\"","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"An alternative approach is downloading the corresponding Julia binary from the Nanjing university mirror website. After installing the binary, please set the Julia binary path properly if you want to start a Julia REPL from a terminal, check this manual page to learn more.","category":"page"},{"location":"chap2/julia-setup/#Installing-Julia","page":"Setup Julia","title":"Installing Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To verify that Julia is installed, please open a new terminal and run the following command in your terminal.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"It should start a Julia REPL(Read-Eval-Print-Loop) session like this","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"<!– (Image: REPL Session) –>","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"If you wish to install a specific version of Julia, please refer to the documentation.","category":"page"},{"location":"chap2/julia-setup/#Step-2:-Package-Management","page":"Setup Julia","title":"Step 2: Package Management","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julia has a mature eco-system for scientific computing.\nPkg is the built-in package manager for Julia.\nTo enter the package manager, press ] in the REPL.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"(Image: PackageMangement)","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"The environment is indicated by the (@v1.9).\nTo add a package, type add <package name>.\nTo exit the package manager press backspace key\nRead More","category":"page"},{"location":"chap2/julia-setup/#Step-3.-Configure-the-startup-file","page":"Setup Julia","title":"Step 3. Configure the startup file","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"First create a new file ~/.julia/config/startup.jl by executing the following commands ","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"mkdir -r ~/.julia/config touch ~/.julia/config/startup.jl","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You could open the file with your favourite editor and add the following content","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"try\n    using Revise\ncatch e\n    @warn \"fail to load Revise.\"\nend","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"The contents in the startup file is executed immediately after you open a new Julia session.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Then you need to install Revise, which is an Julia package that can greatly improve the using experience of Julia. To install Revise, open Julia REPL and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia> using Pkg; Pkg.add(\"Revise\")","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"If you don't know about startup.jl and where to find it, here is a good place for further information. ","category":"page"},{"location":"chap2/julia-setup/#More-Packages","page":"Setup Julia","title":"More Packages","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You may find more Julia packages here.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"As a final step, please verify your Julia configuration by openning a Julia REPL and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia> versioninfo()\nJulia Version 1.9.2\nCommit e4ee485e909 (2023-07-05 09:39 UTC)\nPlatform Info:\n  OS: macOS (arm64-apple-darwin22.4.0)\n  CPU: 10 × Apple M2 Pro\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, apple-m1)\n  Threads: 1 on 6 virtual cores\nEnvironment:\n  JULIA_NUM_THREADS = 1\n  JULIA_PROJECT = @.\n  JULIA_PKG_SERVER = http://cn-southeast.pkg.juliacn.com/ ","category":"page"},{"location":"chap2/julia-setup/#Step-4.-Download-an-editor:-VSCode","page":"Setup Julia","title":"Step 4. Download an editor: VSCode","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Install VSCode by downloading the correct binary for your platform from here. Open VSCode and open the Extensions tab on the left side-bar of the window, search Julia and install the most popular extension: julia-vscode","category":"page"},{"location":"chap2/julia-setup/#The-four-modes-of-Julia-REPL","page":"Setup Julia","title":"The four modes of Julia REPL","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"A Julia REPL has four modes,","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julian mode is the default mode that can interpret your Julia code.\nShell mode is the mode that you can run shell commands. Press ; in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"shell> date\nSun Nov  6 10:50:21 PM CST 2022","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the <kbd>Backspace</kbd> key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Package mode is the mode that you can manage packages. Press ] in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"(@v1.8) pkg> st\nStatus `~/.julia/environments/v1.8/Project.toml`\n  [295af30f] Revise v3.4.0","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the <kbd>Backspace</kbd> key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Help mode is the mode that you can access the docstrings of functions. Press ? in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"help> sum\n... docstring for sum ...","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the <kbd>Backspace</kbd> key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"read more...","category":"page"},{"location":"chap3/fft/#Fast-Fourier-transform","page":"Fast Fourier transform","title":"Fast Fourier transform","text":"","category":"section"},{"location":"chap1/terminal/#Get-a-Terminal!","page":"Get a Terminal!","title":"Get a Terminal!","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"You need to get a working terminal to follow the instructions in this book, because every cool guy needs a terminal.","category":"page"},{"location":"chap1/terminal/#Linux-operating-system","page":"Get a Terminal!","title":"Linux operating system","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Using Linux is the most straight-forward way to get a terminal. Just like Windows, IOS, and macOS, Linux is an operating system. In fact, Android, one of the most popular platforms on the planet, is powered by the Linux operating system. It is free to use, open source, widely used on clusters and good at automating your works. Linux kernel and Linux distribution are different concepts.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Linux kernel is started by Linus Torvalds in 1991.\nA Linux distribution is an operating system made from a software collection that includes the Linux kernel and, often, a package management system.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Linux distribution used in this course is Ubuntu.","category":"page"},{"location":"chap1/terminal/#Shell-(or-Terminal)","page":"Get a Terminal!","title":"Shell (or Terminal)","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Although you can use a graphical user interface (GUI) to interact with your Linux distribution, you will find that the command line interface (CLI) is more efficient and powerful. The CLI is also known as the shell or terminal.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The shell is a program that takes commands from the keyboard and gives them to the operating system to perform. Zsh and Bash are two popular shell interpreters used in the Linux operating systems.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Bash is the default shell on most Linux distributions.\nZsh (with oh-my-zsh extension) is an extended version of the shell, with a more powerful command-line editing and completion system. It includes features like spelling correction and tab-completion, and it also supports plugins and themes.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"In Ubuntu, one can use Ctrl + Alt + T to open a shell. In a shell, we use","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"man command_name to get help information related to a command,\nCTRL-C to break a program and\nCTRL-D to exit a shell or an REPL.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The following is a short list of bash commands that will be used frequently in this book.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"man     # an interface to the system reference manuals\n\nls      # list directory contents\ncd      # change directory\nmkdir   # make directories\nrm      # remove files or directories\npwd     # print name of current/working directory\n\necho    # display a line of text\ncat     # concatenate files and print on the standard output\n\nalias   # create an alias for a command\n\nlscpu   # display information about the CPU architecture\nlsmem   # list the ranges of available memory with their online status\n\ntop     # display Linux processes\nssh     # the OpenSSH remote login client\nvim     # Vi IMproved, a programmer's text editor\ngit     # the stupid content tracker\n\ntar     # an archiving utility","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Git Resources","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"MIT Open course: Missing semester\nGet started with the Linux command line and the Shell","category":"page"},{"location":"chap1/terminal/#Editor-in-terminal-Vim","page":"Get a Terminal!","title":"Editor in terminal - Vim","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"To edit files in the terminal, you can use Vim - the default text editor in most Linux distributions. Vim has three primary modes, each tailored for specific tasks. The primary modes include","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Normal Mode, where users can navigate through the file and perform tasks like deleting lines or copying text; One can enter the normal mode by typing ESC;\nInsert Mode, where users can insert text as in conventional text editors; One can enter the insert mode by typing i in the normal mode;\nCommand Mode, where users input commands for tasks like saving files or searching; One can enter the command mode by typing : in the normal mode.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"A few commands are listed below to get you started with Vim.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"i       # input\n:w      # write\n:q      # quit\n:q!     # force quit without saving\n\nu       # undo\nCTRL-R  # redo","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"All the commands must be executed in the normal mode (press ESC if not). To learn more about Vim, please check this lecture.","category":"page"},{"location":"chap1/terminal/#Connect-to-the-remote-SSH","page":"Get a Terminal!","title":"Connect to the remote - SSH","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Secure Shell (SSH) protocol is a method for securely sending commands to a computer over an unsecured network. SSH uses cryptography to authenticate and encrypt connections between devices. It is widely used to:","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"push code to a remote git repository,\nlog into a remote machine and execute commands.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"With a host name (the IP of the target machine to login) and a user name, one can use the following command to login,","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh <username>@<hostname>","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"where <username> is the user's account name and <hostname> is the host name or IP of the target machine. You will get logged in after inputting the password.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Tips to make your life easier","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"It will be tedious to type the host name and user name everytime you want to login to the remote machine. You can setup the ~/.ssh/config file to make your life easier. The following is an example of the ~/.ssh/config file.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Host amat5315\n  HostName <hostname>\n  User <username>","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"where amat5315 is the alias of the host. After setting up the ~/.ssh/config, you can login to the remote machine by typing","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh amat5315","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"If you want to avoid typing the password everytime you login, you can use the command ","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh-keygen","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"to generate a pair of public and private keys, which will be stored in the ~/.ssh folder on the local machine. After setting up the keys, you can copy the public key to the remote machine by typing","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh-copy-id amat5315","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Try connecting to the remote machine again, you will find that you don't need to type the password anymore.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"note: How does an SSH key pair work?\nThe SSH key pair is a pair of asymmetric keys, one is the public key and the other is the private key. In the above example, the public key is uploaded to the remote machine and the private key is stored on the local machine. The public key can be shared with anyone, but the private key must be kept secret.To connect to a server, the server needs to know that you are the one who with the right to access it. To do so, the server will need to check if you have the private key that corresponds to the public key stored on the server. If you have the private key, you will be granted access to the server.The secret of the SSH key pair is that the public key can be used to encrypt a message that can only be decrypted by the private key, i.e. the public key is more like a lock and the private key is the key to unlock the lock. This is the foundation of the SSH protocol. So server can send you a message encrypted by your public key, and only you can decrypt it with your private key. This is how the server knows that you are the one who has the private key without actually sending the private key to the server.","category":"page"},{"location":"chap3/tensors/#Tensor-Operations","page":"Tensor Operations","title":"Tensor Operations","text":"","category":"section"},{"location":"chap3/tensors/#Einsum","page":"Tensor Operations","title":"Einsum","text":"","category":"section"},{"location":"chap3/tensors/#Optimized-tensor-contractions","page":"Tensor Operations","title":"Optimized tensor contractions","text":"","category":"section"},{"location":"chap3/tensors/#Bayesian-inference","page":"Tensor Operations","title":"Bayesian inference","text":"","category":"section"},{"location":"chap2/julia-performance/#Performance-and-Profile","page":"Performance and Profile","title":"Performance and Profile","text":"","category":"section"},{"location":"chap2/julia-performance/#Profiling","page":"Performance and Profile","title":"Profiling","text":"","category":"section"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"Profiling is a way to measure the performance of your code. It can help you to identify the bottleneck of your code and optimize it. The Profile module in Julia provides a set of tools to profile your code.","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"Consider we have two random matrices A and B, and we want to measure the performance of the matrix multiplication A * B.","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"We can start the profiler by","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"using Profile\nProfile.init(n = 10^7, delay = 0.001) # set the number of samples and the delay between samples","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"Then you can profile your code by running it.","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"A, B = rand(1000, 1000), rand(1000, 1000);\nA * B;  # the first run contains the compilation time\n@profile A * B;","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"To view the profile result, you can use the Profile.print() function.","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"Profile.print(; C=true, mincount=3)","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"The majority of the time is spent in the GEMM function of the BLAS library, which is a highly optimized library for matrix multiplication. The performance of the matrix multiplication is close to the theoretical peak performance of the CPU.","category":"page"},{"location":"chap2/julia-performance/#Example:-Optimizing-the-performance-of-Lorenz-attractor","page":"Performance and Profile","title":"Example: Optimizing the performance of Lorenz attractor","text":"","category":"section"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"Consider we have a simple implementation of the Lorenz attractor using the Runge-Kutta method. The code is as follows:","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"# Point in 3D space\nstruct P3{T}\n    x::T\n    y::T\n    z::T\nend\n\n# Overload the zero function\nBase.zero(::Type{P3{T}}) where T = P3(zero(T), zero(T), zero(T))\nBase.zero(::P3{T}) where T = P3(zero(T), zero(T), zero(T))\n\n\n# Overload the addition, subtraction, division and multiplication\n@inline function Base.:(+)(a::P3, b::P3)\n    P3(a.x + b.x, a.y + b.y, a.z + b.z)\nend\n\n@inline function Base.:(/)(a::P3, b::Real)\n    P3(a.x/b, a.y/b, a.z/b)\nend\n\n@inline function Base.:(*)(a::Real, b::P3)\n    P3(a*b.x, a*b.y, a*b.z)\nend\n\n\n# define the Lorenz attractor\nfunction lorenz(t, y)\n    P3(10*(y.y-y.x), y.x*(27-y.z)-y.y, y.x*y.y-8/3*y.z)\nend\n\n# define the single step update for the Runge-Kutta method of order 4\n# f: the function to be integrated\n# t: the current time\n# y: the current value\n# Δt: the current time step\nfunction rk4_step(f, t, y, Δt)\n    k1 = Δt * f(t, y)\n    k2 = Δt * f(t+Δt/2, y + k1 / 2)\n    k3 = Δt * f(t+Δt/2, y + k2 / 2)\n    k4 = Δt * f(t+Δt, y + k3)\n    return y + k1/6 + k2/3 + k3/3 + k4/6\nend\n\n# define the Runge-Kutta method of order 4\n# f: the function to be integrated\n# y0: the initial value\n# t0: the initial time\n# Δt: the time step\n# Nt: the number of steps\nfunction rk4(f, y0; t0, Δt, Nt, history=nothing)\n    y = y0\n    for i=1:Nt\n        y = rk4_step(f, t0+(i-1)*Δt, y, Δt)\n        # record the history\n        record!(history, y)\n    end\n    return y\nend\n\n# record the history: if history is a vector, push the value to the vector\nrecord!(v::AbstractVector, y) = push!(v, y)\nrecord!(::Nothing, y) = nothing\nnothing # hide","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"If we run the code, we can see the Lorenz attractor.","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"y = P3(1.0, 0.0, 0.0)\nhistory = [y]\nrk4(lorenz, y; t0=0.0, Δt=0.001, Nt=100000, history)\n\nusing Plots; gr(dpi=100)\nplot([h.x for h in history], [h.y for h in history], [h.z for h in history], legend=false)","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"The performance of the code ","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"julia> @benchmark rk4(lorenz, P3(1.0, 0.0, 0.0); t0=0.0, Δt=0.001, Nt=100000, history=[])\nBenchmarkTools.Trial: 1479 samples with 1 evaluation.\n Range (min … max):  3.167 ms …   7.822 ms  ┊ GC (min … max): 0.00% … 56.98%\n Time  (median):     3.263 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   3.381 ms ± 321.910 μs  ┊ GC (mean ± σ):  3.06% ±  6.93%\n\n  ▂▃▅█▇▅▄▃▃▁▁▂▂▁                              ▁▂▂▁             \n  ██████████████▇▅▄▄▅▁▄▄▁▁▄▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▅▇▆▆████▇▇▆▅▆▅▄▅▅▅▄ █\n  3.17 ms      Histogram: log(frequency) by time      4.43 ms <\n\n Memory estimate: 4.88 MiB, allocs estimate: 100011.","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"It is reasonable to suspect that the performance bottleneck is the record! function, because the history is a vector of element type Any. In order to verify our intuition, we can profile the code to see the performance bottleneck.","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"Profile.clear()   # clear the previous profile result\n@profile rk4(lorenz, P3(1.0, 0.0, 0.0); t0=0.0, Δt=0.001, Nt=5000000, history=[]) # record the profile\nProfile.print(format=:flat, mincount=5)  # show the profile result, only show the functions that are called more than 5 times","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"The print also supports other formats, such as :tree.","category":"page"},{"location":"chap2/julia-performance/","page":"Performance and Profile","title":"Performance and Profile","text":"In this example, we can see that the record! function has only a few counts, each count stands for 10^-3s. So the record! function is not the performance bottleneck. The performance bottleneck is the rk4 function.","category":"page"},{"location":"chap2/julia-type/#Types-and-Multiple-dispatch","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"","category":"section"},{"location":"chap2/julia-type/#Julia-Types","page":"Types and Multiple-dispatch","title":"Julia Types","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Julia has rich type system, which is not limited to the primitive types that supported by the hardware. The type system is the key to the multiple dispatch feature of Julia.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"As an example, let us consider the type for complex numbers.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Complex{Float64}","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where Float64 is the type parameter of Complex. Type parameters are a part of a type, without which the type is not fully specified. A fully specified type is called a concrete type, which has a fixed memory layout and can be instantiated in memory. For example, the Complex{Float64} consists of two fields of type Float64, which are the real and imaginary parts of the complex number.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fieldnames(Complex{Float64})\nfieldtypes(Complex{Float64})","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Extending the example, we can define the type for a matrix of complex numbers.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Array{Complex{Float64}, 2}","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Array type has two type parameters, the first one is the element type and the second one is the dimension of the array.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"One can get the type of value with typeof function.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"typeof(1+2im)\ntypeof(randn(Complex{Float64}, 2, 2))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Then, what the type of a type?","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"typeof(Complex{Float64})","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There is a very special type: Tuple, which is different from regular types in the following ways:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Tuple types may have any number of parameters.\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore Tuple{Any} is considered an abstract type, and tuple types are only concrete if their parameters are.\nTuples do not have field names; fields are only accessed by index.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"tp = (1, 2.0, 'c')\ntypeof(tp)\ntp[2]","category":"page"},{"location":"chap2/julia-type/#Multiple-dispatch","page":"Types and Multiple-dispatch","title":"Multiple dispatch","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch is a feature of some programming languages in which a function or method can be dynamically dispatched based on the run-time type. The dispatch is the process of selecting the method to invoke based on the type of the arguments.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We first define of an abstract type AbstractAnimal with the keyword abstract type:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"abstract type AbstractAnimal{L} end","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where the type parameter L stands for the number of legs. Defining the number of legs as a type parameter or a field of a concrete type is a design choice. Providing more information in the type system can help the compiler to optimize the code, but it can also make the compiler generate more code.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Abstract types can have subtypes. In the following we define a concrete subtype type Dog with 4 legs, which is a subtype of AbstractAnimal{4}.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Dog <: AbstractAnimal{4}\n\tcolor::String\nend","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where <: is the symbol for sybtyping， A <: B means A is a subtype of B. Concrete types can have fields, which are the data members of the type. However, they can not have subtypes.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Similarly, we define a Cat with 4 legs, a Cock with 2 legs and a Human with 2 legs.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Cat <: AbstractAnimal{4}\n\tcolor::String\nend\n\nstruct Cock <: AbstractAnimal{2}\n\tgender::Bool\nend\n\nstruct Human{FT <: Real} <: AbstractAnimal{2}\n\theight::FT\n\tfunction Human(height::T) where T <: Real\n\t\tif height <= 0 || height > 300\n\t\t\terror(\"The tall of a Human being must be in range 0~300, got $(height)\")\n\t\tend\n\t\treturn new{T}(height)\n\tend\nend","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Here, the Human type has its own constructor. The new function is the default constructor.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define a fall back method fight on the abstract type AbstractAnimal","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(a::AbstractAnimal, b::AbstractAnimal) = \"draw\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where :: is a type assertion. This function will be invoked if two subtypes of AbstractAnimal are fed into the function fight and no more explicit methods are defined.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define many more explicit methods with the same name.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(dog::Dog, cat::Cat) = \"win\"\nfight(hum::Human, a::AbstractAnimal) = \"win\"\nfight(hum::Human, a::Union{Dog, Cat}) = \"loss\"\nfight(hum::AbstractAnimal, a::Human) = \"loss\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where Union{Dog, Cat} is a union type. It is a type that can be either Dog or Cat. Union types are not concrete since they do not have a fixed memory layout, meanwhile, they can not be subtyped! Here, we defined 5 methods for the function fight. However, defining too many methods for the same function can be dangerous. You need to be careful about the ambiguity error!","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(Human(170), Human(180))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"It makes sense because we claim Human wins any other animals, but we also claim any animal losses to Human. When it comes to two Humans, the two functions are equally valid. To resolve the ambiguity, we can define a new method for the function fight as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(hum::Human{T}, hum2::Human{T}) where T<:Real = hum.height > hum2.height ? \"win\" : \"loss\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Now, we can test the function fight with different combinations of animals.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(Cock(true), Cat(\"red\"))\nfight(Dog(\"blue\"), Cat(\"white\"))\nfight(Human(180), Cat(\"white\"))\nfight(Human(170), Human(180))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Quiz: How many method instances are generated for fight so far?","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> methodinstances(fight)","category":"page"},{"location":"chap2/julia-type/#Example:-Julia-number-system","page":"Types and Multiple-dispatch","title":"Example: Julia number system","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The Julia type system is a tree, and Any is the root of type tree, i.e. it is a super type of any other type. The Number type is the root type of Julia number system, which is also a subtype of Any.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Number <: Any","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The type tree rooted on Number looks like:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Number\n├─ Base.MultiplicativeInverses.MultiplicativeInverse{T}\n│  ├─ Base.MultiplicativeInverses.SignedMultiplicativeInverse{T<:Signed}\n│  └─ Base.MultiplicativeInverses.UnsignedMultiplicativeInverse{T<:Unsigned}\n├─ Complex{T<:Real}\n├─ Real\n│  ├─ AbstractFloat\n│  │  ├─ BigFloat\n│  │  ├─ Float16\n│  │  ├─ Float32\n│  │  └─ Float64\n│  ├─ AbstractIrrational\n...","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There are utilities to analyze the type tree:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"using InteractiveUtils # hide\nsubtypes(Number)\nsupertype(Float64)\nAbstractFloat <: Real","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The leaf nodes of the type tree are called concrete types. They are the types that can be instantiated in memory. Among the concrete types, there are primitive types and composite types. Primitive types are built into the language, such as Int64, Float64, Bool, and Char, while composite types are built on top of primitive types, such as Dict, Complex and the user-defined types.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The list of primitive types","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end","category":"page"},{"location":"chap2/julia-type/#Extending-the-number-system-a-comparison-with-object-oriented-programming","page":"Types and Multiple-dispatch","title":"Extending the number system - a comparison with object-oriented programming","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Extending the number system in Julia is much easier than in object-oriented languages like Python. In the following example, we show how to implement addition operation of a user defined class in Python (feel free to skip if you do not know Python).","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class X:\n  def __init__(self, num):\n    self.num = num\n\n  def __add__(self, other_obj):\n    return X(self.num+other_obj.num)\n\n  def __radd__(self, other_obj):\n    return X(other_obj.num + self.num)\n\n  def __str__(self):\n    return \"X = \" + str(self.num)\n\nclass Y:\n  def __init__(self, num):\n    self.num = num\n\n  def __radd__(self, other_obj):\n    return Y(self.num+other_obj.num)\n\n  def __str__(self):\n    return \"Y = \" + str(self.num)\n\nprint(X(3) + Y(5))\n\nprint(Y(3) + X(5))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Here, we implemented the addition operation of two classes X and Y. The __add__ method is called when the + operator is used with the object on the left-hand side, while the __radd__ method is called when the object is on the right-hand side. The output is as follows:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"X = 8\nX = 8","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"It turns out the __radd__ method of Y is not called at all. This is because the __radd__ method is only called when the object on the left-hand side does not have the __add__ method by some artifical rules.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Implement addition in Julian style is much easier. We can define the addition operation of two types X and Y as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct X{T} <: Number\n\tnum::T\nend\n\nstruct Y{T} <: Number\n\tnum::T\nend\n\nBase.:(+)(a::X, b::Y) = X(a.num + b.num);\n\nBase.:(+)(a::Y, b::X) = X(a.num + b.num);\n\nBase.:(+)(a::X, b::X) = X(a.num + b.num);\n\nBase.:(+)(a::Y, b::Y) = Y(a.num + b.num);","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch seems to be more expressive than object-oriented programming.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Now, supposed you want to extend this method to a new type Z. In python, he needs to define a new class Z as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class Z:\n  def __init__(self, num):\n    self.num = num\n\n  def __add__(self, other_obj):\n    return Z(self.num+other_obj.num)\n\n  def __radd__(self, other_obj):\n    return Z(other_obj.num + self.num)\n\n  def __str__(self):\n    return \"Z = \" + str(self.num)\n\nprint(X(3) + Z(5))\n\nprint(Z(3) + X(5))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The output is as follows:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"X = 8\nZ = 8","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"No matter how hard you try, you can not make the __add__ method of Z to be called when the object is on the left-hand side. In Julia, this is not a problem at all. We can define the addition operation of Z as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Z{T} <: Number\n    num::T\nend\nBase.:(+)(a::X, b::Z) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::X) = Z(a.num + b.num);\nBase.:(+)(a::Y, b::Z) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::Y) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::Z) = Z(a.num + b.num);\nX(3) + Y(5)\nY(3) + X(5)\nX(3) + Z(5)\nZ(3) + Y(5)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There is a deeper reason why multiple dispatch is more expressive than object-oriented programming. The Julia function space is exponentially large! If a function f has k parameters, and the module has t types, there can be t^k methods for the function f:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"f(x::T1, y::T2, z::T3...)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Exponential function space allows us to specify the behavior of a function in a very fine-grained way. However, in an object-oriented language like Python, the function space is only linear to the number of classes.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class T1:\n    def f(self, y, z, ...):\n        self.num = num\n","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The behavior of method f is completely determined by the first argument self, which means object-oriented programming is equivalent to single dispatch.","category":"page"},{"location":"chap2/julia-type/#Example:-Computing-Fibonacci-number-at-compile-time","page":"Types and Multiple-dispatch","title":"Example: Computing Fibonacci number at compile time","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The Fibonacci number has a recursive definition:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"using BenchmarkTools\nfib(x::Int) = x <= 2 ? 1 : fib(x-1) + fib(x-2)\naddup(x::Int, y::Int) = x + y","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> @btime fib(40)\n  278.066 ms (0 allocations: 0 bytes)\n102334155","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Oops, it is really slow. There is definitely a better way to calculate the Fibonacci number, but let us stick to this recursive implementation for now.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"If you know the Julia type system, you can implement the Fibonacci number in a zero cost way. The trick is to use the type system to calculate the Fibonacci number at compile time. There is a type Val defined in the Base module, which is just a type with a type parameter. The type parameter can be a number:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Val(3.0)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define the addition operation of Val as the addition of the type parameters.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"addup(::Val{x}, ::Val{y}) where {x, y} = Val(x + y)\naddup(Val(5), Val(7))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Finally, we can define the Fibonacci number in a zero cost way.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fib(::Val{x}) where x = x <= 2 ? Val(1) : addup(fib(Val(x-1)), fib(Val(x-2)))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> @btime fib(Val(40))\n  0.792 ns (0 allocations: 0 bytes)\nVal{102334155}()","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Wow, it computes in no time! However, this trick is not recommended in the Julia performance tips. This implementation simply transfers the run-time computation to the compile time. On the other hand, we find the compiling time of the function fib is much shorter than the run-time. The recursive form turns out to be optimized away by the Julia compiler. But still, it is not recommended to abuse the type system.","category":"page"},{"location":"chap2/julia-type/#Summary","page":"Types and Multiple-dispatch","title":"Summary","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch is a feature of some programming languages in which a function or method can be dynamically dispatched based on the run-time type.\nJulia's multiple dispatch provides exponential large function space, which allows extending the number system easily.","category":"page"},{"location":"chap6/sparse/#Sparse-Matrices","page":"Sparse Matrices","title":"Sparse Matrices","text":"","category":"section"},{"location":"chap6/sparse/#Data-structure","page":"Sparse Matrices","title":"Data structure","text":"","category":"section"},{"location":"chap6/sparse/#Dominating-eigenvalue-problem","page":"Sparse Matrices","title":"Dominating eigenvalue problem","text":"","category":"section"},{"location":"chap7/hpc/#MPI-and-OpenMP","page":"MPI and OpenMP","title":"MPI and OpenMP","text":"","category":"section"},{"location":"chap4/ad/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"chap2/julia-why/#Why-Julia?","page":"Why Julia?","title":"Why Julia?","text":"","category":"section"},{"location":"chap2/julia-why/#What-is-Julia-programming-language?","page":"Why Julia?","title":"What is Julia programming language?","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Julia is a modern, open-source, high performance programming language for technical computing. It was born in 2012 in MIT, now is maintained by JuliaHub Inc. located in Boston, US.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike MatLab, Julia is open-source. Julia source code is maintained on GitHub repo JuliaLang/julia, and it open-source LICENSE is MIT. Julia packages can be found on JuliaHub, most of them are open-source.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike Python, Julia is designed for high performance (arXiv:1209.5145). It is a dynamic programming language, but it is as fast as C/C++. The following figure shows the computing time of multiple programming languages normalized to C/C++.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"/assets/images/benchmark.png\" alt=\"image\" width=\"600\" height=\"auto\">","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike C/C++ and Fortran, Julia is easy to use and is becoming a trend in scientific computing. Julia uses the just-int-time (JIT) technique to achieve high performance, which does not have the problem of platform dependency. Many famous scientists and engineers have switched to Julia from other programming languages.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Steven G. Johnson, creater of FFTW, switched from C++ to Julia years ago.\nAnders Sandvik, creater of Stochastic Series Expansion (SSE) quantum Monte Carlo method, switched from Fortran to Julia recently.\nCourse link: Computational Physics\nMiles Stoudenmire, creater of ITensor, switched from C++ to Julia years ago.\nJutho Haegeman, Chris Rackauckas and more.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"note: Should I switch to Julia?\nBefore switching to Julia, please make sure:the problem you are trying to solve runs more than 10min.\nyou are not satisfied by any existing tools.","category":"page"},{"location":"chap2/julia-why/#My-first-program:-Factorial","page":"Why Julia?","title":"My first program: Factorial","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Before we start, please make sure you have the needed packages installed. Type ] in the Julia REPL to enter the package manager, and then type","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"pkg> add BenchmarkTools, MethodAnalysis","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Go back to the REPL by pressing Backspace.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> function jlfactorial(n)\n           x = 1\n           for i in 1:n\n               x = x * i\n           end\n           return x\n       end\njlfactorial (generic function with 1 method)","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To make sure the performance is measured correctly, we use the @btime macro in the BenchmarkTools package to measure the performance of the function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @btime jlfactorial(x) setup=(x=5)\n2.208 ns (0 allocations: 0 bytes)\n120","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"CPU clock cycle is ~0.3ns, so it takes only a few clock cycles to compute the factorial of 5. Julia is really fast!","category":"page"},{"location":"chap2/julia-why/#Compare-with-the-speed-of-C-program","page":"Why Julia?","title":"Compare with the speed of C program","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To measure the performance of the C program, we can utilize the benchmark utilities in Julia. Benchmarking C program with Julia is accurate because Julia has perfect interoperability with C, which allows zero-cost calling of C functions.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In the following example, we first write a C program to calculate the factorial of a number. The file is named demo.c, and the content is as follows:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"$ cat demo.c\n#include <stddef.h>\nint c_factorial(size_t n) {\n\tint s = 1;\n\tfor (size_t i=1; i<=n; i++) {\n\t\ts *= i;\n\t}\n\treturn s;\n}","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To execute a C program in Julia, one needs to compile it to a shared library.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"$ gcc demo.c -fPIC -O3 -shared -o demo.so","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To call the function in Julia, one can use the @ccall macro in the Libdl package (learn more). Please open a Julia REPL and execute the following code:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using Libdl\n\njulia> c_factorial(x) = Libdl.@ccall \"./demo.so\".c_factorial(x::Csize_t)::Int","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The benchmark result is as follows:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using BenchmarkTools\n\njulia> @benchmark c_factorial(5)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  7.333 ns … 47.375 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     7.458 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   7.764 ns ±  1.620 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ██▅  ▃▁ ▂▂                         ▁▁▁                     ▂\n  ███▆▄██▆███▅▅▆▆▆▅▆▅▄▅▆▅▅▇▆▆▄▅▅▇█▇▆▆█████▅▃▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▃ █\n  7.33 ns      Histogram: log(frequency) by time     12.6 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Although the C program requires the type of variables to be manually declared, its performance is very good. The computing time is only 7.33 ns.","category":"page"},{"location":"chap2/julia-why/#Compare-with-the-speed-of-Python-program","page":"Why Julia?","title":"Compare with the speed of Python program","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"We use the timeit module in ipython to measure the performance of the Python program.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In [5]: def factorial(n):\n...:        x = 1\n...:        for i in range(1, n+1):\n...:            x = x * i\n...:        return x\n...:\n\nIn [6]: factorial(5)\nOut[6]: 120\n\nIn [7]: timeit factorial(5)\n144 ns ± 0.379 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\nIn [8]: factorial(100)\nOut[8]: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"One can also use the PyCall package to call the Python function in Julia.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The computing time of the Python program is 144 ns, which is 20 times slower than the C program and 70 times slower than the Julia program. On the other hand, the python program is more flexible since its integer type is not limited by the machine word size.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> typemax(Int)\n9223372036854775807\n\njulia> jlfactorial(100)\n0","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The reason why python is slow and flexible are the same. In python the type of a variable is not declared when it is defined, and it can be changed at any time. This is why the integer type becomes an arbitrary precision integer type when the number is too large. If a variable does not have a fixed type, the program can not preallocate memory for it due to the lack of size information. Then a dynamic typed language has to use a tuple (type, *data) to represent an object, where type is the type of the object and *data is the pointer to the data. Pointing to a random memory location is slow, because it violates the principle of data locality. Lacking of data locality causes the frequent cache miss - failure to find the data in the L1, L2, or L3 cache. Loading data from the main memory is slow, because of the long latency of reading the main memory.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"/assets/images/data.png\" alt=\"image\" width=\"300\" height=\"auto\">","category":"page"},{"location":"chap2/julia-why/#Combining-Python-and-C/C?","page":"Why Julia?","title":"Combining Python and C/C++?","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"From the maintainer's perspective, it is hard to maintain a program written in both Python and C/C++:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"It makes the build configuration files complicated.\nLearning two programming languages is hard for new contributors.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Using python as glue is not as powerful as it looks, the following problem can not be solved by this approach:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Monte Carlo simulation.\nBranching and bound algorithms.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"/assets/images/pythonc.png\" alt=\"image\" width=\"400\" height=\"auto\"/>","category":"page"},{"location":"chap2/julia-why/#Key-ingredients-of-Julia's-performance:-Just-in-time-(JIT)-compilation","page":"Why Julia?","title":"Key ingredients of Julia's performance: Just in time (JIT) compilation","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"JIT compilation: compile the method to a method instance when a method is called for the first time;\nMultiple dispatch: invoke the correct method instance according to the type of multiple arguments;","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"(Image: )","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Given a user defined Julia function, the Julia compiler will generate a binary for it at the first called. This binary is called a method instance, and it is generated based on the input types of the function. The method instance is then stored in the method table, and it will be called when the function is called with the same input types. The method instance is generated by the LLVM compiler, and it is optimized for the input types. The method instance is a binary, and it is as fast as a C/C++ program.","category":"page"},{"location":"chap2/julia-why/#Step-1:-Infer-the-types","page":"Why Julia?","title":"Step 1: Infer the types","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Knowing the types of the variables is key to generate a fast binary. Given the input types, the Julia compiler can infer the types of the variables in the function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"If all the types are inferred, the function is called type stable. One can use the @code_warntype macro to check if the function is type stable. For example, the jlfactorial function with integer input is type stable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_warntype jlfactorial(10)\nMethodInstance for jlfactorial(::Int64)\n  from jlfactorial(n) @ Main REPL[4]:1\nArguments\n  #self#::Core.Const(jlfactorial)\n  n::Int64\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  x::Int64\n  i::Int64\nBody::Int64\n1 ─       (x = 1)\n│   %2  = (1:n)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│         (x = x * i)\n│         (@_3 = Base.iterate(%2, %9))\n│   %12 = (@_3 === nothing)::Bool\n│   %13 = Base.not_int(%12)::Bool\n└──       goto #4 if not %13\n3 ─       goto #2\n4 ┄       return x","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"If the types are not inferred, the function is called type unstable. For example, the badcode function is type unstable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> badcode(x) = x > 3 ? 1.0 : 3\n\njulia> @code_warntype badcode(4)\nMethodInstance for badcode(::Int64)\n  from badcode(x) @ Main REPL[9]:1\nArguments\n  #self#::Core.Const(badcode)\n  x::Int64\nBody::Union{Float64, Int64}\n1 ─ %1 = (x > 3)::Bool\n└──      goto #3 if not %1\n2 ─      return 1.0\n3 ─      return 3","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In this example, the output type Union{Float64, Int64} means the return type is either Float64 or Int64. The function is type unstable because the return type is not fixed. Type unstable code is slow. In the following example, the badcode function is ~10 times slower than its type stable version stable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> x = rand(1:10, 1000);\n\njulia> @benchmark badcode.($x)\nBenchmarkTools.Trial: 10000 samples with 8 evaluations.\n Range (min … max):  2.927 μs … 195.198 μs  ┊ GC (min … max):  0.00% … 96.52%\n Time  (median):     3.698 μs               ┊ GC (median):     0.00%\n Time  (mean ± σ):   4.257 μs ±   7.894 μs  ┊ GC (mean ± σ):  12.43% ±  6.54%\n\n                 ▁▅█▅▃▂                                        \n  ▁▃▅▇▇▇▅▃▂▂▂▃▄▆▇███████▇▇▅▄▄▃▃▃▃▃▃▂▂▃▂▂▂▂▁▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃\n  2.93 μs         Histogram: frequency by time        5.44 μs <\n\n Memory estimate: 26.72 KiB, allocs estimate: 696.\n\njulia> stable(x) = x > 3 ? 1.0 : 3.0\nstable (generic function with 1 method)\n\njulia> @benchmark stable.($x)\nBenchmarkTools.Trial: 10000 samples with 334 evaluations.\n Range (min … max):  213.820 ns … 25.350 μs  ┊ GC (min … max):  0.00% … 98.02%\n Time  (median):     662.551 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   947.978 ns ±  1.187 μs  ┊ GC (mean ± σ):  29.30% ± 21.05%\n\n  ▂▃▅██▇▅▄▃▂▁                                                  ▂\n  ████████████▇▅▅▄▄▁▁▁▁▁▁▁▁▁▁▁▁▁▃▅▆▇██████▇▇▇▆█▇▇▇▇▇▇▇▇▆▇▆▆▆▇▇ █\n  214 ns        Histogram: log(frequency) by time      6.32 μs <\n\n Memory estimate: 7.94 KiB, allocs estimate: 1.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In the above example:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"\".\" is the broadcasting operator, it applies the function to each element of the array.\n\"$\" is the interpolation operator, it is used to interpolate a variable into an expression. In a benchmark, it can be used to avoid the overhead of variable initialization.","category":"page"},{"location":"chap2/julia-why/#Step-2:-Generates-the-LLVM-intermediate-representation","page":"Why Julia?","title":"Step 2: Generates the LLVM intermediate representation","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"LLVM is a set of compiler and toolchain technologies that can be used to develop a front end for any programming language and a back end for any instruction set architecture. LLVM is the backend of multiple languages, including Julia, Rust, Swift and Kotlin.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In Julia, one can use the @code_llvm macro to show the LLVM intermediate representation of a function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_llvm jlfactorial(10)\n\nor any instruction set architecture. LLVM is the backend of multiple languages, including Julia, Rust, Swift and Kotlin.\n\n\n\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:1 within `jlfactorial`\ndefine i64 @julia_jlfactorial_3677(i64 signext %0) #0 {\ntop:\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:3 within `jlfactorial`\n; ┌ @ range.jl:5 within `Colon`\n; │┌ @ range.jl:403 within `UnitRange`\n; ││┌ @ range.jl:414 within `unitrange_last`\n     %1 = call i64 @llvm.smax.i64(i64 %0, i64 0)\n; └└└\n; ┌ @ range.jl:897 within `iterate`\n; │┌ @ range.jl:672 within `isempty`\n; ││┌ @ operators.jl:378 within `>`\n; │││┌ @ int.jl:83 within `<`\n      %2 = icmp slt i64 %0, 1\n; └└└└\n  br i1 %2, label %L32, label %L17.preheader\n\nL17.preheader:                                    ; preds = %top\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n  %min.iters.check = icmp ult i64 %1, 2\n  br i1 %min.iters.check, label %scalar.ph, label %vector.ph\n\nvector.ph:                                        ; preds = %L17.preheader\n  %n.vec = and i64 %1, 9223372036854775806\n  %ind.end = or i64 %1, 1\n  br label %vector.body\n\nvector.body:                                      ; preds = %vector.body, %vector.ph\n  %index = phi i64 [ 0, %vector.ph ], [ %induction12, %vector.body ]\n  %vec.phi = phi i64 [ 1, %vector.ph ], [ %3, %vector.body ]\n  %vec.phi11 = phi i64 [ 1, %vector.ph ], [ %4, %vector.body ]\n  %offset.idx = or i64 %index, 1\n  %induction12 = add i64 %index, 2\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; ┌ @ int.jl:88 within `*`\n   %3 = mul i64 %vec.phi, %offset.idx\n   %4 = mul i64 %vec.phi11, %induction12\n   %5 = icmp eq i64 %induction12, %n.vec\n   br i1 %5, label %middle.block, label %vector.body\n\nmiddle.block:                                     ; preds = %vector.body\n; └\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n  %bin.rdx = mul i64 %4, %3\n  %cmp.n = icmp eq i64 %1, %n.vec\n  br i1 %cmp.n, label %L32, label %scalar.ph\n\nscalar.ph:                                        ; preds = %middle.block, %L17.preheader\n  %bc.resume.val = phi i64 [ %ind.end, %middle.block ], [ 1, %L17.preheader ]\n  %bc.merge.rdx = phi i64 [ %bin.rdx, %middle.block ], [ 1, %L17.preheader ]\n  br label %L17\n\nL17:                                              ; preds = %L17, %scalar.ph\n  %value_phi4 = phi i64 [ %7, %L17 ], [ %bc.resume.val, %scalar.ph ]\n  %value_phi6 = phi i64 [ %6, %L17 ], [ %bc.merge.rdx, %scalar.ph ]\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; ┌ @ int.jl:88 within `*`\n   %6 = mul i64 %value_phi6, %value_phi4\n; └\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n; ┌ @ range.jl:901 within `iterate`\n; │┌ @ promotion.jl:521 within `==`\n    %.not = icmp eq i64 %value_phi4, %1\n; │└\n   %7 = add nuw i64 %value_phi4, 1\n; └\n  br i1 %.not, label %L32, label %L17\n\nL32:                                              ; preds = %L17, %middle.block, %top\n  %value_phi10 = phi i64 [ 1, %top ], [ %bin.rdx, %middle.block ], [ %6, %L17 ]\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n  ret i64 %value_phi10\n}","category":"page"},{"location":"chap2/julia-why/#Step-3:-Compiles-to-binary-code","page":"Why Julia?","title":"Step 3: Compiles to binary code","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The LLVM intermediate representation is then compiled to binary code by the LLVM compiler. The binary code can be printed by the @code_native macro.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_native jlfactorial(10)\n\t.section\t__TEXT,__text,regular,pure_instructions\n\t.build_version macos, 14, 0\n\t.globl\t_julia_jlfactorial_3726         ; -- Begin function julia_jlfactorial_3726\n\t.p2align\t2\n_julia_jlfactorial_3726:                ; @julia_jlfactorial_3726\n; ┌ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:1 within `jlfactorial`\n; %bb.0:                                ; %top\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:3 within `jlfactorial`\n; │┌ @ range.jl:5 within `Colon`\n; ││┌ @ range.jl:403 within `UnitRange`\n; │││┌ @ range.jl:414 within `unitrange_last`\n\tcmp\tx0, #0\n\tcsel\tx9, x0, xzr, gt\n; │└└└\n\tcmp\tx0, #1\n\tb.lt\tLBB0_3\n; %bb.1:                                ; %L17.preheader\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tcmp\tx9, #2\n\tb.hs\tLBB0_4\n; %bb.2:\n\tmov\tw8, #1\n\tmov\tw0, #1\n\tb\tLBB0_7\nLBB0_3:\n\tmov\tw0, #1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n\tret\nLBB0_4:                                 ; %vector.ph\n\tmov\tx12, #0\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tand\tx10, x9, #0x7ffffffffffffffe\n\torr\tx8, x9, #0x1\n\tmov\tw11, #1\n\tmov\tw13, #1\nLBB0_5:                                 ; %vector.body\n                                        ; =>This Inner Loop Header: Depth=1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmadd\tx11, x11, x12, x11\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tadd\tx14, x12, #2\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmul\tx13, x13, x14\n\tmov\tx12, x14\n\tcmp\tx10, x14\n\tb.ne\tLBB0_5\n; %bb.6:                                ; %middle.block\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tmul\tx0, x13, x11\n\tcmp\tx9, x10\n\tb.eq\tLBB0_9\nLBB0_7:                                 ; %L17.preheader15\n\tadd\tx9, x9, #1\nLBB0_8:                                 ; %L17\n                                        ; =>This Inner Loop Header: Depth=1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmul\tx0, x0, x8\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n; │┌ @ range.jl:901 within `iterate`\n\tadd\tx8, x8, #1\n; │└\n\tcmp\tx9, x8\n\tb.ne\tLBB0_8\nLBB0_9:                                 ; %L32\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n\tret\n; └\n                                        ; -- End function\n.subsections_via_symbols","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Single function definition may have multiple method instances.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> methods(jlfactorial)\n# 1 method for generic function \"jlfactorial\" from Main:\n [1] jlfactorial(n)\n     @ REPL[4]:1","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Whenever the function is called with a new input type, the Julia compiler will generate a new method instance for the function. The method instance is then stored in the method table, and can be analyzed by the MethodAnalysis package.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using MethodAnalysis\n\njulia> methodinstances(jlfactorial)\n1-element Vector{Core.MethodInstance}:\n MethodInstance for jlfactorial(::Int64)\n\njulia> jlfactorial(UInt32(5))\n120\n\njulia> methodinstances(jlfactorial)\n2-element Vector{Core.MethodInstance}:\n MethodInstance for jlfactorial(::Int64)\n MethodInstance for jlfactorial(::UInt32)","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"When a function is called with multiple arguments, the Julia compiler will invoke the correct method instance according to the type of the arguments. This is called multiple dispatch.","category":"page"},{"location":"chap3/cuda/#Arrays-on-GPU","page":"Arrays on GPU","title":"Arrays on GPU","text":"","category":"section"},{"location":"chap7/cuda/#CUDA-programming","page":"CUDA programming","title":"CUDA programming","text":"","category":"section"},{"location":"chap2/julia-fluid/#Project:-Fluid-dynamics","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"","category":"section"},{"location":"chap2/julia-fluid/#Fluid-Dynamics-Simulation","page":"Project: Fluid dynamics","title":"Fluid Dynamics Simulation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Fluid dynamics is the study of the movement of fluids, including air and water. In this project, we will use the Lattice Boltzmann Method (LBM) to simulate fluid dynamics, which is a mesoscopic method based on the kinetic theory of gases.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":" micro meso macro\nScale 10^-9m 10^-9 -10^-6m 10^6m\nPhysics molecular probabilistic continuous\nGov. Eq. Newton Boltzmann Navier-Stokes equations\nMethod Molecular Dynamics Lattice Boltzmann Computational Fluid Dynamics","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"This book does not aim to provide a comprehensive understanding of fluid dynamics. If you are interested in learning more about fluid dynamics, you can refer to the following resources:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Fluid Dynamics Simulation (in Python, Java and Javascript)\nYouTube - Introduction to Lattice Boltzmann Method","category":"page"},{"location":"chap2/julia-fluid/#Lattice-Boltzmann-Method-(LBM)","page":"Project: Fluid dynamics","title":"Lattice Boltzmann Method (LBM)","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The general idea of LBM is to simulate the fluid dynamics by modeling the movement of particles in a lattice, a grid of cells, without keeping track of the individual particles. The state of a cell in the lattice is defined by the density of particles moving in different directions, i.e. ","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"rm state(i j) equiv rho_ij(mathbfv)","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"where (i j) is the position of the cell in the lattice and mathbfv is the velocity of the particles.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<img src=\"/assets/images/lattice.png\" alt=\"image\" width=300 height=\"auto\">","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The particles move with different velocities mathbf v and collide with each other, driving the fluid to reach an equilibrium state, where the energy of the particles is governed by the Boltzmann distribution","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"rho_rm eq(E) sim e^-fracEk_BT (rm or  e^- rm const times mathbfv^2)","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"where k_B is the Boltzmann constant, T is the temperature, and E = frac12mmathbfv^2 is the energy of the particles.","category":"page"},{"location":"chap2/julia-fluid/#D2Q9-model","page":"Project: Fluid dynamics","title":"D2Q9 model","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The lattice Boltzmann method uses a discrete set of velocities, which is a simplification of the continuous velocity space. One of the simplest models is the D2Q9 model, which contains","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"a 2D lattice, and\n9 discrete velocities: (00), (10) (01) (-10) (0-1), (11) (-11) (-1-1) (1-1).","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<img src=\"/assets/images/D2Q9.png\" alt=\"image\" width=500 height=\"auto\">","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Lattice Boltzmann Method (LBM) contains two steps:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Streaming - particles move to neighboring cells\nCollision - particles collide and exchange momentum","category":"page"},{"location":"chap2/julia-fluid/#Streaming","page":"Project: Fluid dynamics","title":"Streaming","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<img src=\"/assets/images/stream.png\" alt=\"image\" width=500 height=\"auto\">","category":"page"},{"location":"chap2/julia-fluid/#Collision-Bhatnagar-Gross-Krook-(BGK)-model.","page":"Project: Fluid dynamics","title":"Collision - Bhatnagar-Gross-Krook (BGK) model.","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The collision step is based on the Bhatnagar-Gross-Krook (BGK) model, which is a simplified version of the Boltzmann equation. The collision step is defined as","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"rholeftarrow(1-omega)rho_0+omegarho_mathrmrm eq","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"where rho is the updated density rho_0 is the density before collision, and rho_texteq is the equilibrium density omega = Delta ttau, where tau is the (relative) relaxation time","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<img src=\"/assets/images/Equilibrium density.png\" alt=\"image\" width=500 height=\"auto\">","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The BGK model has a nice property that it conserves:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"total density rho\nmomentum rhomathbfu","category":"page"},{"location":"chap2/julia-fluid/#Julia-implementation","page":"Project: Fluid dynamics","title":"Julia implementation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The following code is a part of the package MyFirstPackage that we created in the previous section: My First Package.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"File: src/fluid.jl","category":"page"},{"location":"chap2/julia-fluid/#Step-1.-Define-the-lattice-Boltzmann-configuration","page":"Project: Fluid dynamics","title":"Step 1. Define the lattice Boltzmann configuration","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Let us start by defining an abstract type for lattice Boltzmann configurations and a concrete type that implements the D2Q9 lattice.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    AbstractLBConfig{D, N}\n\nAn abstract type for lattice Boltzmann configurations.\n\"\"\"\nabstract type AbstractLBConfig{D, N} end","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The D2Q9 lattice Boltzman configuration is defined as follows:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    D2Q9 <: AbstractLBConfig{2, 9}\n\nA lattice Boltzmann configuration for 2D, 9-velocity model.\n\"\"\"\nstruct D2Q9 <: AbstractLBConfig{2, 9} end\ndirections(::D2Q9) = (\n        Point(1, 1), Point(-1, 1),\n        Point(1, 0), Point(0, -1),\n        Point(0, 0), Point(0, 1),\n        Point(-1, 0), Point(1, -1),\n        Point(-1, -1),\n    )","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The directions function returns the 9 discrete velocities in the D2Q9 model. The velocities are ordered in a specific way, which enables us to define a function to flip the velocity vector. This is useful for handling the boundaries and barriers in the lattice.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# directions[k] is the opposite of directions[flip_direction_index(k)\nfunction flip_direction_index(::D2Q9, i::Int)\n    return 10 - i\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-2:-Define-the-Cell-type-for-storing-the-state","page":"Project: Fluid dynamics","title":"Step 2: Define the Cell type for storing the state","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The cell state is defined by the density of the fluid in different directions, rho_ij(mathbfv).","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# the density of the fluid, each component is the density of a velocity\nstruct Cell{N, T <: Real}\n    density::NTuple{N, T}\nend\n# the total density of the fluid\ndensity(cell::Cell) = sum(cell.density)\n# the density of the fluid in a specific direction,\n# where the direction is an integer\ndensity(cell::Cell, direction::Int) = cell.density[direction]","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Expect the total density, the momentum mathbfu is also conserved, which is defined as the momentum of the fluid.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    momentum(lb::AbstractLBConfig, rho::Cell)\n\nCompute the momentum of the fluid from the density of the fluid.\n\"\"\"\nfunction momentum(lb::AbstractLBConfig, rho::Cell)\n    return mapreduce((r, d) -> r * d, +, rho.density, directions(lb)) / density(rho)\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Let us also define the addition and multiplication operations for the Cell type.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Base.:+(x::Cell, y::Cell) = Cell(x.density .+ y.density)\nBase.:*(x::Real, y::Cell) = Cell(x .* y.density)","category":"page"},{"location":"chap2/julia-fluid/#Step-3.-Implement-the-streaming-step","page":"Project: Fluid dynamics","title":"Step 3. Implement the streaming step","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# streaming step\nfunction stream!(\n        lb::AbstractLBConfig{2, N},  # lattice configuration\n        newgrid::AbstractMatrix{D}, # the updated grid\n        grid::AbstractMatrix{D}, # the original grid\n        barrier::AbstractMatrix{Bool} # the barrier configuration\n    ) where {N, T, D<:Cell{N, T}}\n    ds = directions(lb)\n    @inbounds for ci in CartesianIndices(newgrid)\n        i, j = ci.I\n        newgrid[ci] = Cell(ntuple(N) do k # collect the densities\n            ei = ds[k]\n            m, n = size(grid)\n            i2, j2 = mod1(i - ei[1], m), mod1(j - ei[2], n)\n            if barrier[i2, j2]\n                # if the cell is a barrier, the fluid flows back\n                density(grid[i, j], flip_direction_index(lb, k))\n            else\n                # otherwise, the fluid flows to the neighboring cell\n                density(grid[i2, j2], k)\n            end\n        end)\n    end\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-4.-Implement-the-collision-step","page":"Project: Fluid dynamics","title":"Step 4. Implement the collision step","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"By the Bhatnagar-Gross-Krook (BGK) model, the collision step drives the fluid towards an equilibrium state. The equilibrium density is completely determined by the total density and the momentum of the fluid:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"rho_rm eq(mathbfv_i) approx rho_rm tot w_i left(1 + 3mathbfv_icdotmathbfu + frac92(mathbfv_icdotmathbfu)^2 - frac32mathbfucdotmathbfuright)","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"where rho_rm tot is the total density, mathbfu is the momentum, w_i sim e^-mathbfv_i^2 is the distribution of velocities with mean-velocity zero, and v_i is the velocity vector.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The detailed derivation of the equilibrium density could be found in the first reference at the top of this page.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    equilibrium_density(lb::AbstractLBConfig, ρ, u)\n\nCompute the equilibrium density of the fluid from the total density and the momentum.\n\"\"\"\nfunction equilibrium_density(lb::AbstractLBConfig{D, N}, ρ, u) where {D, N}\n    ws, ds = weights(lb), directions(lb)\n    return Cell(\n        ntuple(i-> ρ * ws[i] * _equilibrium_density(u, ds[i]), N)\n    )\nend\n\n# the distribution of the 9 velocities at the equilibrium state\nweights(::D2Q9) = (1/36, 1/36, 1/9, 1/9, 4/9, 1/9, 1/9, 1/36, 1/36)\nfunction _equilibrium_density(u, ei)\n    # the equilibrium density of the fluid with a specific mean momentum\n    return (1 + 3 * dot(ei, u) + 9/2 * dot(ei, u)^2 - 3/2 * dot(u, u))\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The collision step that implements the BGK model is defined as follows:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# collision step, applied on a single cell\nfunction collide(lb::AbstractLBConfig{D, N}, rho; viscosity = 0.02) where {D, N}\n    omega = 1 / (3 * viscosity + 0.5)   # \"relaxation\" parameter\n    # Recompute macroscopic quantities:\n    v = momentum(lb, rho)\n    return (1 - omega) * rho + omega * equilibrium_density(lb, density(rho), v)\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-5.-Implement-the-lattice-Boltzmann-simulation","page":"Project: Fluid dynamics","title":"Step 5. Implement the lattice Boltzmann simulation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    LatticeBoltzmann{D, N, T, CFG, MT, BT}\n\nA lattice Boltzmann simulation with D dimensions, N velocities, and lattice configuration CFG.\n\"\"\"\n\nstruct LatticeBoltzmann{D, N, T, CFG<:AbstractLBConfig{D, N}, MT<:AbstractMatrix{Cell{N, T}}, BT<:AbstractMatrix{Bool}}\n    config::CFG # lattice configuration\n    grid::MT    # density of the fluid\n    gridcache::MT # cache for the density of the fluid\n    barrier::BT # barrier configuration\nend\n\nfunction LatticeBoltzmann(config::AbstractLBConfig{D, N}, grid::AbstractMatrix{<:Cell}, barrier::AbstractMatrix{Bool}) where {D, N}\n    @assert size(grid) == size(barrier)\n    return LatticeBoltzmann(config, grid, similar(grid), barrier)\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"A single step of the lattice Boltzmann simulation is defined as follows, which directly modifies the grid field of the LatticeBoltzmann type.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    step!(lb::LatticeBoltzmann)\n\nPerform a single step of the lattice Boltzmann simulation.\n\"\"\"\nfunction step!(lb::LatticeBoltzmann)\n    copyto!(lb.gridcache, lb.grid)\n    stream!(lb.config, lb.grid, lb.gridcache, lb.barrier)\n    lb.grid .= collide.(Ref(lb.config), lb.grid)\n    return lb\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"For better visualization, we define a function to compute the curl of the momentum field in 2D, which is defined as:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    curl(u::AbstractMatrix{Point2D{T}})\n\nCompute the curl of the momentum field in 2D, which is defined as:\n```math\n∂u_y/∂x−∂u_x/∂y\n```\n\"\"\"\nfunction curl(u::Matrix{Point2D{T}}) where T \n    return map(CartesianIndices(u)) do ci\n        i, j = ci.I\n        m, n = size(u)\n        uy = u[mod1(i + 1, m), j][2] - u[mod1(i - 1, m), j][2]\n        ux = u[i, mod1(j + 1, n)][1] - u[i, mod1(j - 1, n)][1]\n        return uy - ux # a factor of 1/2 is missing here?\n    end\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-6.-Find-the-example-simulation","page":"Project: Fluid dynamics","title":"Step 6. Find the example simulation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"A D2Q9 lattice Boltzmann simulation example. A simple linear barrier is added to the lattice.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"function example_d2q9(;\n        height = 80, width = 200,\n        u0 = Point(0.0, 0.1)) # initial and in-flow speed\n    # Initialize all the arrays to steady rightward flow:\n    rho = equilibrium_density(D2Q9(), 1.0, u0)\n    rgrid = fill(rho, height, width)\n\n    # Initialize barriers:\n    barrier = falses(height, width)  # True wherever there's a barrier\n    mid = div(height, 2)\n    barrier[mid-8:mid+8, div(height,2)] .= true              # simple linear barrier\n\n    return LatticeBoltzmann(D2Q9(), rgrid, barrier)\nend","category":"page"},{"location":"chap2/julia-fluid/#Using-the-package","page":"Project: Fluid dynamics","title":"Using the package","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"File: examples/barrier.jl","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"using Makie: RGBA # for visualization\nusing Makie, GLMakie\nusing MyFirstPackage # our package","category":"page"},{"location":"chap2/julia-fluid/#Simulation-and-visualization","page":"Project: Fluid dynamics","title":"Simulation and visualization","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# Set up the visualization with Makie:\nlb = example_d2q9()\nvorticity = Observable(curl(momentum.(Ref(lb.config), lb.grid))')\nfig, ax, plot = image(vorticity, colormap = :jet, colorrange = (-0.1, 0.1))\n\n# Show barrier\nbarrier_img = map(x -> x ? RGBA(0, 0, 0, 1) : RGBA(0, 0, 0, 0), lb.barrier)\nimage!(ax, barrier_img')","category":"page"},{"location":"chap2/julia-fluid/#Benchmarking","page":"Project: Fluid dynamics","title":"Benchmarking","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"using BenchmarkTools\n@benchmark step!($(deepcopy(lb)))","category":"page"},{"location":"chap2/julia-fluid/#Profiling-(!!!)","page":"Project: Fluid dynamics","title":"Profiling (!!!)","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> using Profile\n\njulia> Profile.init(n = 10^7)\n\njulia> @profile for i in 1:100\n           step!(lb)\n       end\n    \njulia> Profile.print()","category":"page"},{"location":"chap2/julia-fluid/#Recording-the-simulation","page":"Project: Fluid dynamics","title":"Recording the simulation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"record(fig, joinpath(@__DIR__, \"barrier.mp4\"), 1:100; framerate = 10) do i\n    for i=1:20\n        step!(lb)\n    end\n    vorticity[] = curl(momentum.(Ref(lb.config), lb.grid))'\nend","category":"page"},{"location":"chap2/julia-fluid/#To-run","page":"Project: Fluid dynamics","title":"To run","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Install dependencies","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"pkg> activate(\"examples\")\n\npkg> dev .\n\npkg> add Makie GLMakie BenchmarkTools","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Type Backspace to exit the package mode.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> include(\"examples/barrier.jl\")","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<video width=\"320\" height=\"240\" controls>   <source src=\"barrier.mp4\" type=\"video/mp4\"> </video>","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Please find the video barrier.mp4 in the same folder as this file if the video does not show up.","category":"page"},{"location":"chap3/factorization/#Matrix-factorization","page":"Matrix factorization","title":"Matrix factorization","text":"","category":"section"},{"location":"chap3/factorization/#Special-matrices","page":"Matrix factorization","title":"Special matrices","text":"","category":"section"},{"location":"chap3/factorization/#QR-factorization","page":"Matrix factorization","title":"QR factorization","text":"","category":"section"},{"location":"chap3/factorization/#Example:-Solving-linear-equations","page":"Matrix factorization","title":"Example: Solving linear equations","text":"","category":"section"},{"location":"chap3/factorization/#Eigenvalue-and-eigenvector","page":"Matrix factorization","title":"Eigenvalue and eigenvector","text":"","category":"section"},{"location":"chap3/factorization/#Example:-Least-square-fitting","page":"Matrix factorization","title":"Example: Least square fitting","text":"","category":"section"},{"location":"chap3/factorization/#Singular-value-decomposition","page":"Matrix factorization","title":"Singular value decomposition","text":"","category":"section"},{"location":"chap3/factorization/#Example:-Principal-component-analysis","page":"Matrix factorization","title":"Example: Principal component analysis","text":"","category":"section"},{"location":"chap4/combinatorial/#Combinatorial-Optimization","page":"Combinatorial Optimization","title":"Combinatorial Optimization","text":"","category":"section"},{"location":"chap4/optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"chap5/montecarlo/#Markov-Chain-Monte-Carlo","page":"Markov Chain Monte Carlo","title":"Markov Chain Monte Carlo","text":"","category":"section"},{"location":"#ScientificComputingForPhysicists","page":"Home","title":"ScientificComputingForPhysicists","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Who-should-read-this-book?","page":"Home","title":"Who should read this book?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I am a book for those who aim to become professional scientific computing programmers. Before reading me, please make sure","category":"page"},{"location":"","page":"Home","title":"Home","text":"the problem you are trying to solve runs more than 10min,\nyou want to become a tool builder rather than tools user, and you are happy with writing the tool with the Julia programming language.","category":"page"}]
}
