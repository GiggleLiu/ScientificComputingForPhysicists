var documenterSearchIndex = {"docs":
[{"location":"chap3/matmul/","page":"-","title":"-","text":"In Julia, we can implement the matrix multiplication as follows.","category":"page"},{"location":"chap3/matmul/","page":"-","title":"-","text":"function mymatmul_rowmajor(A::AbstractMatrix, B::AbstractMatrix)\n    m, n = size(A)\n    n, p = size(B)\n    @assert size(A, 2) == size(B, 1) \"size mismatch\"\n    C = zeros(promote_type(eltype(A), eltype(B)), m, p)\n    @inbounds for i = 1:m\n        for k = 1:n\n            for j = 1:p\n                C[i, j] += A[i, k] * B[k, j]\n            end\n        end\n    end\n    return C\nend","category":"page"},{"location":"chap3/matmul/","page":"-","title":"-","text":"A, B = randn(1000, 1000), randn(1000, 1000);\nusing BenchmarkTools","category":"page"},{"location":"chap3/matmul/","page":"-","title":"-","text":"julia> @benchmark mymatmul_rowmajor($A, $B)\nBenchmarkTools.Trial: 9 samples with 1 evaluation.\n Range (min … max):  616.256 ms … 621.271 ms  ┊ GC (min … max): 0.00% … 0.19%\n Time  (median):     618.576 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   618.502 ms ±   1.597 ms  ┊ GC (mean ± σ):  0.02% ± 0.06%\n\n  ▁        ▁    █             ▁       ▁    █                  ▁  \n  █▁▁▁▁▁▁▁▁█▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁█▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  616 ms           Histogram: frequency by time          621 ms <\n\n Memory estimate: 7.63 MiB, allocs estimate: 2.","category":"page"},{"location":"chap3/matmul/","page":"-","title":"-","text":"Alternatively, we can iterate over the columns of the matrices first.","category":"page"},{"location":"chap3/matmul/","page":"-","title":"-","text":"function mymatmul_colmajor(A::AbstractMatrix, B::AbstractMatrix)\n    m, n = size(A)\n    n, p = size(B)\n    @assert size(A, 2) == size(B, 1) \"size mismatch\"\n    C = zeros(promote_type(eltype(A), eltype(B)), m, p)\n    @inbounds for j = 1:p\n        for k = 1:n\n            for i = 1:m\n                C[i, j] += A[i, k] * B[k, j]\n            end\n        end\n    end\n    return C\nend","category":"page"},{"location":"chap3/matmul/","page":"-","title":"-","text":"julia> @benchmark mymatmul_colmajor($A, $B)\nBenchmarkTools.Trial: 34 samples with 1 evaluation.\n Range (min … max):  146.371 ms … 149.116 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     146.895 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   147.138 ms ± 680.122 μs  ┊ GC (mean ± σ):  0.08% ± 0.27%\n\n        ▁█▄ ▄█▄▁ ▁                                               \n  ▆▁▁▁▁▁███▆████▆█▆▆▁▁▁▁▁▁▁▁▁▁▁▆▁▁▁▁▁▆▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆▆▆▁▁▁▁▁▁▁▆ ▁\n  146 ms           Histogram: frequency by time          149 ms <\n\n Memory estimate: 7.63 MiB, allocs estimate: 2.","category":"page"},{"location":"chap3/matmul/","page":"-","title":"-","text":"julia> @benchmark $A * $B\nBenchmarkTools.Trial: 383 samples with 1 evaluation.\n Range (min … max):  12.089 ms … 38.311 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     12.873 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   13.052 ms ±  1.418 ms  ┊ GC (mean ± σ):  1.20% ± 3.41%\n\n       ▄▆▅ ▂▄▇█▇▅▅▄                                            \n  ▆▁▁▁▁████████████▆▆▁▄▁▁▄▁▄▁▆▆▇▄▇▄▇█▇▇▁▁▇▁▆▁▆▄▁▄▁▁▁▁▁▁▁▁▁▁▁▄ ▇\n  12.1 ms      Histogram: log(frequency) by time      15.8 ms <\n\n Memory estimate: 7.63 MiB, allocs estimate: 2.","category":"page"},{"location":"chap3/matmul/","page":"-","title":"-","text":"The performance of a CPU is measured by the number of floating point operations per second (FLOPS) it can perform. The floating point operations include addition, subtraction, multiplication and division. The FLOPS can be related to multiple factors, such as the clock frequency, the number of cores, the number of instructions per cycle, and the number of floating point units. A simple way to measure the FLOPS is to benchmarking the speed of matrix multiplication. The number of FLOPS in a ntimes ntimes n matrix multiplication is 2n^3. The FLOPS can be calculated as: 2 times 1000^3  (12089 times 10^-3) approx 165rm GFLOPS.","category":"page"},{"location":"chap3/image/#Case-study:-Image-processing","page":"-","title":"Case study: Image processing","text":"","category":"section"},{"location":"chap3/image/","page":"-","title":"-","text":"Download an image from the internet:","category":"page"},{"location":"chap3/image/","page":"-","title":"-","text":"url = \"https://avatars.githubusercontent.com/u/8445510?v=4\"\ntarget_path = tempname() * \".png\"\ndownload(url, target_path)","category":"page"},{"location":"chap3/image/","page":"-","title":"-","text":"Load the image with Images.jl:","category":"page"},{"location":"chap3/image/","page":"-","title":"-","text":"using Images\nimg = load(target_path)","category":"page"},{"location":"chap3/image/","page":"-","title":"-","text":"Quiz:","category":"page"},{"location":"chap3/image/","page":"-","title":"-","text":"How to invert the color of the image?","category":"page"},{"location":"chap3/linalg/#Basic-Linear-Algebra","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"","category":"section"},{"location":"chap3/linalg/#Matrix-multiplication","page":"Basic Linear Algebra","title":"Matrix multiplication","text":"","category":"section"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"Matrix multiplication is a fundamental operation in linear algebra. Given two matrices Ain mathbbC^mtimes n and Bin mathbbC^ntimes p, the product C = AB is defined as","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"C_ij = sum_k=1^n A_ikB_kj","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"The time complexity of matrix multiplication is O(mnp).","category":"page"},{"location":"chap3/linalg/#System-of-Linear-Equations","page":"Basic Linear Algebra","title":"System of Linear Equations","text":"","category":"section"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"note: Example\nLet us consider the following system of linear equationsbeginalign*\n2 x_1 + 3 x_2 - 2 x_3 = 1 \n3 x_1 + 2 x_2 + 3 x_3 = 2 \n4 x_1 - 3 x_2 + 2 x_3 = 3\nendalign*The system of linear equations can be written in matrix form asbeginbmatrix\n2  3  -2 \n3  2  3 \n4  -3  2\nendbmatrix\nbeginbmatrix\nx_1 \nx_2 \nx_3\nendbmatrix\n=\nbeginbmatrix\n1 \n2 \n3\nendbmatrixIn Julia, we can solve the system of linear equations using the backslash operator \\ or the lu function.A = [2 3 -2; 3 2 3; 4 -3 2]\nb = [1, 2, 3]\nA \\ b","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"Let Ain mathbbC^ntimes n be a invertible square matrix and b in mathbbC^n be a vector. Solving a linear equation means finding a vector xinmathbbC^n such that","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A x = b","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"One can solve a linear equation by following these steps:","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"Decompose the matrix A in mathbbC^ntimes n into L in mathbbC^ntimes n and U in mathbbC^ntimes n matrices using a method such as Gaussian elimination or Crout's method.\nRewrite the equation Ax = b as LUx = b.\nSolve for y in Ly = b by Forward-substitution. This involves substituting the values of y into the equation one at a time, starting with the first row and working downwards.\nSolve for x in Ux = y by Back-substitution (link TBA). This involves substituting the values of x into the equation one at a time, starting with the last row and working upwards.","category":"page"},{"location":"chap3/linalg/#Least-Squares-Problem","page":"Basic Linear Algebra","title":"Least Squares Problem","text":"","category":"section"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"note: Example\nSuppose we have a set of data pointst_i 0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5\ny_i 2.9 2.7 4.8 5.3 7.1 7.6 7.7 7.6 9.4 9.0We can fit a quadratic function of the form y = c_0 + c_1 t + c_2 t^2 to the data by solving the least squares problem. We can solve the least squares problem by finding the values of c_0, c_1, and c_2 that minimize the sum of the squared residualssum_i=1^n (y_i - (c_0 + c_1 t_i + c_2 t_i^2))^2In matrix form, the least squares problem can be written asmin_x Ax - b_2whereA = beginbmatrix\n1  t_1  t_1^2 \n1  t_2  t_2^2 \nvdots  vdots  vdots \n1  t_n  t_n^2\nendbmatrix\nx = beginbmatrix\nc_0 \nc_1 \nc_2\nendbmatrix\nb = beginbmatrix\ny_1 \ny_2 \nvdots \ny_n\nendbmatrixBy expanding the expression Ax - b_2, we can see that the solution to the least squares problem is given byx = (A^dagger A)^-1 A^dagger bwhen A^dagger A is invertible, where A^dagger is the Hermitian conjugate of A, which is the same as transpose given A is real. using LinearAlgebra\n\nA = [1 0.0 0.0; 1 0.5 0.25; 1 1.0 1.0; 1 1.5 2.25;\n    1 2.0 4.0; 1 2.5 6.25; 1 3.0 9.0; 1 3.5 12.25;\n    1 4.0 16.0; 1 4.5 20.25]\nb = [2.9, 2.7, 4.8, 5.3, 7.1, 7.6, 7.7, 7.6, 9.4, 9.0]\nx = (A' * A) \\ (A' * b)However, this approach is not recommended for large matrices due to the poor numerical stability. Instead, we can use the qr function to solve the least squares problem.Q, R = qr(A)\nx = R \\ (Matrix(Q)' * b)","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"The least squares problem is to find a vector xinmathbbC^n that minimizes the residual","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"Ax - b_2","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"where Ain mathbbC^mtimes n and bin mathbbC^m. The solution to the least squares problem is given by","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"x = (A^dagger A)^-1 A^dagger b","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"when A^dagger A is invertible.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"In Julia, we can solve the least squares problem using the backslash operator \\ or the qr function.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A = [1 2; 3 4; 5 6]\nb = [2, 3.0, 4.0]","category":"page"},{"location":"chap3/linalg/#Eigenvalues-and-Eigenvectors","page":"Basic Linear Algebra","title":"Eigenvalues and Eigenvectors","text":"","category":"section"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"The eigenvalues and eigenvectors of a matrix Ain mathbbC^ntimes n are the solutions to the equation","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A x = lambda x","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"where lambda is a scalar and x is a non-zero vector. The eigenvalues of a matrix can be found by solving the characteristic equation","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"det(A - lambda I) = 0","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"where I is the identity matrix. The eigenvectors can be found by solving the equation (A - lambda I)x = 0.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"In Julia, we can find the eigenvalues and eigenvectors of a matrix using the eigen function.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A = [1 2; 3 4]\neigen(A)","category":"page"},{"location":"chap3/linalg/#Singular-Value-Decomposition","page":"Basic Linear Algebra","title":"Singular Value Decomposition","text":"","category":"section"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"The singular value decomposition (SVD) of a matrix Ain mathbbC^mtimes n is a factorization of the form","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A = U Sigma V^dagger","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"where Uin mathbbC^mtimes m and Vin mathbbC^ntimes n are orthogonal matrices and Sigmain mathbbC^mtimes n is a diagonal matrix with non-negative real numbers on the diagonal. The singular value decomposition is a generalization of the eigenvalue decomposition for non-square matrices.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"In Julia, we can find the singular value decomposition of a matrix using the svd function.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A = [1 2; 3 4; 5 6]\nsvd(A)","category":"page"},{"location":"chap3/linalg/#QR-Decomposition","page":"Basic Linear Algebra","title":"QR Decomposition","text":"","category":"section"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"The QR decomposition of a matrix Ain mathbbC^mtimes n is a factorization of the form","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A = QR","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"where Qin mathbbC^mtimes m is an orthogonal matrix and Rin mathbbC^mtimes n is an upper triangular matrix. The QR decomposition is used to solve the linear least squares problem and to find the eigenvalues of a matrix.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"In Julia, we can find the QR decomposition of a matrix using the qr function.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A = [1 2; 3 4; 5 6]\nqr(A)","category":"page"},{"location":"chap3/linalg/#Cholesky-Decomposition","page":"Basic Linear Algebra","title":"Cholesky Decomposition","text":"","category":"section"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"The Cholesky decomposition of a positive definite matrix Ain mathbbC^ntimes n is a factorization of the form","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A = LL^dagger","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"where Lin mathbbC^ntimes n is a lower triangular matrix. The Cholesky decomposition is used to solve the linear system of equations Ax = b when A is symmetric and positive definite.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"In Julia, we can find the Cholesky decomposition of a matrix using the cholesky function.","category":"page"},{"location":"chap3/linalg/","page":"Basic Linear Algebra","title":"Basic Linear Algebra","text":"A = [2 1; 1 3]\ncholesky(A)","category":"page"},{"location":"chap1/git/#Maintainability-Version-Control","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Maintaining a software project is not easy, especially when it comes to multiple developers working on the same piece of code. When adding a new feature to the project, maintainers may encounter the following problems:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Multiple developers modify the same file at the same time, works can not be merged easily.\nNew code breaks an existing feature, downstream users are affected.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"The solution to the above problems is version-control. Among all version control software, git is the most popular one.","category":"page"},{"location":"chap1/git/#Install-git","page":"Maintainability - Version Control","title":"Install git","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"In Ubuntu (or WSL), you can install git with the following command:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"sudo apt-get install git","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"In MacOS, you can install git with the following command:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"brew install git","category":"page"},{"location":"chap1/git/#Create-a-git-repository","page":"Maintainability - Version Control","title":"Create a git repository","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"A git repository, also known as a repo, is basically a directory where your project lives and git keeps track of your file's history. To get started, you start with a terminal and type","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"cd path/to/working/directory\ngit init\necho \"Hello, World\" > README.md\ngit add -A\ngit commit -m 'this is my initial commit'\ngit status","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: changes the directory to the working directory, which can be either an existing directory or a new directory.\nLine 2: initializes a git repository in the working directory. A .git directory is created in the working directory, which contains all the necessary metadata for the repo.\nLine 3: creates a file README.md with the content Hello, World. The file README.md is a markdown file, which is a lightweight markup language with plain-text-formatting syntax. You can learn more about markdown from the markdown tutorial. This line can be omitted if the working directory already contains files.\nLine 4: line add files to the staging area (area that caches changes that to be committed).\nLine 5: commits the changes to the repository, which will create a snapshot of your current work.\nLine 6: shows the status of the working directory, staging area, and repository. If the above commands are executed correctly, the output should be nothing to commit, working tree clean.","category":"page"},{"location":"chap1/git/#Track-the-changes-checkout,-diff,-log","page":"Maintainability - Version Control","title":"Track the changes - checkout, diff, log","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Git enables developers to track changes in their codebase. Continuing the previous example, we can analyze the repository with the following commands:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"echo \"Bye Bye, World\" > README.md\ngit diff\ngit add -A\ngit commit -m 'a second commit'\ngit log\ngit checkout HEAD~1\ngit checkout main","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: makes changes to the file README.md.\nLine 2: shows the changes made to the file README.md.\nLine 3-4: adds the changes to the staging area and commits the changes to the repository.\nLine 5: shows the history of commits. The output should be something like this:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"commit 02cd535b6d78fca1713784c61eec86e67ce9010c (HEAD -> main)\nAuthor: GiggleLiu <cacate0129@gmail.com>\nDate:   Mon Feb 5 14:34:20 2024 +0800\n\n    a second commit\n\ncommit 570e390759617a7021b0e069a3fbe612841b3e50\nAuthor: GiggleLiu <cacate0129@gmail.com>\nDate:   Mon Feb 5 14:23:41 2024 +0800\n\n    this is my initial commit","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 6: Checkout the previous snapshot. Note HEAD is your current snapshot and HEAD~n is the nth snapshot counting back from the current snapshot.\nLine 7: Return to the main branch, which points to the latest snapshot. We will discuss more about branch later in this tutorial.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"You can use git reset to reset the current HEAD to the specified snapshot, which can be useful when you committed something bad by accident.","category":"page"},{"location":"chap1/git/#Work-on-cloud-remotes","page":"Maintainability - Version Control","title":"Work on cloud - remotes","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"A server to store git repository, or remote in git terminology, is required for the collaboration purpose. Remote repositories can be hosted on git hosting services such as GitHub and GitLab.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"After creating a new empty repository (no README files) on a git hosting service (Tutorial: How to create a new GitHub repo), a URL for cloning the repo will show up, which that usually starts with git or https. Let us denote this URL as <url> and continue the previous example:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git remote add origin <url>\ngit remote -v\ngit push origin main","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: add a remote repository, where origin is a tag for the added remote.\nLine 2: shows the URL of all remotes, including the origin remote we just added.\nLine 3: push commits to the main branch of the remote repository origin. This command sometimes could fail due to another commit pushed to the remote earlier, where the commit may from another machine or another person. To resolve the issue, you can use git pull origin main to fetch the latest snapshot on the remote. git pull may also fail, because the remote commit may be incompatible with the local commit, e.g. the same file has been changed. In this worst case, you need to merge two commits manually (link).","category":"page"},{"location":"chap1/git/#Develop-features-safely-branches","page":"Maintainability - Version Control","title":"Develop features safely - branches","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"So far, we worked with a single branch main. A branch in git is a lightweight pointer to a specific commit. Working on a single branch is dangerous due to the following reasons:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"No usable code. Developers usually develop features based on the current main branch, so the main branch is expected to always usable. However, working on a single branch can easily break this rule.\nHard to resolve conflicts. when multiple developers modify the same file at the same time, works can not be merged easily. Multiple branches can make the feature development process independent of each other, which can avoid conflicts.\nHard to discard a feature. For some experimental features, you may want to discard it after testing. A commit on the main branch can not be easily reverted.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Understanding the branches is extremely useful when, multiple developers are working on different features.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout -b me/feature\necho \"Hello, World - Version 2\" > README.md\ngit add -A\ngit commit -m 'this is my feature'\ngit push origin me/feature","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: create and switch to the new branch me/feature. Here, we use the branch name me/feature to indicate that this branch is for the feature developed by me, which is a matter of convention.\nLine 2-5: makes some changes to the file README.md and commits the changes to the repository. Finally, the changes are pushed to the remote repository origin. The remote branch me/feature is created automatically.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"While developing a feature, you or another developer may want to develop another feature based on the current main branch. You can create another branch other/feature and develop the feature there.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout main\ngit checkout -b other/feature\necho \"Bye Bye, World - Version 2\" > feature.md\ngit add -A\ngit commit -m 'this is another feature'\ngit push origin other/feature","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"In the above example, we created a new branch other/feature based on the main branch, and made some changes to the file feature.md.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Finally, when the feature is ready, you can merge the feature branch to the main branch.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout main\ngit merge me/feature\ngit push origin main","category":"page"},{"location":"chap1/git/#Working-with-others-issues-and-pull-requests","page":"Maintainability - Version Control","title":"Working with others - issues and pull requests","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"When working with others, you may want to propose changes to a repository and discuss them with others. This is where issues and pull requests come in. Issues and pull requests are features of git hosting services like GitHub and GitLab.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Issue is relatively simple, it is a way to report a bug or request a feature.\nPull request (resource: how to create a pull request) is a way to propose changes to a repository and discuss them with others. It is also a way to merge code from source branch to target branch. The source branch can be a branch in the same repository or a branch in a forked repository - a copy of the repository in your account. Forking a repository is needed when you want to propose changes to a repository that you do not have write access to.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"note: Should I make a pull requests or push directly to main branch?\nTo update the main branch, one should use pull requests as much as possible, even if you have write access to the repository. It is a good practice to discuss the changes with others before merging them to the main branch. A pull request also makes the changes more traceable, which is useful when you want to revert the changes.","category":"page"},{"location":"chap1/git/#Git-cheat-sheet","page":"Maintainability - Version Control","title":"Git cheat sheet","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"It is not possible to cover all the feature of git. We will list a few useful commands and resources for git learning.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"# global config\ngit config  # Get and set repository or global options\n\n# initialize a repo\ngit init    # Create an empty Git repo or reinitialize an existing one\ngit clone   # Clone repository into new directory\n\n# info\ngit status  # Show the working tree status\ngit log     # Show commit logs\ngit diff    # Show changes between commits, commit and working tree, etc\n\n# work on a branch\ngit add     # Add file contents to the index\ngit rm      # Remove files from the working tree and from the index\ngit commit  # Record changes to the repository\ngit reset   # Reset current HEAD to the specified state\n\n# branch manipulation\ngit checkout # Switch branches or restore working tree files\ngit branch  # List, create, or delete branches\ngit merge   # Join two or more development histories together\n\n# remote synchronization\ngit remote  # Manage set of tracked repositories\ngit pull  # Fetch from and integrate with another repo or a local branch\ngit fetch   # Download objects and refs from another repository\ngit push    # Update remote refs along with associated objects","category":"page"},{"location":"chap1/git/#Resources","page":"Maintainability - Version Control","title":"Resources","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"The Official GitHub Training Manual\nMIT online course missing semester.","category":"page"},{"location":"chap3/array/#Array-and-Broadcasting","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"","category":"section"},{"location":"chap3/array/#Array-indexing-and-broadcasting","page":"Array and Broadcasting","title":"Array indexing and broadcasting","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Julia array can be initialized with multiple ways.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"A = [1, 2, 3] # a vector\nB = [1 2 3; 4 5 6; 7 8 9]  # a matrix\nzero_vector = zeros(3) # zero vector\nrand_vector = randn(Float32, 3, 3) # random normal distribution\nstep_vector = collect(1:3)  # collect from a range\nuninitialized_vector = Vector{Int}(undef, 3) # uninitialized vector of size 3","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Julia array indexing starts from 1, which is different from C, Python, and R. 😞","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"A = [1, 2, 3]\nA[1]     # the first element\nA[end]   # the last element\nA[1:2]   # the first two elements\nA[2:-1:1] # the first two elements in the reversed order\nB = [1 2 3; 4 5 6; 7 8 9];\nB[1:2]   # the first two elements, returns B[1,1] and B[2,1] since B is column-major\nB[1:2, 1:2] # returns a submatrix","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Julia has a powerful broadcasting mechanism. It is a way to apply a function to each element of an array. The broadcasting is done by adding a dot . before the function name.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"x = 0:0.1π:2π\ny = sin.(x) .+ cos.(3 .* x);","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"The broadcasting also does the loop fusion, which means only one loop is used to iterate over the elements of the array and no intermediate array is created. This is often more efficient than the step-by-step loop.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"We can use Ref to protect an object from being broadcasted.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Ref([3,2,1,0]) .* (1:3)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"We can see the vector is treated as a whole.","category":"page"},{"location":"chap3/array/#Julia-array-is-column-major","page":"Array and Broadcasting","title":"Julia array is column-major","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"In Julia, arrays are stored in column-major order. This may affect the performance of the code.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"<img src=\"../../assets/images/colmajor.png\" alt=\"column-major\" width=\"200\"/>","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"For example, we can implement the Frobenius norm of a matrix as follows.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"function frobenius_norm(A::AbstractMatrix)\n    s = zero(eltype(A))\n    # the `@inbounds` macro tells the compiler that the loop is safe and it can skip the boundary check.\n    @inbounds for i in 1:size(A, 1)\n        for j in 1:size(A, 2)\n            s += A[i, j]^2\n        end\n    end\n    return sqrt(s)\nend","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"A = randn(1000, 1000);\nfrobenius_norm(A)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"julia> using BenchmarkTools\n\njulia> @benchmark frobenius_norm($A)\nBenchmarkTools.Trial: 25 samples with 1 evaluation.\n Range (min … max):  203.310 ms … 214.439 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     204.769 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   205.331 ms ±   2.247 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▃   ▃▃███▃ ▃                                                   \n  █▁▇▁██████▇█▁▁▇▁▁▁▁▁▁▇▁▁▁▁▁▁▁▁▁▁▇▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇ ▁\n  203 ms           Histogram: frequency by time          214 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Alternatively, we can loop over the second index first.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"function frobenius_norm_colmajor(A::AbstractMatrix)\n    s = zero(eltype(A))\n    @inbounds for j in 1:size(A, 2)\n        for i in 1:size(A, 1)\n            s += A[i, j]^2\n        end\n    end\n    return sqrt(s)\nend","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"julia> @benchmark frobenius_norm_colmajor($A)\nBenchmarkTools.Trial: 53 samples with 1 evaluation.\n Range (min … max):  90.380 ms … 133.823 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     92.729 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   94.415 ms ±   6.425 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n      ▂ ▂█ ▄   ▂                                                \n  ▆██▄█▆████▆▆▄█▄▁▁▁▁▄▄▄▁▁▁▁▁▁▁▁▁▄▁▁▁▄▁▁▁▁▄▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▁\n  90.4 ms         Histogram: frequency by time          108 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"We can see by simply changing the order of the loop, the performance is improved by more than 2 times. This is because the memory access pattern is more cache-friendly.","category":"page"},{"location":"chap3/array/#Example:-create-a-meshgrid-for-triangular-lattice","page":"Array and Broadcasting","title":"Example: create a meshgrid for triangular lattice","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"b1 = [1, 0]\nb2 = [0.5, sqrt(3)/2]\nn = 5\nmesh1 = [i * b1 + j * b2 for i in 1:n, j in 1:n]  # list comprehension\nmesh2= (1:n) .* Ref(b1) .+ (1:n)' .* Ref(b2)  # broadcasting","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"using Plots\n\nscatter(vec(getindex.(mesh2, 1)), vec(getindex.(mesh2, 2)), label=\"mesh2\", ratio=1, markersize=5)","category":"page"},{"location":"chap3/array/#Array-performance-tips","page":"Array and Broadcasting","title":"Array performance tips","text":"","category":"section"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Fix the type of an array","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Arrays with a fixed type are faster than arrays with abstract types. Any type vector is the most flexible, but it is also very slow.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"vany = Any[]  # same as vany = []\ntypeof(vany)\npush!(vany, \"a\")\npush!(vany, 1)","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"Fixed typed vector is more restrictive.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"vfloat64 = Float64[]\nvfloat64 |> typeof\npush!(vfloat64, \"a\")","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"The performance of the vector with a fixed type is much better than the vector with any type.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"julia> biganyv = collect(Any, 1:2:20000);\n\njulia> @benchmark for i=1:length($biganyv)\n    $biganyv[i] += 1\nend\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  117.833 μs …  1.090 ms  ┊ GC (min … max): 0.00% … 71.28%\n Time  (median):     124.458 μs              ┊ GC (median):    0.00%\n Time  (mean ± σ):   128.512 μs ± 39.121 μs  ┊ GC (mean ± σ):  1.55% ±  4.49%\n\n  ▁   ▃▇█▅▂▂▅▆▄▂▃▄▃▃▄▄▄▃▂▂▂▂▁▁▁▁▁▁                             ▂\n  █▆▄▄█████████████████████████████████▇█▇▇▇█▇▇▇▆▆▄▆▆▆▅▅▅▅▅▅▂▄ █\n  118 μs        Histogram: log(frequency) by time       155 μs <\n\n Memory estimate: 156.25 KiB, allocs estimate: 10000.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"julia> bigfloatv = collect(Float64, 1:2:20000);\n\njulia> @benchmark for i=1:length($bigfloatv)\n    $bigfloatv[i] += 1\nend\nBenchmarkTools.Trial: 10000 samples with 40 evaluations.\n Range (min … max):  908.325 ns …  2.020 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     936.475 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   955.204 ns ± 69.933 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▃   ▇█  ▂▅▁  ▁     ▂                                         ▁\n  █▄▃▃██▇▆███▇▆█▆█▇▄▆█▇▆▆▆█▇▇▆▇▇▇▇▆▅▅▆▆▆▅▅▅▅▃▄▅▄▅▄▄▃▄▄▄▄▄▄▅▅▄▆ █\n  908 ns        Histogram: log(frequency) by time      1.24 μs <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap3/array/","page":"Array and Broadcasting","title":"Array and Broadcasting","text":"We can see that the performance of the vector with a fixed type can be 100 times faster than the vector with any type.","category":"page"},{"location":"chap6/compressedsensing/#Compressed-sensing","page":"Compressed sensing","title":"Compressed sensing","text":"","category":"section"},{"location":"chap1/ci/#Correctness-Unit-Tests","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"In terms of scientific computing, accuracy of your result is most certainly more important than anything else. Checking the correctness is definitely one of the most challenging tasks in software development. Consider the following scenario:","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"question: The problem of code review\nSuppose you are one of the maintainers of the Julia programming language. One day, a GitHub user Oscar Smith submitted a 6k-line PR to the JuliaLang/julia repository: (Image: )You want to check if this huge PR did something expected, requiring the following conditions to be satisfied:The build is successfully on Linux, macOS and Windows.\nNo existing feature breaks.\nThe added feature does something expected.What would you do?Checking to the 128 changed files line-by-line with human eye.\nHire a part-time worker, try installing the PR on three fresh machines, and try using as many features as possible and see if anything breaks.\nSomething more efficient.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"In the above scenario, the first option is not reliable for a software project expected to be used by millions of users. The second option is too expensive and time-consuming. Clever software engineers have come up with a more efficient way to check the correctness of the code, which is to use Unit Tests and CI/CD.","category":"page"},{"location":"chap1/ci/#Unit-Test","page":"Correctness - Unit Tests","title":"Unit Test","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"Unit Tests is a software a testing method for the smallest testable unit of an application, e.g. functions. Unit tests are composed of a series of individual test cases, each of which is composed of:","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"a collection of inputs and expected outputs for a function.\nan assertion statement to verify the function returns the expected output for a given input.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"To verify the correctness of the code, we run the unit tests. If the tests pass and the coverage is high, we can be confident that the code is working as expected.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"Tests pass: all assertions in the test cases are true.\nTest coverage: the percentage of the code that is covered by tests, i.e. the higher the coverage, the more robust the code is.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"In Julia, Test is a built-in package for writing and running unit tests. We will learn how to write and run unit tests in the section My First Package.","category":"page"},{"location":"chap1/ci/#Automate-your-workflow-CI/CD","page":"Correctness - Unit Tests","title":"Automate your workflow - CI/CD","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"You still need to set up three clean machines to run the tests. What if you do not have three machines? The key to solving this problem is to automate the workflow on the cloud with the containerization technology, e.g. Docker. You do not need to configure the dockers on the cloud manually. Instead, you can use a Continuous Integration/Continuous Deployment (CI/CD) service to automate the workflow of","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"(CI) build, test and merge the code changes whenever a developer commits code to the repository.\n(CD) deploy the code or documentation to a cloud service and register the package to the package registry.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"CI/CD are often integrated with git hosting services, e.g. Github Actions. A typical CI/CD pipeline include the following steps:","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"code updated detected,\nfor each task, initialize a virtual machine on the cloud,\nthe virtual machine initializes the environment and runs the tests,\nthe virtual machine reports the test results.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"The tasks of CI/CD are often defined in a configuration file, e.g. .github/workflows/ci.yml. We will learn how to set up a CI/CD pipeline in the section My First Package.","category":"page"},{"location":"chap2/julia-release/#My-First-Package","page":"My First Package","title":"My First Package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"One of the most important features of Julia is its package manager. It allows one to create, manage, and publish his own packages. In this section, we will learn how to create a package and publish it to the Julia registry.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Julia package manager can install the correct version of a package and its dependencies because it knows the exact versions of all the packages that are compatible with each other. This information was stored in the General registry - a central GitHub repository of metadata about all registered Julia packages.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Everyone can register a package in the General registry. To do so, you need to:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Create a package.\nSpecify the dependency of your package in the Project.toml file, like which version of a package your package depends on.\nDevelop the package by writing the source code, tests, and documentation.\nOpen-source the package by pushing the package to a public repository on GitHub. GitHub Actions can be used to automate the process of testing, building the documentation, and tagging a release so that other developers can contribute to the package easily.\nRegister the package in the General registry by creating a pull request to the General registry.","category":"page"},{"location":"chap2/julia-release/#Create-a-package","page":"My First Package","title":"Create a package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"We use PkgTemplate. Open a Julia REPL and type the following commands to initialize a new package named MyFirstPackage:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"julia> using PkgTemplates\n\njulia> tpl = Template(;\n    user=\"GiggleLiu\",  # replace!\n    authors=\"GiggleLiu\",  # replace!\n    julia=v\"1.10\",\n    plugins=[\n        License(; name=\"MIT\"),\n        Git(; ssh=true),\n        GitHubActions(; x86=true),\n        Codecov(),\n        Documenter{GitHubActions}(),\n    ],\n)\n\njulia> tpl(\"MyFirstPackage\")","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"where the username \"GiggleLiu\" should be replaced with your GitHub username. Many plugins are used in the above example:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"License: to choose a license for the package. Here we use the MIT license, which is a permissive free software license. Popular licenses include:\nMIT: a permissive free software license, featured with a short and simple permissive license with conditions only requiring preservation of copyright and license notices.\nApache2: a permissive free software license, featured with a contributor license agreement and a patent grant.\nGPL: a copyleft free software license, featured with a strong copyleft license that requires derived works to be available under the same license.\nGit: to initialize a Git repository for the package. Here we use the SSH protocol for Git for convenience. Using two-factor authentication (2FA) can make your GitHub account more secure.\nGitHubActions: to enable continuous integration (CI) with GitHub Actions.\nCodecov: to enable code coverage tracking with Codecov. It is a tool that helps you to measure the test coverage of your code. A package with high test coverage is more reliable.\nDocumenter: to enable documentation building and deployment with Documenter.jl and GitHub pages.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"After running the above commands, a new directory named MyFirstPackage will be created in the folder ~/.julia/dev/ - the default location for Julia packages.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"note: What makes a good package name?\nFor a package that is intended to be registered in the General registry, it is recommended to use a name that follows the Julia package naming guidelines. Although the same registry may not have two packages with the same name, a package use the UUID rather than the name as its unique identifier, because name may not be unique when multiple registries are used together.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The file structure of the package is as follows:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"tree .   \n.\n├── .git\n│   ...\n├── .github\n│   ├── dependabot.yml\n│   └── workflows\n│       ├── CI.yml\n│       ├── CompatHelper.yml\n│       └── TagBot.yml\n├── .gitignore\n├── LICENSE\n├── Manifest.toml\n├── Project.toml\n├── README.md\n├── docs\n│   ├── Manifest.toml\n│   ├── Project.toml\n│   ├── make.jl\n│   └── src\n│       └── index.md\n├── src\n│   └── MyFirstPackage.jl\n└── test\n    └── runtests.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":".git and .gitignore: the files that are used by Git. The .gitingore file contains the files that should be ignored by Git. By default, the .gitignore file contains the following lines:\n*.jl.*.cov\n*.jl.cov\n*.jl.mem\n/Manifest.toml\n/docs/Manifest.toml\n/docs/build/\n.github: the folder that contains the GitHub Actions configuration files.\nLICENSE: the file that contains the license of the package. The MIT license is used in this package.\nREADME.md: the manual that shows up in the GitHub repository of the package, which contains the description of the package.\nProject.toml: the file that contains the metadata of the package, including the name, UUID, version, dependencies and compatibility of the package.\nManifest.toml: the file that contains the exact versions of all the packages that are compatible with each other. It is usually automatically resolved from the Project.toml file, and it is not recommended pushing it to the remote repository.\ndocs: the folder that contains the documentation of the package. It has its own Project.toml and Manifest.toml files, which are used to manage the documentation environment. The make.jl file is used to build the documentation and the src folder contains the source code of the documentation.\nsrc: the folder that contains the source code of the package.\ntest: the folder that contains the test code of the package, which contains the main test file runtests.jl.","category":"page"},{"location":"chap2/julia-release/#Specify-the-dependency","page":"My First Package","title":"Specify the dependency","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The file that contains the metadata of the package, including the name, UUID, version, dependencies and compatibility of the package. To add a new dependency, you can use the following command in the package path:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"$ cd ~/.julia/dev/MyFirstPackage\n\n$ julia --project","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"This will open a Julia REPL in the package environment. To check the package environment, you can type the following commands in the package mode (press ]) of the REPL:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> st\nProject MyFirstPackage v1.0.0-DEV\nStatus `~/.julia/dev/MyFirstPackage/Project.toml` (empty project)","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"After that, you can add a new dependency by typing:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> add LinearAlgebra\n\n(MyFirstPackage) pkg> st\nProject MyFirstPackage v1.0.0-DEV\nStatus `~/jcode/ScientificComputingForPhysicists/lib/MyFirstPackage/Project.toml`\n  [37e2e46d] LinearAlgebra","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The dependency is added correctly if no error is thrown. Press backspace to exit the package mode.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Type ; to enter the shell mode and then type","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"shell> cat Project.toml\nname = \"MyFirstPackage\"\nuuid = \"594718ca-da39-4ff3-a299-6d8961b2aa49\"\nauthors = [\"GiggleLiu\"]\nversion = \"1.0.0-DEV\"\n\n[deps]\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\n\n[compat]\njulia = \"1.10\"\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"You will see that the dependency LinearAlgebra is added to the [deps] section of the Project.toml file.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"We also need to specify which version of LinearAlgebra is compatible with the current package. To do so, you need to edit the [compat] section of the Project.toml file with your favorite editor.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"[compat]\njulia = \"1.10\"\nLinearAlgebra = \"1\"  # added line","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Here, we have used the most widely used dependency version specifier =, which means matching the first nonzero component of the version number. For example:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"1 matches 1.0.0, 1.1.0, 1.1.1, but not 2.0.0.\n0.8 matches 0.8.0, 0.8.1, 0.8.2, but not 0.9.0 or 0.7.0.\n1.2 matches 1.2.0, 1.3.1, but not 1.1.0 or 2.0.0.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The validity of specifying compatibility is based on the consensus among the developers:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"whenever an exported function is changed in a package, the first nonzero component of the version number should be increased.\nversion number starts with 0 is considered as a development version, and it is not stable.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Please check the Julia documentation about package compatibility for advanced usage.","category":"page"},{"location":"chap2/julia-release/#Develop-the-package","page":"My First Package","title":"Develop the package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Developers develop packages in the package environment. The package development process includes:","category":"page"},{"location":"chap2/julia-release/#1.-Edit-the-source-code","page":"My First Package","title":"1. Edit the source code","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The source code of the package is located in the src folder of the package path.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Let us add a simple function to the package. The source code of the package is as follows:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: src/MyFirstPackage.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"module MyFirstPackage\n# import packages\nusing LinearAlgebra\n\n# export interfaces\nexport Lorenz, integrate_step\nexport Point, Point2D, Point3D\nexport RungeKutta, Euclidean\n\n# `include` other source files into this module\ninclude(\"lorenz.jl\")\n\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The include(\"lorenz.jl\") line includes the source code of the Lorenz system, which can be defined in the lorenz.jl file in the same folder. The source code of is as follows:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: src/lorenz.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"\"\"\"\n    Point{D, T}\n\nA point in D-dimensional space, with coordinates of type T.\n\n# Examples\n```jldoctest\njulia> p1 = Point(1.0, 2.0)\nPoint{2, Float64}((1.0, 2.0))\n\njulia> p2 = Point(3.0, 4.0)\nPoint{2, Float64}((3.0, 4.0))\n\njulia> p1 + p2\nPoint{2, Float64}((4.0, 6.0))\n```\n\"\"\"\n# define a point in D-dimensional space\nstruct Point{D, T <: Real}\n    data::NTuple{D, T}  # a tuple of D elements of type T\nend\nPoint(x::Real...) = Point((x...,))  # `...` is the splat operator\n# define 2D and 3D points\nconst Point2D{T} = Point{2, T}\nconst Point3D{T} = Point{3, T}\n\n# define the dot product of two coordinate vectors\n# `mapreduce` is a high-order function that applies a function to each element \n# of an iterable and then reduces the result to a single value.\nLinearAlgebra.dot(x::Point, y::Point) = mapreduce(*, +, x.data, y.data)\n# implement the operations of the point\n# `Base` is the standard library of Julia\n# `Base.isapprox` is used to define a new method for the function `isapprox` in the `Base` module\n# for arithmetic operations like `*`, `*`, `+`, an extra `:` is required to avoid ambiguity\nBase.:*(x::Real, y::Point) = Point(x .* y.data) # `.` is the broadcast operator\nBase.:/(y::Point, x::Real) = Point(y.data ./ x)\nBase.:+(x::Point, y::Point) = Point(x.data .+ y.data)\nBase.isapprox(x::Point, y::Point; kwargs...) = all(isapprox.(x.data, y.data; kwargs...))\n# `all` returns true if all elements of the iterable are true\n\n# define the index and broadcastable functions\nBase.getindex(p::Point, i::Int) = p.data[i] # for `p[i]` like operations\nBase.broadcastable(p::Point) = p.data # for `x .+ y` like operations\nBase.iterate(p::Point, args...) = iterate(p.data, args...) # for `[p...]` like operations\n\n# the Lorenz system\nstruct Lorenz\n    σ::Float64\n    ρ::Float64\n    β::Float64\nend\n\n# the differential equation of the Lorenz system\nfunction field(p::Lorenz, u)\n    x, y, z = u\n    Point(p.σ*(y-x), x*(p.ρ-z)-y, x*y-p.β*z)\nend\n\n# abstract type for integrators, which allows us to switch between different integration methods\nabstract type AbstractIntegrator end\n# Runge-Kutta 4th order method\n# https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods\nstruct RungeKutta{K} <: AbstractIntegrator end\n# Euclidean method\nstruct Euclidean <: AbstractIntegrator end\n\nfunction integrate_step(f, ::RungeKutta{4}, t, y, Δt)\n    k1 = Δt * f(t, y)\n    k2 = Δt * f(t+Δt/2, y + k1 / 2)\n    k3 = Δt * f(t+Δt/2, y + k2 / 2)\n    k4 = Δt * f(t+Δt, y + k3)\n    return y + k1/6 + k2/3 + k3/3 + k4/6\nend\n\n# Euclidean integration\nfunction integrate_step(f, ::Euclidean, t, y, Δt)\n    return y + Δt * f(t, y)\nend\n\nfunction integrate_step(lz::Lorenz, int::AbstractIntegrator, u, Δt)\n    return integrate_step((t, u) -> field(lz, u), int, zero(Δt), u, Δt)\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"To use this function, you can type the following commands in the package environment:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"julia> using MyFirstPackage\n\njulia> Point(2.0, 3.0)\nPoint2D{Float64}((2.0, 3.0))","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"note: How to enter package environment?\nIn shell: type\n$ cd ~/.julia/dev/MyFirstPackage\n$ julia --project\nIn REPL: press ] to enter the package mode and then type\npkg> activate path/to/package\nto enter the package environment. To deactivate the package environment, type\npkg> activate\nIn VSCode: Click the Julia env: ... button in the bottom of the window and then select the package path.","category":"page"},{"location":"chap2/julia-release/#2.-Write-tests","page":"My First Package","title":"2. Write tests","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"We always need to write tests for the package. The test code of the package is located in the test folder of the package path.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: test/runtests.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"using Test\nusing MyFirstPackage\n\n@testset \"lorenz\" begin\n    include(\"lorenz.jl\")\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: test/lorenz.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"using Test, MyFirstPackage\n\n@testset \"Point\" begin\n    p1 = Point(1.0, 2.0)\n    p2 = Point(3.0, 4.0)\n    @test p1 + p2 ≈ Point(4.0, 6.0)\nend\n\n@testset \"step\" begin\n    lz = Lorenz(10.0, 28.0, 8/3)\n    int = RungeKutta{4}()\n    r1 = integrate_step(lz, int, Point(1.0, 1.0, 1.0), 0.0001)\n    eu = Euclidean()\n    r2 = integrate_step(lz, eu, Point(1.0, 1.0, 1.0), 0.0001)\n    @test isapprox(r1, r2; rtol=1e-5)\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"To run the tests, you can use the following command in the package environment:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> test\n  ... \n  [8e850b90] libblastrampoline_jll v5.8.0+1\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds. 2 already precompiled.\n     Testing Running tests...\nTest Summary: | Pass  Total  Time\nlorenz        |    2      2  0.1s\nTest Summary: | Pass  Total  Time\nfluid         |    1      1  0.1s\n     Testing MyFirstPackage tests passed","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Cheers! All tests passed.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"You might want to write some examples to visualize the results of the package with Makie. We create an examples folder in the package path and then write the following example code","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: examples/lorenz.jl","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"using Makie, GLMakie, MyFirstPackage\nset_theme!(theme_black())\n\n# create a Lorenz system\nlz = Lorenz(10, 28, 8/3)\n\n# initial condition\ny = MyFirstPackage.Point(1.0, 1.0, 1.0)\n \n# `Observable` defines the signal that can be used to update plots efficiently\npoints = Observable(Point3f[])\ncolors = Observable(Int[])\n\n# create a figure\nfig, ax, l = lines(points, color = colors,\n    colormap = :inferno, transparency = true, \n    axis = (; type = Axis3, protrusions = (0, 0, 0, 0), \n              viewmode = :fit, limits = (-30, 30, -30, 30, 0, 50)))\n\nrecord(fig, \"lorenz.mp4\", 1:120) do frame\n    global y\n    for i in 1:50\n        # update arrays inplace\n        y = integrate_step(lz, RungeKutta{4}(), y, 0.01)\n        push!(points[], Point3f(y...))\n        push!(colors[], frame)\n    end\n    ax.azimuth[] = 1.7pi + 0.3 * sin(2pi * frame / 120) # set the view angle of the axis\n    notify(points); notify(colors) # tell points and colors that their value has been updated\n    l.colorrange = (0, frame) # update plot attribute directly\nend","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"It output a video file lorenz.mp4 that visualizes the Lorenz system: (Image: )","category":"page"},{"location":"chap2/julia-release/#3.-Write-documentation","page":"My First Package","title":"3. Write documentation","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The documentation is built with Documenter.jl. The build script is docs/make.jl. To build the documentation, you can first enter the package environment and then type the following commands in a terminal:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"$ cd docs\n$ julia --project","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Instantiate or update the documentation environment if necessary. ","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(docs) pkg> dev ..\n\n(docs) pkg> instantiate # or `up`","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"where dev .. is used to add the MyFirstPackage under development to the documentation environment.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Then build the documentation by typing","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"julia> include(\"make.jl\")","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"where include is a built-in function in Julia that includes the source code of the documentation build file make.jl into the current environment.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"The generated HTML files are located in the docs/build folder of the package path. To preview the documentation, just open the index.html file in a web browser.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"note: Live preview of documentation\nFor seamless previewing of documentation on updates, it is highly recommended using the LiveServer.jl package.","category":"page"},{"location":"chap2/julia-release/#Open-source-the-package","page":"My First Package","title":"Open-source the package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"To open-source the package, you need to push the package to a public repository on GitHub.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"First create a GitHub repository with the same name as the package. In this example, the repository name should be MyFirstPackage.jl. To check the remote repository of the package, you can use the following command in the package path:\n$ git remote -v\norigin\tgit@github.com:GiggleLiu/MyFirstPackage.jl.git (fetch)\norigin\tgit@github.com:GiggleLiu/MyFirstPackage.jl.git (push)\nThen push the package to the remote repository:\n$ git add -A\n$ git commit -m \"Initial commit\"\n$ git push\nAfter that, you need to check if all your GitHub Actions are passing. You can check the status of the GitHub Actions from the badge in the README.md file of the package repository. The configuration of GitHub Actions is located in the .github/workflows folder of the package path. Its file structure is as follows:\n.github\n├── dependabot.yml\n└── workflows\n    ├── CI.yml\n    ├── CompatHelper.yml\n    └── TagBot.yml\nThe CI.yml file contains the configuration for the CI of the package, which is used to automate the process of\nTesting the package after a pull request is opened, or the main branch is updated. This process can be automated with the julia-runtest action.\nBuilding the documentation after the main branch is updated. Please check the Documenter documentation for more information.\nThe TagBot.yml file contains the configuration for the TagBot, which is used to automate the process of tagging a release after a pull request is merged.\nThe CompatHelper.yml file contains the configuration for the CompatHelper, which is used to automate the process of updating the [compat] section of the Project.toml file after a pull request is merged.\nConfiguring GitHub Actions is a bit complicated. For beginners, it is a good practise to mimic the configuration of another package, e.g. OMEinsum.jl.","category":"page"},{"location":"chap2/julia-release/#Register-the-package","page":"My First Package","title":"Register the package","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Once your package is ready to be published, you need to register the package in the General registry. The General registry is a central GitHub repository of metadata about all registered Julia packages. To register the package, you need to create a pull request to the General registry and wait for the pull request to be reviewed and merged. This process can be automated by the Julia registrator. If the pull request meets all guidelines, your pull request will be merged after a few days. Then, your package is available to the public. ","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"A good practice is to tag a release after the pull request is merged so that your package version update can be reflected in your GitHub repository. This process can be automated by the TagBot.","category":"page"},{"location":"chap2/julia-release/#Case-study:-The-file-structure-of-[OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl)","page":"My First Package","title":"Case study: The file structure of OMEinsum.jl","text":"","category":"section"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"(Image: )","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"OMEinsum.jl is a package for tensor contraction. The badges in the README.md file of the package repository are the following:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"build/passing: the tests executed by GitHub Actions are passing.\ncodecov/89%: the code coverage is 89%, meaning that 89% of the code is covered by tests.\ndocs/dev: the documentation is built and deployed with GitHub pages.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Now, let's take a look at the file structure of the package by running the following command in the package path (~/.julia/dev/OMEinsum):","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"$ tree . -L 1 -a\n.\n├── .git\n├── .github\n├── .gitignore\n├── LICENSE\n├── Project.toml\n├── README.md\n├── benchmark\n├── docs\n├── examples\n├── ext\n├── ome-logo.png\n├── src\n└── test","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"File: Project.toml","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"name = \"OMEinsum\"\nuuid = \"ebe7aa44-baf0-506c-a96f-8464559b3922\"\nauthors = [\"Andreas Peter <andreas.peter.ch@gmail.com>\"]\nversion = \"0.8.1\"\n\n[deps]\nAbstractTrees = \"1520ce14-60c1-5f80-bbc7-55ef81b5835c\"\nBatchedRoutines = \"a9ab73d0-e05c-5df1-8fde-d6a4645b8d8e\"\nChainRulesCore = \"d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4\"\nCombinatorics = \"861a8166-3701-5b0c-9a16-15d98fcdc6aa\"\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\nMacroTools = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\nOMEinsumContractionOrders = \"6f22d1fd-8eed-4bb7-9776-e7d684900715\"\nTupleTools = \"9d95972d-f1c8-5527-a6e0-b4b365fa01f6\"\n\n[weakdeps]\nCUDA = \"052768ef-5323-5732-b1bb-66c8b64840ba\"\n\n[extensions]\nCUDAExt = \"CUDA\"\n\n[compat]\nAbstractTrees = \"0.3, 0.4\"\nBatchedRoutines = \"0.2\"\nCUDA = \"4, 5\"\nChainRulesCore = \"1\"\nCombinatorics = \"1.0\"\nMacroTools = \"0.5\"\nOMEinsumContractionOrders = \"0.8\"\nTupleTools = \"1.2, 1.3\"\njulia = \"1\"\n\n[extras]\nDocumenter = \"e30172f5-a6a5-5a46-863b-614d45cd2de4\"\nDoubleFloats = \"497a8b3b-efae-58df-a0af-a86822472b78\"\nForwardDiff = \"f6369f11-7733-5829-9624-2563aa707210\"\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\nPolynomials = \"f27b6e38-b328-58d1-80ce-0feddd5e7a45\"\nProgressMeter = \"92933f4c-e287-5a05-a399-4b506db050ca\"\nRandom = \"9a3f8284-a2c9-5f02-9a11-845980a1fd5c\"\nSymEngine = \"123dc426-2d89-5057-bbad-38513e3affd8\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\nTropicalNumbers = \"b3a74e9c-7526-4576-a4eb-79c0d4c32334\"\nZygote = \"e88e6eb3-aa80-5325-afca-941959d7151f\"\n\n[targets]\ntest = [\"Test\", \"Documenter\", \"LinearAlgebra\", \"ProgressMeter\", \"SymEngine\", \"Random\", \"Zygote\", \"DoubleFloats\", \"TropicalNumbers\", \"ForwardDiff\", \"Polynomials\", \"CUDA\"]","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"It contains the following more sections:","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"[weakdeps] and [extensions]: the sections that specify the extensions of the package, which is related with the files in the ext folder. A package \"extension\" is a module that is automatically loaded when a specified set of other packages (its \"extension dependencies\") are loaded in the current Julia session. As a using case, consider you want to add the CUDA support to your package, but you don't want to force all users to install CUDA package if they don't need it, then adding CUDA as a weak dependency and move this feature ext folder is a good choice. Please check the Julia documentation about package extensions for more information.\n[extras] and [targets]: the section that specifies the extra dependencies of the package that used to test the package. One can also specify the extra dependencies for the test environment in the test folder of the package path.","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Quiz: ","category":"page"},{"location":"chap2/julia-release/","page":"My First Package","title":"My First Package","text":"Is ChainRulesCore at version 1.2 compatible with OMEinsum?\nIf ChainRulesCore at version 2.0 is released, what should be done to make OMEinsum compatible with the new version of ChainRulesCore? Which GitHub Action is used to automate this process?\nIf an author of OMEinsum fixed a bug, what should be done to make the new version of OMEinsum available to the public?\nIf an author of OMEinsum changed an exported function, what should be done to make the new version of OMEinsum available to the public?","category":"page"},{"location":"chap1/opensource_scientist/#Becoming-an-Open-Source-Developer","page":"Becoming an Open-Source Developer","title":"Becoming an Open-Source Developer","text":"","category":"section"},{"location":"chap1/opensource_scientist/","page":"Becoming an Open-Source Developer","title":"Becoming an Open-Source Developer","text":"This section focuses on understanding the open source workflow, which is the foundation of scientific computing. Along the way, we will introduce to you our recommended tools for accomplishing each task. ","category":"page"},{"location":"chap2/julia-setup/#Setup-Julia","page":"Setup Julia","title":"Setup Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julia is a high-level, high-performance, dynamic programming language. From the designing stage, Julia is intended to address the needs of high-performance numerical analysis and computational science, without the typical need of separate compilation to be fast, while also being effective for general-purpose programming, web use or as a specification language. Julia is also a free and open-source language, with a large community and a rich ecosystem.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"We will devlve deeper into Julia later in the chapter. For now, we will just install Julia and setup the environment.","category":"page"},{"location":"chap2/julia-setup/#Step-1:-Installing-Julia","page":"Setup Julia","title":"Step 1: Installing Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"For Linux/Mac users, please open a terminal and type the following command to install Julia with juliaup. Juliaup is a tool to manage Julia versions and installations. It allows you to install multiple versions of Julia and switch between them easily.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"curl -fsSL https://install.julialang.org | sh # Linux and macOS","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"For Windows users, please open execute the following command in a cmd,","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"winget install julia -s msstore # Windows","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You can also install Juliaup directly from Windows Store.","category":"page"},{"location":"chap2/julia-setup/#For-users-suffering-from-the-slow-download-speed","page":"Setup Julia","title":"For users suffering from the slow download speed","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Network connectivity can be an issue for some users, especially for those who are in China. You may need to specify another server for installing Juliaup and Julia packages. To do so, execute the following command in your terminal before running the script above.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Linux and macOS","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"export JULIAUP_SERVER=https://mirror.nju.edu.cn/julia-releases/ # Linux & macOS\nexport JULIA_PKG_SERVER=https://mirrors.nju.edu.cn/julia","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Windows","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"$env:JULIAUP_SERVER=\"https://mirror.nju.edu.cn/julia-releases/\" # Windows\n$env:JULIA_PKG_SERVER=\"https://mirrors.nju.edu.cn/julia\"","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"An alternative approach is downloading the corresponding Julia binary from the Nanjing university mirror website. After installing the binary, please set the Julia binary path properly if you want to start a Julia REPL from a terminal, check this manual page to learn more.","category":"page"},{"location":"chap2/julia-setup/#Installing-Julia","page":"Setup Julia","title":"Installing Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To verify that Julia is installed, please open a new terminal and run the following command in your terminal.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"It should start a Julia REPL(Read-Eval-Print-Loop) session.\nIf you wish to install a specific version of Julia, please refer to the documentation.","category":"page"},{"location":"chap2/julia-setup/#Step-2:-Package-Management","page":"Setup Julia","title":"Step 2: Package Management","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julia has a mature eco-system for scientific computing.\nPkg is the built-in package manager for Julia.\nTo enter the package manager, press ] in the REPL.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"(Image: PackageMangement)","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"The environment is indicated by the (@v1.9).\nTo add a package, type add <package name>.\nTo exit the package manager press backspace key\nRead More","category":"page"},{"location":"chap2/julia-setup/#Step-3.-Configure-the-startup-file","page":"Setup Julia","title":"Step 3. Configure the startup file","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"First create a new file ~/.julia/config/startup.jl by executing the following commands ","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"mkdir -r ~/.julia/config touch ~/.julia/config/startup.jl","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You could open the file with your favourite editor and add the following content","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"try\n    using Revise\ncatch e\n    @warn \"fail to load Revise.\"\nend","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"The contents in the startup file is executed immediately after you open a new Julia session.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Then you need to install Revise, which is an Julia package that can greatly improve the using experience of Julia. To install Revise, open Julia REPL and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia> using Pkg; Pkg.add(\"Revise\")","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"If you don't know about startup.jl and where to find it, here is a good place for further information. ","category":"page"},{"location":"chap2/julia-setup/#More-Packages","page":"Setup Julia","title":"More Packages","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You may find more Julia packages here.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"As a final step, please verify your Julia configuration by openning a Julia REPL and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia> versioninfo()\nJulia Version 1.9.2\nCommit e4ee485e909 (2023-07-05 09:39 UTC)\nPlatform Info:\n  OS: macOS (arm64-apple-darwin22.4.0)\n  CPU: 10 × Apple M2 Pro\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, apple-m1)\n  Threads: 1 on 6 virtual cores\nEnvironment:\n  JULIA_NUM_THREADS = 1\n  JULIA_PROJECT = @.\n  JULIA_PKG_SERVER = http://cn-southeast.pkg.juliacn.com/ ","category":"page"},{"location":"chap2/julia-setup/#Step-4.-Download-an-editor:-VSCode","page":"Setup Julia","title":"Step 4. Download an editor: VSCode","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Install VSCode by downloading the correct binary for your platform from here. Open VSCode and open the Extensions tab on the left side-bar of the window, search Julia and install the most popular extension: julia-vscode","category":"page"},{"location":"chap2/julia-setup/#The-four-modes-of-Julia-REPL","page":"Setup Julia","title":"The four modes of Julia REPL","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"A Julia REPL has four modes,","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julian mode is the default mode that can interpret your Julia code.\nShell mode is the mode that you can run shell commands. Press ; in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"shell> date\nSun Nov  6 10:50:21 PM CST 2022","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the Backspace key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Package mode is the mode that you can manage packages. Press ] in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"(@v1.8) pkg> st\nStatus `~/.julia/environments/v1.8/Project.toml`\n  [295af30f] Revise v3.4.0","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the Backspace key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Help mode is the mode that you can access the docstrings of functions. Press ? in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"help> sum\n... docstring for sum ...","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the Backspace key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"read more...","category":"page"},{"location":"chap3/fft/#Fast-Fourier-transform","page":"Fast Fourier transform","title":"Fast Fourier transform","text":"","category":"section"},{"location":"chap1/terminal/#Get-a-Terminal!","page":"Get a Terminal!","title":"Get a Terminal!","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"You need to get a working terminal to follow the instructions in this book, because every cool guy needs a terminal.","category":"page"},{"location":"chap1/terminal/#Linux-operating-system","page":"Get a Terminal!","title":"Linux operating system","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Using Linux or macOS is the most straight-forward way to get a terminal. Just like Windows, IOS, and macOS, Linux is an operating system. In fact, Android, one of the most popular platforms on the planet, is powered by the Linux operating system. It is free to use, open source, widely used on clusters and good at automating your works. Linux kernel and Linux distribution are different concepts.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Linux kernel is started by Linus Torvalds in 1991.\nA Linux distribution is an operating system made from a software collection that includes the Linux kernel and, often, a package management system.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Linux distribution used in this course is Ubuntu. If you want to stick to Windows, you can use Windows Subsystem for Linux (WSL) to get a Linux terminal.","category":"page"},{"location":"chap1/terminal/#Shell-(or-Terminal)","page":"Get a Terminal!","title":"Shell (or Terminal)","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Although you can use a graphical user interface (GUI) to interact with your Linux distribution, you will find that the command line interface (CLI) is more efficient and powerful. The CLI is also known as the shell or terminal.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The shell is a program that takes commands from the keyboard and gives them to the operating system to perform. Zsh and Bash are two popular shell interpreters used in the Linux operating systems.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Bash is the default shell on most Linux distributions.\nZsh (with oh-my-zsh extension) is an extended version of the shell, with a more powerful command-line editing and completion system. It includes features like spelling correction and tab-completion, and it also supports plugins and themes.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"In Ubuntu, one can use Ctrl + Alt + T to open a shell. In a shell, we use","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"man command_name to get help information related to a command,\nCTRL-C to break a program and\nCTRL-D to exit a shell.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"To learn more about shell, please check:","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"MIT Open course: Missing semester\nGet started with the Linux command line and the Shell","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The following is a short list of bash commands that will be used frequently in this book.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"man     # an interface to the system reference manuals\n\nls      # list directory contents\ncd      # change directory\nmkdir   # make directories\nrm      # remove files or directories\npwd     # print name of current/working directory\n\necho    # display a line of text\ncat     # concatenate files and print on the standard output\n\nalias   # create an alias for a command\n\nlscpu   # display information about the CPU architecture\nlsmem   # list the ranges of available memory with their online status\n\ntop     # display Linux processes\nssh     # the OpenSSH remote login client\nvim     # Vi IMproved, a programmer's text editor\ngit     # the stupid content tracker\n\ntar     # an archiving utility","category":"page"},{"location":"chap1/terminal/#Editor-in-terminal-Vim","page":"Get a Terminal!","title":"Editor in terminal - Vim","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"To edit files in the terminal, you can use Vim - the default text editor in most Linux distributions. Vim has three primary modes, each tailored for specific tasks. The primary modes include","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Normal Mode, where users can navigate through the file and perform tasks like deleting lines or copying text; One can enter the normal mode by typing ESC;\nInsert Mode, where users can insert text as in conventional text editors; One can enter the insert mode by typing i in the normal mode;\nCommand Mode, where users input commands for tasks like saving files or searching; One can enter the command mode by typing : in the normal mode.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"A few commands are listed below to get you started with Vim.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"i       # input\n:w      # write\n:q      # quit\n:q!     # force quit without saving\n\nu       # undo\nCTRL-R  # redo","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"All the commands must be executed in the normal mode (press ESC if not). To learn more about Vim, please check this lecture.","category":"page"},{"location":"chap1/terminal/#Connect-to-the-remote-SSH","page":"Get a Terminal!","title":"Connect to the remote - SSH","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Secure Shell (SSH) protocol is a method for securely sending commands to a computer over an unsecured network. SSH uses cryptography to authenticate and encrypt connections between devices. It is widely used to:","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"push code to a remote git repository,\nlog into a remote machine and execute commands.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Consider you want to access a remote machine, e.g. the cluster of your university. You will be given a host name and a username. You can use the following command to log in to the remote machine.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh <username>@<hostname>","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"where <username> is the user's account name and <hostname> is the host name or IP of the target machine. You will get logged in after inputting the password.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Tips to make your life easier","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"It will be tedious to type the host name and user name everytime you want to login to the remote machine. You can setup the ~/.ssh/config file to make your life easier. The following is an example of the ~/.ssh/config file.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Host amat5315\n  HostName <hostname>\n  User <username>","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"where amat5315 is the alias of the host. After setting up the ~/.ssh/config, you can login to the remote machine by typing","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh amat5315","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"If you want to avoid typing the password everytime you login, you can use the command ","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh-keygen","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"to generate a pair of public and private keys, which will be stored in the ~/.ssh folder on the local machine. After setting up the keys, you can copy the public key to the remote machine by typing","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh-copy-id amat5315","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Try connecting to the remote machine again, you will find that you don't need to type the password anymore.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"note: How does an SSH key pair work?\nThe SSH key pair is a pair of asymmetric keys, one is the public key and the other is the private key. In the above example, the public key is uploaded to the remote machine and the private key is stored on the local machine. The public key can be shared with anyone, but the private key must be kept secret.To connect to a server, the server needs to know that you are the one who with the right to access it. To do so, the server will need to check if you have the private key that corresponds to the public key stored on the server. If you have the private key, you will be granted access to the server.The secret of the SSH key pair is that the public key can be used to encrypt a message that can only be decrypted by the private key, i.e. the public key is more like a lock and the private key is the key to unlock the lock. This is the foundation of the SSH protocol. So server can send you a message encrypted by your public key, and only you can decrypt it with your private key. This is how the server knows that you are the one who has the private key without actually sending the private key to the server.","category":"page"},{"location":"chap1/terminal/#Practice","page":"Get a Terminal!","title":"Practice","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"In the following example, we will use the ssh command to connect to the remote machine gpu and do some basic operations. If you don't have a remote machine, you can use your local machine to do the following operations.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"(base) ➜  ~ ssh gpu\nWelcome to Ubuntu 22.04.3 LTS (GNU/Linux 5.15.0-91-generic x86_64)\n...\n*** System restart required ***\nLast login: Tue Mar  5 06:20:05 2024 from 10.13.139.204\n(base) ➜  ~","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Then we switch to the jcode directory and create a directory test and a file README.md in the directory.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"(base) ➜  ~ ls     # list directory contents\nClusterManagement                 jcode       packages\nScientificComputingForPhysicists  miniconda3  software\n(base) ➜  ~ cd jcode   # change directory\n(base) ➜  jcode mkdir test # make directories\n(base) ➜  jcode cd test # change directory\n(base) ➜  test vim README.md # create a file and edit it","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"You will see the following screen after typing vim README.md. (Image: ) Type i to enter the insert mode and type some text, e.g. \"# Read me!\". Then type ESC to enter the normal mode and type :wq to save and quit the file.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"After returning to the terminal, you can type ls -l to check the file you just created.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"total 4\n-rw-rw-r-- 1 jinguoliu jinguoliu 11 Mar  5 06:30 README.md","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"You can also use the cat command to check the content of the file.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"(base) ➜  test cat README.md\n# Read me!","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Finally, you can press CTRL-D to exit the shell.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Enjoy your journey in the terminal!","category":"page"},{"location":"chap3/lu/#LU-Decomposition","page":"LU Decomposition","title":"LU Decomposition","text":"","category":"section"},{"location":"chap3/lu/#Forward-substitution","page":"LU Decomposition","title":"Forward-substitution","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Solving tridiagonal linear equation https://en.wikipedia.org/wiki/Triangular_matrix","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Lx = b","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"where L in mathbbR^ntimes n is a lower triangular matrix defined as","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"L = left(beginmatrix\nl_11  0  ldots  0\nl_21  l_22  ldots  0\nvdots  vdots  ddots  vdots\nl_n1  l_n2  ldots  l_nn\nendmatrixright)","category":"page"},{"location":"chap3/lu/#Algorithm:-Forward-Substitution-for-Lower-Triangular-System","page":"LU Decomposition","title":"Algorithm: Forward-Substitution for Lower Triangular System","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Forward substitution is an algorithm used to solve a system of linear equations with a lower triangular matrix. It involves solving for the unknowns in a forward direction, starting from the first equation and moving towards the last. Here's an example of forward substitution algorithm in the matrix form:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Consider the following system of lower triangular linear equations:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"L = left(beginmatrix\n3  0  0\n2  5  0\n1  4  2\nendmatrixright)\nleft(beginmatrix\nx_1\nx_2\nx_3\nendmatrixright) = \nleft(beginmatrix\n9\n12\n13\nendmatrixright)","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"To solve for x_1, x_2, and x_3 using forward substitution, we start with the first equation:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"3x_1 + 0x_2 + 0x_3 = 9","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Solving for x_1, we get:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"x_1 = 3","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Substituting x = 3 into the second equation (row), we get:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"2(3) + 5x_2 + 0x_3 = 12","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Solving for x_2, we get:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"x_2 = (12 - 6)  5 = 12","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Substituting x = 3 and x_2 = 12 into the third equation (row), we get:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"1(3) + 4(12) + 2x_3 = 13","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Solving for x_3, we get:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"x_3 = (13 - 3 - 4(12))  2 = 15","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Therefore, the solution to the system of equations is:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"x = left(beginmatrix\n3\n12\n15\nendmatrixright)","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"It can be summarized to the following algorithm","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"x_1 = b_1l_11 x_i = left(b_i - sum_j=1^i-1l_ijx_jright)l_ii i=2  n","category":"page"},{"location":"chap3/lu/#Back-substitution","page":"LU Decomposition","title":"Back-substitution","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"We implement the above algorithm in Julia language.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"function back_substitution!(l::AbstractMatrix, b::AbstractVector)\n\tn = length(b)\n\t@assert size(l) == (n, n) \"size mismatch\"\n\tx = zero(b)\n\t# loop over columns\n\tfor j = 1:n\n\t\t# stop if matrix is singular\n\t\tif iszero(l[j, j])\n\t\t\terror(\"The lower triangular matrix is singular!\")\n\t\tend\n\t\t# compute solution component\n\t\tx[j] = b[j] / l[j, j]\n\t\tfor i = j+1:n\n\t\t\t# update right hand side\n\t\t\tb[i] = b[i] - l[i, j] * x[j]\n\t\tend\n\tend\n\treturn x\nend","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"We can write a test for this algorithm.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"@testset \"back substitution\" begin\n\t# create a random lower triangular matrix\n\tl = tril(randn(4, 4))\n\t# target vector\n\tb = randn(4)\n\t# solve the linear equation with our algorithm\n\tx = back_substitution!(l, copy(b))\n\t@test l * x ≈ b\n\n\t# The Julia's standard library `LinearAlgebra` contains a native implementation.\n\tx_native = LowerTriangular(l) \\ b\n\t@test l * x_native ≈ b\nend","category":"page"},{"location":"chap3/lu/#Gaussian-elimination","page":"LU Decomposition","title":"Gaussian elimination","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"LU decomposition is a method for solving linear equations that involves breaking down a matrix into lower and upper triangular matrices. The LU decomposition of a matrix A is represented as A = LU, where L is a lower triangular matrix and U is an upper triangular matrix.","category":"page"},{"location":"chap3/lu/#The-elementary-elimination-matrix","page":"LU Decomposition","title":"The elementary elimination matrix","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"An elementary elimination matrix is a matrix that is used in the process of Gaussian elimination to transform a system of linear equations into an equivalent system that is easier to solve. It is a square matrix that is obtained by performing a single elementary row operation on the identity matrix.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"(M_k)_ij = begincases\n\tdelta_ij  i= j\n\t- a_ika_kk  i  j land j = k \n    0  rm otherwise\nendcases","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Let A = (a_ij) be a square matrix of size n times n. The kth elementary elimination matrix for it is defined as","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"M_k = left(beginmatrix\n\n1  ldots  0  0  0  ldots  0\nvdots  ddots  vdots  vdots  vdots  ddots  vdots\n0  ldots  1  0  0  ldots  0\n0  ldots  0  1  0  ldots  0\n0  ldots  0  -m_k+1  1  ldots  0\nvdots  ddots  vdots  vdots  vdots  ddots  vdots\n0  ldots  0  -m_n  0  ldots  1\n\nendmatrixright)","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"where m_i = a_ika_kk.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"By applying this elementary elimination matrix M_1 on A, we can obtain a new matrix with the a_i1 = 0 for all i1.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"M_1 A = left(beginmatrix\na_11  a_12  a_13  ldots  a_1n\n0  a_22  a_23  ldots  a_2n\n0  a_32  a_33  ldots  a_3n\nvdots  vdots  vdots  ddots  vdots\n0  a_n2  a_n3  ldots  a_nn\nendmatrixright)","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"For k=12ldotsn, apply M_k on A. We will have an upper triangular matrix.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"U = M_n-1ldots M_1 A","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Since M_k is reversible (as we will show below), we have","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"beginalign\nA = LU\nL = M_1^-1 M_2^-1 ldots M_n-1^-1\nendalign","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"\"","category":"page"},{"location":"chap3/lu/#Properties-of-elementary-elimination-matrices","page":"LU Decomposition","title":"Properties of elementary elimination matrices","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Its inverse can be computed in O(n) time","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"M_k^-1 = 2I - M_k","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"The multiplication of two elementary matrices can be computed in O(n) time","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"M_k M_k  k = M_k + M_k - I","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"\"","category":"page"},{"location":"chap3/lu/#Coding:-Properties-of-elimination-matrices\"","page":"LU Decomposition","title":"Coding: Properties of elimination matrices\"","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"A3 = [1 2 2; 4 4 2; 4 6 4]\n\nfunction elementary_elimination_matrix(A::AbstractMatrix{T}, k::Int) where T\n\tn = size(A, 1)\n\t@assert size(A, 2) == n\n\t# create Elementary Elimination Matrices\n\tM = Matrix{Float64}(I, n, n)\n\tfor i=k+1:n\n\t\tM[i, k] =  -A[i, k] ./ A[k, k]\n\tend\n\treturn M\nend","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"The elimination","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"elementary_elimination_matrix(A3, 1)\nelementary_elimination_matrix(A3, 1) * A3","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"The inverse","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"inv(elementary_elimination_matrix(A3, 1))","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"The multiplication","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"elementary_elimination_matrix(A3, 2)\ninv(elementary_elimination_matrix(A3, 1)) * inv(elementary_elimination_matrix(A3, 2))","category":"page"},{"location":"chap3/lu/#LU-Factorization-by-Gaussian-Elimination\"","page":"LU Decomposition","title":"LU Factorization by Gaussian Elimination\"","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"A naive implementation of elimentary elimination matrix is as follows","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"function lufact_naive!(A::AbstractMatrix{T}) where T\n\tn = size(A, 1)\n\t@assert size(A, 2) == n\n\tM = Matrix{T}(I, n, n)\n\tfor k=1:n-1\n\t\tm = elementary_elimination_matrix(A, k)\n\t\tM = M * inv(m)\n\t\tA .= m * A\n\tend\n\treturn M, A\nend\n\nlufact_naive!(copy(A3))\n\n@testset \"naive LU factorization\" begin\n\tA = [1 2 2; 4 4 2; 4 6 4]\n\tL, U = lufact_naive!(copy(A))\n\t@test L * U ≈ A\nend","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"The above implementation has time complexity O(n^4) since we did not use the sparsity of elimentary elimination matrix. A better implementation that gives O(n^3) time complexity is as follows.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"function lufact!(a::AbstractMatrix)\n\tn = size(a, 1)\n\t@assert size(a, 2) == n \"size mismatch\"\n\tm = zero(a)\n\tm[1:n+1:end] .+= 1\n\t# loop over columns\n\tfor k=1:n-1\n\t\t# stop if pivot is zero\n\t\tif iszero(a[k, k])\n\t\t\terror(\"Gaussian elimination fails!\")\n\t\tend\n\t\t# compute multipliers for current column\n\t\tfor i=k+1:n\n\t\t\tm[i, k] = a[i, k] / a[k, k]\n\t\tend\n\t\t# apply transformation to remaining sub-matrix\n\t\tfor j=k+1:n\n\t\t\tfor i=k+1:n\n\t\t\t\ta[i,j] -= m[i,k] * a[k, j]\n\t\t\tend\n\t\tend\n\tend\n\treturn m, triu!(a)\nend\n\nlufact(a::AbstractMatrix) = lufact!(copy(a))\n\n@testset \"LU factorization\" begin\n\ta = randn(4, 4)\n\tL, U = lufact(a)\n\t@test istril(L)\n\t@test istriu(U)\n\t@test L * U ≈ a\nend\n\nA4 = randn(4, 4)\n\nlufact(A4)","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Julia language has a much better implementation in the standard library LinearAlgebra.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"julia_lures = lu(A4, NoPivot())  # the version we implemented above has no pivot\n\njulia_lures.U\n\ntypeof(julia_lures)\n\nfieldnames(julia_lures |> typeof)","category":"page"},{"location":"chap3/lu/#Issue:-how-to-handle-small-diagonal-entries?","page":"LU Decomposition","title":"Issue: how to handle small diagonal entries?","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"The above Gaussian elimination process is not stable if any diagonal entry in A has a value that close to zero.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"@bind ϵ Slider(-20:0.01:0.0; default=-2, show_value=true)\n\nsmall_diagonal_matrix = [10^(ϵ) 1; 1 1]\n\nlures = lufact(small_diagonal_matrix)","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"This issue is not always related to the rank deficiency (or ill-condition). A remedy to this issue is to permute the rows of A before factorizing it. For example:","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"lufact(small_diagonal_matrix[end:-1:1, :])","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"This technique is called pivoting.","category":"page"},{"location":"chap3/lu/#Pivoting-technique","page":"LU Decomposition","title":"Pivoting technique","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"LU factoriazation (or Gaussian elimination) with pivoting is defined as","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"P A = L U","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"where P is a permutation matrix.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Pivoting in Gaussian elimination is the process of selecting a pivot element in a matrix and then using it to eliminate other elements in the same column or row. The pivot element is chosen as the largest absolute value in the column, and its row is swapped with the row containing the current element being eliminated if necessary. This is done to avoid division by zero or numerical instability, and to ensure that the elimination process proceeds smoothly. Pivoting is an important step in Gaussian elimination, as it ensures that the resulting matrix is in reduced row echelon form and that the solution to the system of equations is accurate.\"","category":"page"},{"location":"chap3/lu/#Gaussian-Elimination-process-with-Partial-Pivoting","page":"LU Decomposition","title":"Gaussian Elimination process with Partial Pivoting","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Let A=(a_ij) be a square matrix of size ntimes n. The Gaussian elimination process with partial pivoting can be represented as","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"M_n-1P_n-1ldots M_2P_2M_1P_1 A = U","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"Here we emphsis that P_k and M_jk commute.","category":"page"},{"location":"chap3/lu/#LU-Factoriazation-by-Gaussian-Elimination-with-Partial-Pivoting","page":"LU Decomposition","title":"LU Factoriazation by Gaussian Elimination with Partial Pivoting","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"A Julia implementation of the Gaussian elimination with partial pivoting is","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"function lufact_pivot!(a::AbstractMatrix)\n\tn = size(a, 1)\n\t@assert size(a, 2) == n \"size mismatch\"\n\tm = zero(a)\n\tP = collect(1:n)\n\t# loop over columns\n\t@inbounds for k=1:n-1\n\t\t# search for pivot in current column\n\t\tval, p = findmax(x->abs(a[x, k]), k:n)\n\t\tp += k-1\n\t\t# find index p such that |a_{pk}| ≥ |a_{ik}| for k ≤ i ≤ n\n\t\tif p != k\n\t\t\t# swap rows k and p of matrix A\n\t\t\tfor col = 1:n\n\t\t\t\ta[k, col], a[p, col] = a[p, col], a[k, col]\n\t\t\tend\n\t\t\t# swap rows k and p of matrix M\n\t\t\tfor col = 1:k-1\n\t\t\t\tm[k, col], m[p, col] = m[p, col], m[k, col]\n\t\t\tend\n\t\t\tP[k], P[p] = P[p], P[k]\n\t\tend\n\t\tif iszero(a[k, k])\n\t\t\t# skip current column if it's already zero\n\t\t\tcontinue\n\t\tend\n\t\t# compute multipliers for current column\n\t\tm[k, k] = 1\n\t\tfor i=k+1:n\n\t\t\tm[i, k] = a[i, k] / a[k, k]\n\t\tend\n\t\t# apply transformation to remaining sub-matrix\n\t\tfor j=k+1:n\n\t\t\takj = a[k, j]\n\t\t\tfor i=k+1:n\n\t\t\t\ta[i,j] -= m[i,k] * akj\n\t\t\tend\n\t\tend\n\tend\n\tm[n, n] = 1\n\treturn m, triu!(a), P\nend\n\n@testset \"lufact with pivot\" begin\n\tn = 5\n\tA = randn(n, n)\n\tL, U, P = lufact_pivot!(copy(A))\n\tpmat = zeros(Int, n, n)\n\tsetindex!.(Ref(pmat), 1, 1:n, P)\n\t@test L ≈ lu(A).L\n\t@test U ≈ lu(A).U\n\t@test pmat * A ≈ L * U\nend","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"If you are interested in knowing the performance of our implementation, please check the following check box.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"n = 200\nA = randn(n, n)\n@benchmark lufact_pivot!($A)\n\nn = 200\nA = randn(n, n)\n@benchmark lu($A)","category":"page"},{"location":"chap3/lu/#Complete-pivoting","page":"LU Decomposition","title":"Complete pivoting","text":"","category":"section"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"The complete pivoting also allows permuting columns. It produces better numerical stability but is also harder to implement. In most practical using cases, partial pivoting is good enough.","category":"page"},{"location":"chap3/lu/","page":"LU Decomposition","title":"LU Decomposition","text":"P A Q = L U","category":"page"},{"location":"chap3/tensors/#Tensor-Operations","page":"Tensor Operations","title":"Tensor Operations","text":"","category":"section"},{"location":"chap3/tensors/#Einsum/Tensor-network","page":"Tensor Operations","title":"Einsum/Tensor network","text":"","category":"section"},{"location":"chap3/tensors/","page":"Tensor Operations","title":"Tensor Operations","text":"using OMEinsum\n\nA = randn(1000, 1000, 1000);","category":"page"},{"location":"chap3/tensors/#Optimized-tensor-contractions","page":"Tensor Operations","title":"Optimized tensor contractions","text":"","category":"section"},{"location":"chap3/tensors/#Bayesian-inference","page":"Tensor Operations","title":"Bayesian inference","text":"","category":"section"},{"location":"chap3/sensitivity/#Sensitivity-Analysis","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Sensitivity analysis in linear algebra is the study of how changes in the input data or parameters of a linear system affect the output or solution of the system. It involves analyzing the sensitivity of the solution to changes in the coefficients of the system, the right-hand side vector, or the constraints of the problem. Sensitivity analysis can be used to determine the effect of small changes in the input data on the optimal solution, to identify critical parameters that affect the solution, and to assess the robustness of the solution to uncertainties or variations in the input data.","category":"page"},{"location":"chap3/sensitivity/#Issue:-An-Ill-Conditioned-Matrix","page":"Sensitivity Analysis","title":"Issue: An Ill Conditioned Matrix","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"An ill conditioned matrix may produce unreliable result, or the output is very sensitive to the input. The following is an example of a matrix close to singular.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"A = left(beginmatrix\n0913  0659\n0457  0330\nendmatrix\nright)","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"ill_conditioned_matrix = [0.913 0.659; 0.457 0.330]\n\nlures2 = lufact(ill_conditioned_matrix)\n\nlures2\n\ncond(ill_conditioned_matrix)","category":"page"},{"location":"chap3/sensitivity/#The-relative-error","page":"Sensitivity Analysis","title":"The relative error","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The relevant error in floating number system is the relative error.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Absolute error: x - hat x\nRelative error: fracx - hat xx","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"where cdot is a measure of size.","category":"page"},{"location":"chap3/sensitivity/#Numeric-experiment:-Floating-point-numbers-have-\"constant\"-relative-error","page":"Sensitivity Analysis","title":"Numeric experiment: Floating point numbers have \"constant\" relative error","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"eps(Float64)","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"n = 1000\nreltol = zeros(2n+1)\nfor i=-n:n\n    f = 2.0^i\n    reltol[i+n+1] = log10(eps(f)) - log10(f)\nend\nplot(-n:n, reltol; label=\"relative error\")","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"eps(1.0)/1.0\n\neps(2.0)/2.0\n\neps(sqrt(2))/sqrt(2)","category":"page"},{"location":"chap3/sensitivity/#(Relative)-Condition-Number","page":"Sensitivity Analysis","title":"(Relative) Condition Number","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Condition number is a measure of the sensitivity of a mathematical problem to changes or errors in the input data. It is a way to quantify how much the output of a function or algorithm can vary due to small changes in the input. A high condition number indicates that the problem is ill-conditioned, meaning that small errors in the input can lead to large errors in the output. A low condition number indicates that the problem is well-conditioned, meaning that small errors in the input have little effect on the output.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"In short, the (relative) condition number of an operation f with input x measures the relative error amplication power of f with input x, which is formally defined as","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"lim _varepsilon rightarrow 0^+sup _delta xleq varepsilon frac delta f(x)f(x)delta xx","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Quiz 1: What is the condition number of","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"y = exp(x)","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Quiz 2: What is the condition number of","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"a + b","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"With the obtained result, show why we should avoid subtracting two big floating point numbers?","category":"page"},{"location":"chap3/sensitivity/#Measuring-the-size-vectors-and-matrices\"","page":"Sensitivity Analysis","title":"Measuring the size vectors and matrices\"","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The vector p-norm is formally defined as\"","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"v_p = left(sum_iv_i^pright)^1p","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Similarly, the matrix p-norm is formally defined as","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"A_p = max_xneq 0 fracAx_px_p","category":"page"},{"location":"chap3/sensitivity/#Examples:-Vector-and-Matrix-Norms\"","page":"Sensitivity Analysis","title":"Examples: Vector and Matrix Norms\"","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"norm([3, 4], 2)\n\nnorm([3, 4], 1)\n\nnorm([3, 4], Inf)","category":"page"},{"location":"chap3/sensitivity/#l0-norm-is-not-a-true-norm","page":"Sensitivity Analysis","title":"l0 norm is not a true norm","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"norm([3, 4], 0)\n\nnorm([3, 0], 0)\n\nmat = randn(2, 2)\n\nopnorm(mat, 1)\n\nopnorm(mat, Inf)\n\nopnorm(mat, 2)\n\nopnorm(mat, 0)\n\ncond(mat)","category":"page"},{"location":"chap3/sensitivity/#Condition-Number-of-a-Linear-Operator\"","page":"Sensitivity Analysis","title":"Condition Number of a Linear Operator\"","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The condition number of a linear system Ax = b is defined as","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"rm cond(A) = A A^-1","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Using the defintion of condition number, we have","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"beginalign\nrm cond(A x)=lim _varepsilon rightarrow 0^+sup _delta xleq varepsilon frac delta (Ax)A xdelta xx\n=lim _varepsilon rightarrow 0^+sup _delta xleq varepsilon frac Adelta xxdelta xAx\nendalign","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Let y = Ax, we have","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"beginalign\nrm cond(A x)=lim _varepsilon rightarrow 0^+sup _delta xleq varepsilon frac Adelta xA^-1ydelta xy\n=AfracA^-1yy\nendalign","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Suppose we want to get an upper bound for any input x, then using the definiton of matrix norm, we have","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"rm cond(A) = Asup_y fracA^-1yy = A A^-1","category":"page"},{"location":"chap3/sensitivity/#Numeric-experiment:-Numeric-experiment-on-condition-number","page":"Sensitivity Analysis","title":"Numeric experiment: Numeric experiment on condition number","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"We randomly generate matrices of size 10times 10 and show the condition number approximately upper bounds the numeric error amplification factor of a linear equation solver.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"n = 1000\np = 2\nerrors = zeros(n)\nconds = zeros(n)\nfor k = 1:n\n    A = rand(10, 10)\n    b = rand(10)\n    dx = A \\ b\n    sx = Float32.(A) \\ Float32.(b)\n    errors[k] = (norm(sx - dx, p)/norm(dx, p)) / (norm(b-Float32.(b), p)/norm(b, p))\n    conds[k] = cond(A, p)\nend\nplt = plot(conds, conds; label=\"condition number\", xlim=(1, 10000), ylim=(1, 10000), xscale=:log10, yscale=:log10)\nscatter!(plt, conds, errors; label=\"samples\")","category":"page"},{"location":"chap3/sensitivity/#Positive-definite-symmetric-matrix\"","page":"Sensitivity Analysis","title":"Positive definite symmetric matrix\"","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"(Real) Symmetric: A = A^T,\nPositive definite: x^T A x  0 for all x neq 0.","category":"page"},{"location":"chap3/sensitivity/#Cholesky-decomposition","page":"Sensitivity Analysis","title":"Cholesky decomposition","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Cholesky decomposition is a method of decomposing a positive-definite matrix into a product of a lower triangular matrix and its transpose. It is named after the mathematician André-Louis Cholesky, who developed the method in the early 1900s. The Cholesky decomposition is useful in many areas of mathematics and science, including linear algebra, numerical analysis, and statistics. It is often used in solving systems of linear equations, computing the inverse of a matrix, and generating random numbers with a given covariance matrix. The Cholesky decomposition is computationally efficient and numerically stable, making it a popular choice in many applications.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Given a positive definite symmetric matrix Ain mathbbR^ntimes n, the Cholesky decomposition is formally defined as","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"A = LL^T","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"where L is an upper triangular matrix.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"The implementation of Cholesky decomposition is similar to LU decomposition.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"function chol!(a::AbstractMatrix)\n\tn = size(a, 1)\n\t@assert size(a, 2) == n\n\tfor k=1:n\n\t\ta[k, k] = sqrt(a[k, k])\n\t\tfor i=k+1:n\n\t\t\ta[i, k] = a[i, k] / a[k, k]\n\t\tend\n\t\tfor j=k+1:n\n\t\t\tfor i=k+1:n\n\t\t\t\ta[i,j] = a[i,j] - a[i, k] * a[j, k]\n\t\t\tend\n\t\tend\n\tend\n\treturn a\nend\n\n@testset \"cholesky\" begin\n\tn = 10\n\tQ, R = qr(randn(10, 10))\n\ta = Q * Diagonal(rand(10)) * Q'\n\tL = chol!(copy(a))\n\t@test tril(L) * tril(L)' ≈ a\n\t# cholesky(a) in Julia\nend","category":"page"},{"location":"chap3/sensitivity/#Assignments","page":"Sensitivity Analysis","title":"Assignments","text":"","category":"section"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Get the relative condition number of division operation ab.\nClassify each of the following matrices as well-conditioned or ill-conditioned:","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"(a) left(beginmatrix10^10  0 0  10^-10endmatrixright)","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"(b) left(beginmatrix10^10  0 0  10^10endmatrixright)","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"(c) left(beginmatrix10^-10  0 0  10^-10endmatrixright)","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"(d) left(beginmatrix1  2 2  4endmatrixright)","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Implement the Gauss-Jordan elimination algorithm to compute matrix inverse. In the following example, we first create an augmented matrix (A  I). Then we apply the Gauss-Jordan elimination matrices on the left. The final result is stored in the augmented matrix as (I A^-1).","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"(Image: )","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Task: Please implement a function gauss_jordan that computes the inverse for a matrix at any size. Please also include the following test in your submission.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"@testset \"Gauss Jordan\" begin\n\tn = 10\n\tA = randn(n, n)\n\t@test gauss_jordan(A) * A ≈ Matrix{Float64}(I, n, n)\nend","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Simular to computing Guassian elimination with elementary elimination matrices, computing the inverse can be done by repreatedly applying the Guass-Jordan elimination matrix and convert the target matrix to identity.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"SN_nN_n-1ldots N_1 A = I","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Then","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"A^-1 = SN_nN_n-1ldots N_1","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"Here, the Gauss-Jordan elimination matrix N_k eliminates the kth column except the diagonal element a_kk.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"N_k = left(beginmatrix\n\n1  ldots  0  -m_1  0  ldots  0\nvdots  ddots  vdots  vdots  vdots  ddots  vdots\n0  ldots  1  -m_k-1  0  ldots  0\n0  ldots  0  1  0  ldots  0\n0  ldots  0  -m_k+1  1  ldots  0\nvdots  ddots  vdots  vdots  vdots  ddots  vdots\n0  ldots  0  -m_n  0  ldots  1\n\nendmatrixright)","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"where m_i = a_ia_k.","category":"page"},{"location":"chap3/sensitivity/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"S is a diagonal matrix.","category":"page"},{"location":"chap2/julia-type/#Types-and-Multiple-dispatch","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"","category":"section"},{"location":"chap2/julia-type/#Julia-Types","page":"Types and Multiple-dispatch","title":"Julia Types","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Julia has rich type system, which is not limited to the primitive types that supported by the hardware. The type system is the key to the multiple dispatch feature of Julia.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"As an example, let us consider the type for complex numbers.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Complex{Float64}","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where Float64 is the type parameter of Complex. Type parameters are a part of a type, without which the type is not fully specified. A fully specified type is called a concrete type, which has a fixed memory layout and can be instantiated in memory. For example, the Complex{Float64} consists of two fields of type Float64, which are the real and imaginary parts of the complex number.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fieldnames(Complex{Float64})\nfieldtypes(Complex{Float64})","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Extending the example, we can define the type for a matrix of complex numbers.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Array{Complex{Float64}, 2}","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Array type has two type parameters, the first one is the element type and the second one is the dimension of the array.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"One can get the type of value with typeof function.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"typeof(1+2im)\ntypeof(randn(Complex{Float64}, 2, 2))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Then, what the type of a type?","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"typeof(Complex{Float64})","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There is a very special type: Tuple, which is different from regular types in the following ways:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Tuple types may have any number of parameters.\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore Tuple{Any} is considered an abstract type, and tuple types are only concrete if their parameters are.\nTuples do not have field names; fields are only accessed by index.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"tp = (1, 2.0, 'c')\ntypeof(tp)\ntp[2]","category":"page"},{"location":"chap2/julia-type/#Multiple-dispatch","page":"Types and Multiple-dispatch","title":"Multiple dispatch","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch is a feature of some programming languages in which a function or method can be dynamically dispatched based on the run-time type. The dispatch is the process of selecting the method to invoke based on the type of the arguments.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We first define of an abstract type AbstractAnimal with the keyword abstract type:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"abstract type AbstractAnimal{L} end","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where the type parameter L stands for the number of legs. Defining the number of legs as a type parameter or a field of a concrete type is a design choice. Providing more information in the type system can help the compiler to optimize the code, but it can also make the compiler generate more code.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Abstract types can have subtypes. In the following we define a concrete subtype type Dog with 4 legs, which is a subtype of AbstractAnimal{4}.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Dog <: AbstractAnimal{4}\n\tcolor::String\nend","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where <: is the symbol for sybtyping， A <: B means A is a subtype of B. Concrete types can have fields, which are the data members of the type. However, they can not have subtypes.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Similarly, we define a Cat with 4 legs, a Cock with 2 legs and a Human with 2 legs.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Cat <: AbstractAnimal{4}\n\tcolor::String\nend\n\nstruct Cock <: AbstractAnimal{2}\n\tgender::Bool\nend\n\nstruct Human{FT <: Real} <: AbstractAnimal{2}\n\theight::FT\n\tfunction Human(height::T) where T <: Real\n\t\tif height <= 0 || height > 300\n\t\t\terror(\"The tall of a Human being must be in range 0~300, got $(height)\")\n\t\tend\n\t\treturn new{T}(height)\n\tend\nend","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Here, the Human type has its own constructor. The new function is the default constructor.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define a fall back method fight on the abstract type AbstractAnimal","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(a::AbstractAnimal, b::AbstractAnimal) = \"draw\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where :: is a type assertion. This function will be invoked if two subtypes of AbstractAnimal are fed into the function fight and no more explicit methods are defined.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define many more explicit methods with the same name.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(dog::Dog, cat::Cat) = \"win\"\nfight(hum::Human, a::AbstractAnimal) = \"win\"\nfight(hum::Human, a::Union{Dog, Cat}) = \"loss\"\nfight(hum::AbstractAnimal, a::Human) = \"loss\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where Union{Dog, Cat} is a union type. It is a type that can be either Dog or Cat. Union types are not concrete since they do not have a fixed memory layout, meanwhile, they can not be subtyped! Here, we defined 5 methods for the function fight. However, defining too many methods for the same function can be dangerous. You need to be careful about the ambiguity error!","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(Human(170), Human(180))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"It makes sense because we claim Human wins any other animals, but we also claim any animal losses to Human. When it comes to two Humans, the two functions are equally valid. To resolve the ambiguity, we can define a new method for the function fight as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(hum::Human{T}, hum2::Human{T}) where T<:Real = hum.height > hum2.height ? \"win\" : \"loss\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Now, we can test the function fight with different combinations of animals.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(Cock(true), Cat(\"red\"))\nfight(Dog(\"blue\"), Cat(\"white\"))\nfight(Human(180), Cat(\"white\"))\nfight(Human(170), Human(180))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Quiz: How many method instances are generated for fight so far?","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> methodinstances(fight)","category":"page"},{"location":"chap2/julia-type/#Example:-Julia-number-system","page":"Types and Multiple-dispatch","title":"Example: Julia number system","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The Julia type system is a tree, and Any is the root of type tree, i.e. it is a super type of any other type. The Number type is the root type of Julia number system, which is also a subtype of Any.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Number <: Any","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The type tree rooted on Number looks like:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Number\n├─ Base.MultiplicativeInverses.MultiplicativeInverse{T}\n│  ├─ Base.MultiplicativeInverses.SignedMultiplicativeInverse{T<:Signed}\n│  └─ Base.MultiplicativeInverses.UnsignedMultiplicativeInverse{T<:Unsigned}\n├─ Complex{T<:Real}\n├─ Real\n│  ├─ AbstractFloat\n│  │  ├─ BigFloat\n│  │  ├─ Float16\n│  │  ├─ Float32\n│  │  └─ Float64\n│  ├─ AbstractIrrational\n...","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There are utilities to analyze the type tree:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"using InteractiveUtils # hide\nsubtypes(Number)\nsupertype(Float64)\nAbstractFloat <: Real","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The leaf nodes of the type tree are called concrete types. They are the types that can be instantiated in memory. Among the concrete types, there are primitive types and composite types. Primitive types are built into the language, such as Int64, Float64, Bool, and Char, while composite types are built on top of primitive types, such as Dict, Complex and the user-defined types.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The list of primitive types","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end","category":"page"},{"location":"chap2/julia-type/#Extending-the-number-system-a-comparison-with-object-oriented-programming","page":"Types and Multiple-dispatch","title":"Extending the number system - a comparison with object-oriented programming","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Extending the number system in Julia is much easier than in object-oriented languages like Python. In the following example, we show how to implement addition operation of a user defined class in Python (feel free to skip if you do not know Python).","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class X:\n  def __init__(self, num):\n    self.num = num\n\n  def __add__(self, other_obj):\n    return X(self.num+other_obj.num)\n\n  def __radd__(self, other_obj):\n    return X(other_obj.num + self.num)\n\n  def __str__(self):\n    return \"X = \" + str(self.num)\n\nclass Y:\n  def __init__(self, num):\n    self.num = num\n\n  def __radd__(self, other_obj):\n    return Y(self.num+other_obj.num)\n\n  def __str__(self):\n    return \"Y = \" + str(self.num)\n\nprint(X(3) + Y(5))\n\nprint(Y(3) + X(5))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Here, we implemented the addition operation of two classes X and Y. The __add__ method is called when the + operator is used with the object on the left-hand side, while the __radd__ method is called when the object is on the right-hand side. The output is as follows:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"X = 8\nX = 8","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"It turns out the __radd__ method of Y is not called at all. This is because the __radd__ method is only called when the object on the left-hand side does not have the __add__ method by some artifical rules.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Implement addition in Julian style is much easier. We can define the addition operation of two types X and Y as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct X{T} <: Number\n\tnum::T\nend\n\nstruct Y{T} <: Number\n\tnum::T\nend\n\nBase.:(+)(a::X, b::Y) = X(a.num + b.num);\n\nBase.:(+)(a::Y, b::X) = X(a.num + b.num);\n\nBase.:(+)(a::X, b::X) = X(a.num + b.num);\n\nBase.:(+)(a::Y, b::Y) = Y(a.num + b.num);","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch seems to be more expressive than object-oriented programming.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Now, supposed you want to extend this method to a new type Z. In python, he needs to define a new class Z as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class Z:\n  def __init__(self, num):\n    self.num = num\n\n  def __add__(self, other_obj):\n    return Z(self.num+other_obj.num)\n\n  def __radd__(self, other_obj):\n    return Z(other_obj.num + self.num)\n\n  def __str__(self):\n    return \"Z = \" + str(self.num)\n\nprint(X(3) + Z(5))\n\nprint(Z(3) + X(5))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The output is as follows:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"X = 8\nZ = 8","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"No matter how hard you try, you can not make the __add__ method of Z to be called when the object is on the left-hand side. In Julia, this is not a problem at all. We can define the addition operation of Z as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Z{T} <: Number\n    num::T\nend\nBase.:(+)(a::X, b::Z) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::X) = Z(a.num + b.num);\nBase.:(+)(a::Y, b::Z) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::Y) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::Z) = Z(a.num + b.num);\nX(3) + Y(5)\nY(3) + X(5)\nX(3) + Z(5)\nZ(3) + Y(5)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There is a deeper reason why multiple dispatch is more expressive than object-oriented programming. The Julia function space is exponentially large! If a function f has k parameters, and the module has t types, there can be t^k methods for the function f:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"f(x::T1, y::T2, z::T3...)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Exponential function space allows us to specify the behavior of a function in a very fine-grained way. However, in an object-oriented language like Python, the function space is only linear to the number of classes.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class T1:\n    def f(self, y, z, ...):\n        self.num = num\n","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The behavior of method f is completely determined by the first argument self, which means object-oriented programming is equivalent to single dispatch.","category":"page"},{"location":"chap2/julia-type/#Example:-Computing-Fibonacci-number-at-compile-time","page":"Types and Multiple-dispatch","title":"Example: Computing Fibonacci number at compile time","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The Fibonacci number has a recursive definition:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"using BenchmarkTools\nfib(x::Int) = x <= 2 ? 1 : fib(x-1) + fib(x-2)\naddup(x::Int, y::Int) = x + y","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> @btime fib(40)\n  278.066 ms (0 allocations: 0 bytes)\n102334155","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Oops, it is really slow. There is definitely a better way to calculate the Fibonacci number, but let us stick to this recursive implementation for now.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"If you know the Julia type system, you can implement the Fibonacci number in a zero cost way. The trick is to use the type system to calculate the Fibonacci number at compile time. There is a type Val defined in the Base module, which is just a type with a type parameter. The type parameter can be a number:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Val(3.0)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define the addition operation of Val as the addition of the type parameters.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"addup(::Val{x}, ::Val{y}) where {x, y} = Val(x + y)\naddup(Val(5), Val(7))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Finally, we can define the Fibonacci number in a zero cost way.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fib(::Val{x}) where x = x <= 2 ? Val(1) : addup(fib(Val(x-1)), fib(Val(x-2)))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> @btime fib(Val(40))\n  0.792 ns (0 allocations: 0 bytes)\nVal{102334155}()","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Wow, it computes in no time! However, this trick is not recommended in the Julia performance tips. This implementation simply transfers the run-time computation to the compile time. On the other hand, we find the compiling time of the function fib is much shorter than the run-time. The recursive form turns out to be optimized away by the Julia compiler. But still, it is not recommended to abuse the type system.","category":"page"},{"location":"chap2/julia-type/#Summary","page":"Types and Multiple-dispatch","title":"Summary","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch is a feature of some programming languages in which a function or method can be dynamically dispatched based on the run-time type.\nJulia's multiple dispatch provides exponential large function space, which allows extending the number system easily.","category":"page"},{"location":"chap6/sparse/#Sparse-Matrices","page":"Sparse Matrices","title":"Sparse Matrices","text":"","category":"section"},{"location":"chap6/sparse/#Data-structure","page":"Sparse Matrices","title":"Data structure","text":"","category":"section"},{"location":"chap6/sparse/#Dominating-eigenvalue-problem","page":"Sparse Matrices","title":"Dominating eigenvalue problem","text":"","category":"section"},{"location":"chap7/hpc/#MPI-and-OpenMP","page":"MPI and OpenMP","title":"MPI and OpenMP","text":"","category":"section"},{"location":"chap4/ad/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"chap2/julia-why/#Why-Julia?","page":"Why Julia?","title":"Why Julia?","text":"","category":"section"},{"location":"chap2/julia-why/#What-is-Julia-programming-language?","page":"Why Julia?","title":"What is Julia programming language?","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Julia is a modern, open-source, high performance programming language for technical computing. It was born in 2012 in MIT, now is maintained by JuliaHub Inc. located in Boston, US.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike MatLab, Julia is open-source. Julia source code is maintained on GitHub repo JuliaLang/julia, and it open-source LICENSE is MIT. Julia packages can be found on JuliaHub, most of them are open-source.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike Python, Julia is designed for high performance (arXiv:1209.5145). It is a dynamic programming language, but it is as fast as C/C++. The following figure shows the computing time of multiple programming languages normalized to C/C++.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"../../assets/images/benchmark.png\" alt=\"image\" width=\"600\" height=\"auto\">","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike C/C++ and Fortran, Julia is easy to use and is becoming a trend in scientific computing. Julia uses the just-int-time (JIT) technique to achieve high performance, which does not have the problem of platform dependency. Many famous scientists and engineers have switched to Julia from other programming languages.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Steven G. Johnson, creater of FFTW, switched from C++ to Julia years ago.\nAnders Sandvik, creater of Stochastic Series Expansion (SSE) quantum Monte Carlo method, switched from Fortran to Julia recently.\nCourse link: Computational Physics\nMiles Stoudenmire, creater of ITensor, switched from C++ to Julia years ago.\nJutho Haegeman, Chris Rackauckas and more.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"note: Should I switch to Julia?\nBefore switching to Julia, please make sure:the problem you are trying to solve runs more than 10min.\nyou are not satisfied by any existing tools.","category":"page"},{"location":"chap2/julia-why/#My-first-program:-Factorial","page":"Why Julia?","title":"My first program: Factorial","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Before we start, please make sure you have the needed packages installed. Type ] in the Julia REPL to enter the package manager, and then type","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"pkg> add BenchmarkTools, MethodAnalysis","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Go back to the REPL by pressing Backspace.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> function jlfactorial(n)\n           x = 1\n           for i in 1:n\n               x = x * i\n           end\n           return x\n       end\njlfactorial (generic function with 1 method)","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To make sure the performance is measured correctly, we use the @btime macro in the BenchmarkTools package to measure the performance of the function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @btime jlfactorial(x) setup=(x=5)\n2.208 ns (0 allocations: 0 bytes)\n120","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"CPU clock cycle is ~0.3ns, so it takes only a few clock cycles to compute the factorial of 5. Julia is really fast!","category":"page"},{"location":"chap2/julia-why/#Compare-with-the-speed-of-C-program","page":"Why Julia?","title":"Compare with the speed of C program","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To measure the performance of the C program, we can utilize the benchmark utilities in Julia. Benchmarking C program with Julia is accurate because Julia has perfect interoperability with C, which allows zero-cost calling of C functions.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In the following example, we first write a C program to calculate the factorial of a number. The file is named demo.c, and the content is as follows:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"$ cat demo.c\n#include <stddef.h>\nint c_factorial(size_t n) {\n\tint s = 1;\n\tfor (size_t i=1; i<=n; i++) {\n\t\ts *= i;\n\t}\n\treturn s;\n}","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To execute a C program in Julia, one needs to compile it to a shared library.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"$ gcc demo.c -fPIC -O3 -shared -o demo.so","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To call the function in Julia, one can use the @ccall macro in the Libdl package (learn more). Please open a Julia REPL and execute the following code:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using Libdl\n\njulia> c_factorial(x) = Libdl.@ccall \"./demo.so\".c_factorial(x::Csize_t)::Int","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The benchmark result is as follows:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using BenchmarkTools\n\njulia> @benchmark c_factorial(5)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  7.333 ns … 47.375 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     7.458 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   7.764 ns ±  1.620 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ██▅  ▃▁ ▂▂                         ▁▁▁                     ▂\n  ███▆▄██▆███▅▅▆▆▆▅▆▅▄▅▆▅▅▇▆▆▄▅▅▇█▇▆▆█████▅▃▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▃ █\n  7.33 ns      Histogram: log(frequency) by time     12.6 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Although the C program requires the type of variables to be manually declared, its performance is very good. The computing time is only 7.33 ns.","category":"page"},{"location":"chap2/julia-why/#Compare-with-the-speed-of-Python-program","page":"Why Julia?","title":"Compare with the speed of Python program","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"We use the timeit module in ipython to measure the performance of the Python program.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In [5]: def factorial(n):\n...:        x = 1\n...:        for i in range(1, n+1):\n...:            x = x * i\n...:        return x\n...:\n\nIn [6]: factorial(5)\nOut[6]: 120\n\nIn [7]: timeit factorial(5)\n144 ns ± 0.379 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\nIn [8]: factorial(100)\nOut[8]: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"One can also use the PyCall package to call the Python function in Julia.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The computing time of the Python program is 144 ns, which is 20 times slower than the C program and 70 times slower than the Julia program. On the other hand, the python program is more flexible since its integer type is not limited by the machine word size.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> typemax(Int)\n9223372036854775807\n\njulia> jlfactorial(100)\n0","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The reason why python is slow and flexible are the same. In python the type of a variable is not declared when it is defined, and it can be changed at any time. This is why the integer type becomes an arbitrary precision integer type when the number is too large. If a variable does not have a fixed type, the program can not preallocate memory for it due to the lack of size information. Then a dynamic typed language has to use a tuple (type, *data) to represent an object, where type is the type of the object and *data is the pointer to the data. Pointing to a random memory location is slow, because it violates the principle of data locality. Lacking of data locality causes the frequent cache miss - failure to find the data in the L1, L2, or L3 cache. Loading data from the main memory is slow, because of the long latency of reading the main memory.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"../../assets/images/data.png\" alt=\"image\" width=\"300\" height=\"auto\">","category":"page"},{"location":"chap2/julia-why/#Combining-Python-and-C/C?","page":"Why Julia?","title":"Combining Python and C/C++?","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"From the maintainer's perspective, it is hard to maintain a program written in both Python and C/C++:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"It makes the build configuration files complicated.\nLearning two programming languages is hard for new contributors.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Using python as glue is not as powerful as it looks, the following problem can not be solved by this approach:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Monte Carlo simulation.\nBranching and bound algorithms.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"../../assets/images/pythonc.png\" alt=\"image\" width=\"400\" height=\"auto\"/>","category":"page"},{"location":"chap2/julia-why/#Key-ingredients-of-Julia's-performance:-Just-in-time-(JIT)-compilation","page":"Why Julia?","title":"Key ingredients of Julia's performance: Just in time (JIT) compilation","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"JIT compilation: compile the method to a method instance when a method is called for the first time;\nMultiple dispatch: invoke the correct method instance according to the type of multiple arguments;","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"(Image: )","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Given a user defined Julia function, the Julia compiler will generate a binary for it at the first called. This binary is called a method instance, and it is generated based on the input types of the function. The method instance is then stored in the method table, and it will be called when the function is called with the same input types. The method instance is generated by the LLVM compiler, and it is optimized for the input types. The method instance is a binary, and it is as fast as a C/C++ program.","category":"page"},{"location":"chap2/julia-why/#Step-1:-Infer-the-types","page":"Why Julia?","title":"Step 1: Infer the types","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Knowing the types of the variables is key to generate a fast binary. Given the input types, the Julia compiler can infer the types of the variables in the function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"If all the types are inferred, the function is called type stable. One can use the @code_warntype macro to check if the function is type stable. For example, the jlfactorial function with integer input is type stable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_warntype jlfactorial(10)\nMethodInstance for jlfactorial(::Int64)\n  from jlfactorial(n) @ Main REPL[4]:1\nArguments\n  #self#::Core.Const(jlfactorial)\n  n::Int64\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  x::Int64\n  i::Int64\nBody::Int64\n1 ─       (x = 1)\n│   %2  = (1:n)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│         (x = x * i)\n│         (@_3 = Base.iterate(%2, %9))\n│   %12 = (@_3 === nothing)::Bool\n│   %13 = Base.not_int(%12)::Bool\n└──       goto #4 if not %13\n3 ─       goto #2\n4 ┄       return x","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"If the types are not inferred, the function is called type unstable. For example, the badcode function is type unstable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> badcode(x) = x > 3 ? 1.0 : 3\n\njulia> @code_warntype badcode(4)\nMethodInstance for badcode(::Int64)\n  from badcode(x) @ Main REPL[9]:1\nArguments\n  #self#::Core.Const(badcode)\n  x::Int64\nBody::Union{Float64, Int64}\n1 ─ %1 = (x > 3)::Bool\n└──      goto #3 if not %1\n2 ─      return 1.0\n3 ─      return 3","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In this example, the output type Union{Float64, Int64} means the return type is either Float64 or Int64. The function is type unstable because the return type is not fixed. Type unstable code is slow. In the following example, the badcode function is ~10 times slower than its type stable version stable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> x = rand(1:10, 1000);\n\njulia> @benchmark badcode.($x)\nBenchmarkTools.Trial: 10000 samples with 8 evaluations.\n Range (min … max):  2.927 μs … 195.198 μs  ┊ GC (min … max):  0.00% … 96.52%\n Time  (median):     3.698 μs               ┊ GC (median):     0.00%\n Time  (mean ± σ):   4.257 μs ±   7.894 μs  ┊ GC (mean ± σ):  12.43% ±  6.54%\n\n                 ▁▅█▅▃▂                                        \n  ▁▃▅▇▇▇▅▃▂▂▂▃▄▆▇███████▇▇▅▄▄▃▃▃▃▃▃▂▂▃▂▂▂▂▁▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃\n  2.93 μs         Histogram: frequency by time        5.44 μs <\n\n Memory estimate: 26.72 KiB, allocs estimate: 696.\n\njulia> stable(x) = x > 3 ? 1.0 : 3.0\nstable (generic function with 1 method)\n\njulia> @benchmark stable.($x)\nBenchmarkTools.Trial: 10000 samples with 334 evaluations.\n Range (min … max):  213.820 ns … 25.350 μs  ┊ GC (min … max):  0.00% … 98.02%\n Time  (median):     662.551 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   947.978 ns ±  1.187 μs  ┊ GC (mean ± σ):  29.30% ± 21.05%\n\n  ▂▃▅██▇▅▄▃▂▁                                                  ▂\n  ████████████▇▅▅▄▄▁▁▁▁▁▁▁▁▁▁▁▁▁▃▅▆▇██████▇▇▇▆█▇▇▇▇▇▇▇▇▆▇▆▆▆▇▇ █\n  214 ns        Histogram: log(frequency) by time      6.32 μs <\n\n Memory estimate: 7.94 KiB, allocs estimate: 1.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In the above example:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"\".\" is the broadcasting operator, it applies the function to each element of the array.\n\"$\" is the interpolation operator, it is used to interpolate a variable into an expression. In a benchmark, it can be used to avoid the overhead of variable initialization.","category":"page"},{"location":"chap2/julia-why/#Step-2:-Generates-the-LLVM-intermediate-representation","page":"Why Julia?","title":"Step 2: Generates the LLVM intermediate representation","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"LLVM is a set of compiler and toolchain technologies that can be used to develop a front end for any programming language and a back end for any instruction set architecture. LLVM is the backend of multiple languages, including Julia, Rust, Swift and Kotlin.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In Julia, one can use the @code_llvm macro to show the LLVM intermediate representation of a function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_llvm jlfactorial(10)\n\nor any instruction set architecture. LLVM is the backend of multiple languages, including Julia, Rust, Swift and Kotlin.\n\n\n\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:1 within `jlfactorial`\ndefine i64 @julia_jlfactorial_3677(i64 signext %0) #0 {\ntop:\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:3 within `jlfactorial`\n; ┌ @ range.jl:5 within `Colon`\n; │┌ @ range.jl:403 within `UnitRange`\n; ││┌ @ range.jl:414 within `unitrange_last`\n     %1 = call i64 @llvm.smax.i64(i64 %0, i64 0)\n; └└└\n; ┌ @ range.jl:897 within `iterate`\n; │┌ @ range.jl:672 within `isempty`\n; ││┌ @ operators.jl:378 within `>`\n; │││┌ @ int.jl:83 within `<`\n      %2 = icmp slt i64 %0, 1\n; └└└└\n  br i1 %2, label %L32, label %L17.preheader\n\nL17.preheader:                                    ; preds = %top\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n  %min.iters.check = icmp ult i64 %1, 2\n  br i1 %min.iters.check, label %scalar.ph, label %vector.ph\n\nvector.ph:                                        ; preds = %L17.preheader\n  %n.vec = and i64 %1, 9223372036854775806\n  %ind.end = or i64 %1, 1\n  br label %vector.body\n\nvector.body:                                      ; preds = %vector.body, %vector.ph\n  %index = phi i64 [ 0, %vector.ph ], [ %induction12, %vector.body ]\n  %vec.phi = phi i64 [ 1, %vector.ph ], [ %3, %vector.body ]\n  %vec.phi11 = phi i64 [ 1, %vector.ph ], [ %4, %vector.body ]\n  %offset.idx = or i64 %index, 1\n  %induction12 = add i64 %index, 2\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; ┌ @ int.jl:88 within `*`\n   %3 = mul i64 %vec.phi, %offset.idx\n   %4 = mul i64 %vec.phi11, %induction12\n   %5 = icmp eq i64 %induction12, %n.vec\n   br i1 %5, label %middle.block, label %vector.body\n\nmiddle.block:                                     ; preds = %vector.body\n; └\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n  %bin.rdx = mul i64 %4, %3\n  %cmp.n = icmp eq i64 %1, %n.vec\n  br i1 %cmp.n, label %L32, label %scalar.ph\n\nscalar.ph:                                        ; preds = %middle.block, %L17.preheader\n  %bc.resume.val = phi i64 [ %ind.end, %middle.block ], [ 1, %L17.preheader ]\n  %bc.merge.rdx = phi i64 [ %bin.rdx, %middle.block ], [ 1, %L17.preheader ]\n  br label %L17\n\nL17:                                              ; preds = %L17, %scalar.ph\n  %value_phi4 = phi i64 [ %7, %L17 ], [ %bc.resume.val, %scalar.ph ]\n  %value_phi6 = phi i64 [ %6, %L17 ], [ %bc.merge.rdx, %scalar.ph ]\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; ┌ @ int.jl:88 within `*`\n   %6 = mul i64 %value_phi6, %value_phi4\n; └\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n; ┌ @ range.jl:901 within `iterate`\n; │┌ @ promotion.jl:521 within `==`\n    %.not = icmp eq i64 %value_phi4, %1\n; │└\n   %7 = add nuw i64 %value_phi4, 1\n; └\n  br i1 %.not, label %L32, label %L17\n\nL32:                                              ; preds = %L17, %middle.block, %top\n  %value_phi10 = phi i64 [ 1, %top ], [ %bin.rdx, %middle.block ], [ %6, %L17 ]\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n  ret i64 %value_phi10\n}","category":"page"},{"location":"chap2/julia-why/#Step-3:-Compiles-to-binary-code","page":"Why Julia?","title":"Step 3: Compiles to binary code","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The LLVM intermediate representation is then compiled to binary code by the LLVM compiler. The binary code can be printed by the @code_native macro.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_native jlfactorial(10)\n\t.section\t__TEXT,__text,regular,pure_instructions\n\t.build_version macos, 14, 0\n\t.globl\t_julia_jlfactorial_3726         ; -- Begin function julia_jlfactorial_3726\n\t.p2align\t2\n_julia_jlfactorial_3726:                ; @julia_jlfactorial_3726\n; ┌ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:1 within `jlfactorial`\n; %bb.0:                                ; %top\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:3 within `jlfactorial`\n; │┌ @ range.jl:5 within `Colon`\n; ││┌ @ range.jl:403 within `UnitRange`\n; │││┌ @ range.jl:414 within `unitrange_last`\n\tcmp\tx0, #0\n\tcsel\tx9, x0, xzr, gt\n; │└└└\n\tcmp\tx0, #1\n\tb.lt\tLBB0_3\n; %bb.1:                                ; %L17.preheader\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tcmp\tx9, #2\n\tb.hs\tLBB0_4\n; %bb.2:\n\tmov\tw8, #1\n\tmov\tw0, #1\n\tb\tLBB0_7\nLBB0_3:\n\tmov\tw0, #1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n\tret\nLBB0_4:                                 ; %vector.ph\n\tmov\tx12, #0\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tand\tx10, x9, #0x7ffffffffffffffe\n\torr\tx8, x9, #0x1\n\tmov\tw11, #1\n\tmov\tw13, #1\nLBB0_5:                                 ; %vector.body\n                                        ; =>This Inner Loop Header: Depth=1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmadd\tx11, x11, x12, x11\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tadd\tx14, x12, #2\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmul\tx13, x13, x14\n\tmov\tx12, x14\n\tcmp\tx10, x14\n\tb.ne\tLBB0_5\n; %bb.6:                                ; %middle.block\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tmul\tx0, x13, x11\n\tcmp\tx9, x10\n\tb.eq\tLBB0_9\nLBB0_7:                                 ; %L17.preheader15\n\tadd\tx9, x9, #1\nLBB0_8:                                 ; %L17\n                                        ; =>This Inner Loop Header: Depth=1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmul\tx0, x0, x8\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n; │┌ @ range.jl:901 within `iterate`\n\tadd\tx8, x8, #1\n; │└\n\tcmp\tx9, x8\n\tb.ne\tLBB0_8\nLBB0_9:                                 ; %L32\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n\tret\n; └\n                                        ; -- End function\n.subsections_via_symbols","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Single function definition may have multiple method instances.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> methods(jlfactorial)\n# 1 method for generic function \"jlfactorial\" from Main:\n [1] jlfactorial(n)\n     @ REPL[4]:1","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Whenever the function is called with a new input type, the Julia compiler will generate a new method instance for the function. The method instance is then stored in the method table, and can be analyzed by the MethodAnalysis package.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using MethodAnalysis\n\njulia> methodinstances(jlfactorial)\n1-element Vector{Core.MethodInstance}:\n MethodInstance for jlfactorial(::Int64)\n\njulia> jlfactorial(UInt32(5))\n120\n\njulia> methodinstances(jlfactorial)\n2-element Vector{Core.MethodInstance}:\n MethodInstance for jlfactorial(::Int64)\n MethodInstance for jlfactorial(::UInt32)","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"When a function is called with multiple arguments, the Julia compiler will invoke the correct method instance according to the type of the arguments. This is called multiple dispatch.","category":"page"},{"location":"chap3/cuda/#Arrays-on-GPU","page":"Arrays on GPU","title":"Arrays on GPU","text":"","category":"section"},{"location":"chap7/cuda/#CUDA-programming","page":"CUDA programming","title":"CUDA programming","text":"","category":"section"},{"location":"chap2/julia-fluid/#Project:-Fluid-dynamics","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"","category":"section"},{"location":"chap2/julia-fluid/#Fluid-Dynamics-Simulation","page":"Project: Fluid dynamics","title":"Fluid Dynamics Simulation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Fluid dynamics is the study of the movement of fluids, including air and water. In this project, we will use the Lattice Boltzmann Method (LBM) to simulate fluid dynamics, which is a mesoscopic method based on the kinetic theory of gases.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":" micro meso macro\nScale 10^-9m 10^-9 -10^-6m 10^6m\nPhysics molecular probabilistic continuous\nGov. Eq. Newton Boltzmann Navier-Stokes equations\nMethod Molecular Dynamics Lattice Boltzmann Computational Fluid Dynamics","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"This book does not aim to provide a comprehensive understanding of fluid dynamics. If you are interested in learning more about fluid dynamics, you can refer to the following resources:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Fluid Dynamics Simulation (in Python, Java and Javascript)\nYouTube - Introduction to Lattice Boltzmann Method","category":"page"},{"location":"chap2/julia-fluid/#Lattice-Boltzmann-Method-(LBM)","page":"Project: Fluid dynamics","title":"Lattice Boltzmann Method (LBM)","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The general idea of LBM is to simulate the fluid dynamics by modeling the movement of particles in a lattice, a grid of cells, without keeping track of the individual particles. The state of a cell in the lattice is defined by the density of particles moving in different directions, i.e. ","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"rm state(i j) equiv rho_ij(mathbfv)","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"where (i j) is the position of the cell in the lattice and mathbfv is the velocity of the particles.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<img src=\"../../assets/images/lattice.png\" alt=\"image\" width=300 height=\"auto\">","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The particles move with different velocities mathbf v and collide with each other, driving the fluid to reach an equilibrium state, where the energy of the particles is governed by the Boltzmann distribution","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"rho_rm eq(E) sim e^-fracEk_BT (rm or  e^- rm const times mathbfv^2)","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"where k_B is the Boltzmann constant, T is the temperature, and E = frac12mmathbfv^2 is the energy of the particles.","category":"page"},{"location":"chap2/julia-fluid/#D2Q9-model","page":"Project: Fluid dynamics","title":"D2Q9 model","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The lattice Boltzmann method uses a discrete set of velocities, which is a simplification of the continuous velocity space. One of the simplest models is the D2Q9 model, which contains","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"a 2D lattice, and\n9 discrete velocities: (00), (10) (01) (-10) (0-1), (11) (-11) (-1-1) (1-1).","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<img src=\"../../assets/images/D2Q9.png\" alt=\"image\" width=500 height=\"auto\">","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Lattice Boltzmann Method (LBM) contains two steps:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Streaming - particles move to neighboring cells\nCollision - particles collide and exchange momentum","category":"page"},{"location":"chap2/julia-fluid/#Streaming","page":"Project: Fluid dynamics","title":"Streaming","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<img src=\"../../assets/images/stream.png\" alt=\"image\" width=500 height=\"auto\">","category":"page"},{"location":"chap2/julia-fluid/#Collision-Bhatnagar-Gross-Krook-(BGK)-model.","page":"Project: Fluid dynamics","title":"Collision - Bhatnagar-Gross-Krook (BGK) model.","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The collision step is based on the Bhatnagar-Gross-Krook (BGK) model, which is a simplified version of the Boltzmann equation. The collision step is defined as","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"rholeftarrow(1-omega)rho_0+omegarho_mathrmrm eq","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"where rho is the updated density rho_0 is the density before collision, and rho_texteq is the equilibrium density omega = Delta ttau, where tau is the (relative) relaxation time","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<img src=\"../../assets/images/Equilibrium density.png\" alt=\"image\" width=500 height=\"auto\">","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The BGK model has a nice property that it conserves:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"total density rho\nmomentum rhomathbfu","category":"page"},{"location":"chap2/julia-fluid/#Julia-implementation","page":"Project: Fluid dynamics","title":"Julia implementation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The following code is a part of the package MyFirstPackage that we created in the previous section: My First Package.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"File: src/fluid.jl (Step 1-6)","category":"page"},{"location":"chap2/julia-fluid/#Step-1.-Define-the-lattice-Boltzmann-configuration","page":"Project: Fluid dynamics","title":"Step 1. Define the lattice Boltzmann configuration","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Let us start by defining an abstract type for lattice Boltzmann configurations and a concrete type that implements the D2Q9 lattice.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    AbstractLBConfig{D, N}\n\nAn abstract type for lattice Boltzmann configurations.\n\"\"\"\nabstract type AbstractLBConfig{D, N} end","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The D2Q9 lattice Boltzman configuration is defined as follows:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    D2Q9 <: AbstractLBConfig{2, 9}\n\nA lattice Boltzmann configuration for 2D, 9-velocity model.\n\"\"\"\nstruct D2Q9 <: AbstractLBConfig{2, 9} end\ndirections(::D2Q9) = (\n        Point(1, 1), Point(-1, 1),\n        Point(1, 0), Point(0, -1),\n        Point(0, 0), Point(0, 1),\n        Point(-1, 0), Point(1, -1),\n        Point(-1, -1),\n    )","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The directions function returns the 9 discrete velocities in the D2Q9 model. The velocities are ordered in a specific way, which enables us to define a function to flip the velocity vector. This is useful for handling the boundaries and barriers in the lattice.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# directions[k] is the opposite of directions[flip_direction_index(k)\nfunction flip_direction_index(::D2Q9, i::Int)\n    return 10 - i\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-2:-Define-the-Cell-type-for-storing-the-state","page":"Project: Fluid dynamics","title":"Step 2: Define the Cell type for storing the state","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The cell state is defined by the density of the fluid in different directions, rho_ij(mathbfv).","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# the density of the fluid, each component is the density of a velocity\nstruct Cell{N, T <: Real}\n    density::NTuple{N, T}\nend\n# the total density of the fluid\ndensity(cell::Cell) = sum(cell.density)\n# the density of the fluid in a specific direction,\n# where the direction is an integer\ndensity(cell::Cell, direction::Int) = cell.density[direction]","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Expect the total density, the momentum mathbfu is also conserved, which is defined as the momentum of the fluid.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    momentum(lb::AbstractLBConfig, rho::Cell)\n\nCompute the momentum of the fluid from the density of the fluid.\n\"\"\"\nfunction momentum(lb::AbstractLBConfig, rho::Cell)\n    return mapreduce((r, d) -> r * d, +, rho.density, directions(lb)) / density(rho)\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Let us also define the addition and multiplication operations for the Cell type.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Base.:+(x::Cell, y::Cell) = Cell(x.density .+ y.density)\nBase.:*(x::Real, y::Cell) = Cell(x .* y.density)","category":"page"},{"location":"chap2/julia-fluid/#Step-3.-Implement-the-streaming-step","page":"Project: Fluid dynamics","title":"Step 3. Implement the streaming step","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# streaming step\nfunction stream!(\n        lb::AbstractLBConfig{2, N},  # lattice configuration\n        newgrid::AbstractMatrix{D}, # the updated grid\n        grid::AbstractMatrix{D}, # the original grid\n        barrier::AbstractMatrix{Bool} # the barrier configuration\n    ) where {N, T, D<:Cell{N, T}}\n    ds = directions(lb)\n    @inbounds for ci in CartesianIndices(newgrid)\n        i, j = ci.I\n        newgrid[ci] = Cell(ntuple(N) do k # collect the densities\n            ei = ds[k]\n            m, n = size(grid)\n            i2, j2 = mod1(i - ei[1], m), mod1(j - ei[2], n)\n            if barrier[i2, j2]\n                # if the cell is a barrier, the fluid flows back\n                density(grid[i, j], flip_direction_index(lb, k))\n            else\n                # otherwise, the fluid flows to the neighboring cell\n                density(grid[i2, j2], k)\n            end\n        end)\n    end\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-4.-Implement-the-collision-step","page":"Project: Fluid dynamics","title":"Step 4. Implement the collision step","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"By the Bhatnagar-Gross-Krook (BGK) model, the collision step drives the fluid towards an equilibrium state. The equilibrium density is completely determined by the total density and the momentum of the fluid:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"rho_rm eq(mathbfv_i) approx rho_rm tot w_i left(1 + 3mathbfv_icdotmathbfu + frac92(mathbfv_icdotmathbfu)^2 - frac32mathbfucdotmathbfuright)","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"where rho_rm tot is the total density, mathbfu is the momentum, w_i sim e^-mathbfv_i^2 is the distribution of velocities with mean-velocity zero, and v_i is the velocity vector.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The detailed derivation of the equilibrium density could be found in the first reference at the top of this page.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    equilibrium_density(lb::AbstractLBConfig, ρ, u)\n\nCompute the equilibrium density of the fluid from the total density and the momentum.\n\"\"\"\nfunction equilibrium_density(lb::AbstractLBConfig{D, N}, ρ, u) where {D, N}\n    ws, ds = weights(lb), directions(lb)\n    return Cell(\n        ntuple(i-> ρ * ws[i] * _equilibrium_density(u, ds[i]), N)\n    )\nend\n\n# the distribution of the 9 velocities at the equilibrium state\nweights(::D2Q9) = (1/36, 1/36, 1/9, 1/9, 4/9, 1/9, 1/9, 1/36, 1/36)\nfunction _equilibrium_density(u, ei)\n    # the equilibrium density of the fluid with a specific mean momentum\n    return (1 + 3 * dot(ei, u) + 9/2 * dot(ei, u)^2 - 3/2 * dot(u, u))\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The collision step that implements the BGK model is defined as follows:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"# collision step, applied on a single cell\nfunction collide(lb::AbstractLBConfig{D, N}, rho; viscosity = 0.02) where {D, N}\n    omega = 1 / (3 * viscosity + 0.5)   # \"relaxation\" parameter\n    # Recompute macroscopic quantities:\n    v = momentum(lb, rho)\n    return (1 - omega) * rho + omega * equilibrium_density(lb, density(rho), v)\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-5.-Implement-the-lattice-Boltzmann-simulation","page":"Project: Fluid dynamics","title":"Step 5. Implement the lattice Boltzmann simulation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    LatticeBoltzmann{D, N, T, CFG, MT, BT}\n\nA lattice Boltzmann simulation with D dimensions, N velocities, and lattice configuration CFG.\n\"\"\"\n\nstruct LatticeBoltzmann{D, N, T, CFG<:AbstractLBConfig{D, N}, MT<:AbstractMatrix{Cell{N, T}}, BT<:AbstractMatrix{Bool}}\n    config::CFG # lattice configuration\n    grid::MT    # density of the fluid\n    gridcache::MT # cache for the density of the fluid\n    barrier::BT # barrier configuration\nend\n\nfunction LatticeBoltzmann(config::AbstractLBConfig{D, N}, grid::AbstractMatrix{<:Cell}, barrier::AbstractMatrix{Bool}) where {D, N}\n    @assert size(grid) == size(barrier)\n    return LatticeBoltzmann(config, grid, similar(grid), barrier)\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"A single step of the lattice Boltzmann simulation is defined as follows, which directly modifies the grid field of the LatticeBoltzmann type.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    step!(lb::LatticeBoltzmann)\n\nPerform a single step of the lattice Boltzmann simulation.\n\"\"\"\nfunction step!(lb::LatticeBoltzmann)\n    copyto!(lb.gridcache, lb.grid)\n    stream!(lb.config, lb.grid, lb.gridcache, lb.barrier)\n    lb.grid .= collide.(Ref(lb.config), lb.grid)\n    return lb\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"For better visualization, we define a function to compute the curl of the momentum field in 2D, which is defined as:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"\"\"\"\n    curl(u::AbstractMatrix{Point2D{T}})\n\nCompute the curl of the momentum field in 2D, which is defined as:\n```math\n∂u_y/∂x−∂u_x/∂y\n```\n\"\"\"\nfunction curl(u::Matrix{Point2D{T}}) where T \n    return map(CartesianIndices(u)) do ci\n        i, j = ci.I\n        m, n = size(u)\n        uy = u[mod1(i + 1, m), j][2] - u[mod1(i - 1, m), j][2]\n        ux = u[i, mod1(j + 1, n)][1] - u[i, mod1(j - 1, n)][1]\n        return uy - ux # a factor of 1/2 is missing here?\n    end\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-6.-Find-the-example-simulation","page":"Project: Fluid dynamics","title":"Step 6. Find the example simulation","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"A D2Q9 lattice Boltzmann simulation example. A simple linear barrier is added to the lattice.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"function example_d2q9(;\n        height = 80, width = 200,\n        u0 = Point(0.0, 0.1)) # initial and in-flow speed\n    # Initialize all the arrays to steady rightward flow:\n    rho = equilibrium_density(D2Q9(), 1.0, u0)\n    rgrid = fill(rho, height, width)\n\n    # Initialize barriers:\n    barrier = falses(height, width)  # True wherever there's a barrier\n    mid = div(height, 2)\n    barrier[mid-8:mid+8, div(height,2)] .= true              # simple linear barrier\n\n    return LatticeBoltzmann(D2Q9(), rgrid, barrier)\nend","category":"page"},{"location":"chap2/julia-fluid/#Step-7.-Include-the-above-file-into-the-package-module","page":"Project: Fluid dynamics","title":"Step 7. Include the above file into the package module","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"File: src/MyFirstPackage.jl","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"module MyFirstPackage\n# import packages\nusing LinearAlgebra\n\n# export interfaces\nexport Lorenz, integrate_step\nexport Point, Point2D, Point3D\nexport RungeKutta, Euclidean\nexport D2Q9, LatticeBoltzmann, step!, equilibrium_density, momentum, curl, example_d2q9, density\n\ninclude(\"lorenz.jl\")\ninclude(\"fluid.jl\")\n\nend","category":"page"},{"location":"chap2/julia-fluid/#Using-the-package","page":"Project: Fluid dynamics","title":"Using the package","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"File: examples/barrier.jl","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"using Makie: RGBA # for visualization\nusing Makie, GLMakie\nusing MyFirstPackage # our package\n\n# Set up the visualization with Makie:\nlb = example_d2q9()\nvorticity = Observable(curl(momentum.(Ref(lb.config), lb.grid))')\nfig, ax, plot = image(vorticity, colormap = :jet, colorrange = (-0.1, 0.1))\n\n# Show barrier\nbarrier_img = map(x -> x ? RGBA(0, 0, 0, 1) : RGBA(0, 0, 0, 0), lb.barrier)\nimage!(ax, barrier_img')\n\n# Recording the simulation\nrecord(fig, joinpath(@__DIR__, \"barrier.mp4\"), 1:100; framerate = 10) do i\n    for i=1:20\n        step!(lb)\n    end\n    vorticity[] = curl(momentum.(Ref(lb.config), lb.grid))'\nend","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"To ensure the reproducibility of the code, we need to create a local environment and install the required packages.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"pkg> activate(\"examples\")\n\npkg> dev .\n\npkg> add Makie GLMakie BenchmarkTools","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Type Backspace to exit the package mode. To execute the code, type","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> include(\"examples/barrier.jl\")","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"You should see a new file barrier.mp4 in the examples directory, which is the recording of the simulation.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"<video width=\"320\" height=\"240\" controls>\n  <source src=\"../../assets/images/barrier.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"chap2/julia-fluid/#Benchmarking","page":"Project: Fluid dynamics","title":"Benchmarking","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> using BenchmarkTools\n\njulia> @benchmark step!($(deepcopy(lb)))\nBenchmarkTools.Trial: 3637 samples with 1 evaluation.\n Range (min … max):  1.323 ms …  1.899 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     1.363 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   1.374 ms ± 30.730 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n             ▁▇█▆▄▃▃▂▂▂▁▂▂▂▂▁▁▁▁▁▁                           ▁\n  ▃▁▁▃▃▃▃▁▁▁▃█████████████████████████▆▆▆▆▅▆▆▆▆▅▅▆▆▃▅▅▄▆▆▅▃▆ █\n  1.32 ms      Histogram: log(frequency) by time     1.49 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap2/julia-fluid/#Profiling-identify-the-performance-bottleneck","page":"Project: Fluid dynamics","title":"Profiling - identify the performance bottleneck","text":"","category":"section"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Premature optimization is the root of all evil – Donald Knuth","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Performance optimization comes after the correctness of the code, and it should be based on the profiling result. Profiling is mainly used to identify the performance bottleneck of your code. The Profile module in Julia provides a set of tools to profile your code.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> using Profile\n\njulia> Profile.init(n = 10^7, delay = 0.001) # set the number of samples and the delay between samples","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Then you can profile your code by wrapping the code with @profile macro.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> @profile for i in 1:100\n           step!(lb)\n       end","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"In order to collect enough samples, we run the step! function for 100 times. To view the profile result, you can use the Profile.print function.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> Profile.print(; mincount=10) # only show functions with ≥10 counts\nOverhead ╎ [+additional indent] Count File:Line; Function\n=========================================================\n            ... truncated message ...\n  ╎    ╎    ╎    ╎ 88  …rc/fluid.jl:144; step!(lb::LatticeBoltzm…\n  ╎    ╎    ╎    ╎  88  …rc/fluid.jl:76; stream!(lb::D2Q9, newgr…\n33╎    ╎    ╎    ╎   88  …e/ntuple.jl:19; ntuple\n  ╎    ╎    ╎    ╎    18  …rc/fluid.jl:79; (::MyFirstPackage.var…\n  ╎    ╎    ╎    ╎     10  …perators.jl:830; mod1\n 1╎    ╎    ╎    ╎    16  …rc/fluid.jl:80; (::MyFirstPackage.var…\n  ╎    ╎    ╎    ╎     15  …actarray.jl:1291; getindex\n  ╎    ╎    ╎    ╎    ╎ 13  …actarray.jl:1323; _getindex\n 1╎    ╎    ╎    ╎    ╎  13  …actarray.jl:702; checkbounds\n  ╎    ╎    ╎    ╎    ╎   12  …actarray.jl:681; checkbounds\n  ╎    ╎    ╎    ╎ 13  …rc/fluid.jl:145; step!(lb::LatticeBoltzm…\n  ╎    ╎    ╎    ╎  13  …roadcast.jl:911; materialize!\n  ╎    ╎    ╎    ╎   13  …roadcast.jl:914; materialize!\n  ╎    ╎    ╎    ╎    13  …roadcast.jl:956; copyto!\n  ╎    ╎    ╎    ╎     13  …roadcast.jl:1003; copyto!\n  ╎    ╎    ╎    ╎    ╎ 12  …simdloop.jl:77; macro expansion\n  ╎    ╎    ╎    ╎    ╎  12  …roadcast.jl:1004; macro expansion\n  ╎    ╎    ╎    ╎    ╎   12  …roadcast.jl:636; getindex\nTotal snapshots: 112. Utilization: 100% across all threads and tasks. Use the `groupby` kwarg to break down by thread and/or task.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Alternatively, you can use the format :flat to show the profile result in a flat view.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> Profile.print(; mincount=10, format=:flat)\n Count  Overhead File                                                        Line Function\n =====  ======== ====                                                        ==== ========\n            ... truncated message ...\n    10         0 @MyFirstPackage/src/fluid.jl                                  63 #6\n    11        11 @MyFirstPackage/src/fluid.jl                                   ? (::MyFirstPackage.var\"#8#9\"{D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}, BitMatrix, N…\n    20         0 @MyFirstPackage/src/fluid.jl                                  79 (::MyFirstPackage.var\"#8#9\"{D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}, BitMatrix, N…\n    17         0 @MyFirstPackage/src/fluid.jl                                  80 (::MyFirstPackage.var\"#8#9\"{D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}, BitMatrix, N…\n    15         3 @MyFirstPackage/src/fluid.jl                                  94 collide(lb::D2Q9, rho::MyFirstPackage.Cell{9, Float64}; viscosity::Float64)\n    11         1 @MyFirstPackage/src/fluid.jl                                  62 equilibrium_density(lb::D2Q9, ρ::Float64, u::Point2D{Float64})\n    97         0 @MyFirstPackage/src/fluid.jl                                 144 step!(lb::LatticeBoltzmann{2, 9, Float64, D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}…\n    10         0 @MyFirstPackage/src/fluid.jl                                 145 step!(lb::LatticeBoltzmann{2, 9, Float64, D2Q9, Matrix{MyFirstPackage.Cell{9, Float64}}…\n    97         0 @MyFirstPackage/src/fluid.jl                                  76 stream!(lb::D2Q9, newgrid::Matrix{MyFirstPackage.Cell{9, Float64}}, grid::Matrix{MyFirs…\nTotal snapshots: 120. Utilization: 100% across all threads and tasks. Use the `groupby` kwarg to break down by thread and/or task.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The printed result shows that the stream! step is more costly than the collide step, which should be the focus of optimization.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"note: How profiling works\nProfiling is a statistical method to measure the performance of your code. It works by sampling the function call stack of the running code at a certain frequency.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Let use look at the stream! function to see which part of the code is more costly.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"julia> Profile.clear()   # clear the previous profile result\n\njulia> @profile for i in 1:300\n    MyFirstPackage.stream!(lb.config, lb.grid, lb.gridcache, lb.barrier)\nend\n\nProfile.print(format=:flat, mincount=30)  # show the profile result, only show the functions that are called more than 5 times\n            ... truncated message ...\n  ╎    ╎    ╎    ╎ 263 …rc/fluid.jl:76; stream!(lb::D2Q9, newgri…\n77╎    ╎    ╎    ╎  259 …e/ntuple.jl:19; ntuple\n  ╎    ╎    ╎    ╎   57  …rc/fluid.jl:79; (::MyFirstPackage.var\"…\n28╎    ╎    ╎    ╎    28  @Base/int.jl:86; -\n  ╎    ╎    ╎    ╎    29  …perators.jl:830; mod1\n  ╎    ╎    ╎    ╎     27  @Base/int.jl:287; mod\n  ╎    ╎    ╎    ╎    ╎ 27  @Base/div.jl:319; fld\n  ╎    ╎    ╎    ╎    ╎  27  @Base/div.jl:354; div\n  ╎    ╎    ╎    ╎    ╎   25  @Base/int.jl:1068; -\n25╎    ╎    ╎    ╎    ╎    25  @Base/int.jl:86; -\n 3╎    ╎    ╎    ╎   51  …rc/fluid.jl:80; (::MyFirstPackage.var\"…\n  ╎    ╎    ╎    ╎    48  …actarray.jl:1291; getindex\n  ╎    ╎    ╎    ╎     46  …actarray.jl:1323; _getindex\n 3╎    ╎    ╎    ╎    ╎ 46  …actarray.jl:702; checkbounds\n  ╎    ╎    ╎    ╎    ╎  43  …actarray.jl:681; checkbounds\n  ╎    ╎    ╎    ╎    ╎   39  …actarray.jl:728; checkbounds_indi…\n  ╎    ╎    ╎    ╎    ╎    39  …actarray.jl:728; checkbounds_ind…\n  ╎    ╎    ╎    ╎    ╎     39  …actarray.jl:763; checkindex\n38╎    ╎    ╎    ╎    ╎    ╎ 39  @Base/int.jl:86; -\n  ╎    ╎    ╎    ╎   29  …rc/fluid.jl:83; (::MyFirstPackage.var\"…\n29╎    ╎    ╎    ╎    29  …sentials.jl:14; getindex\nTotal snapshots: 264. Utilization: 100% across all threads and tasks. Use the `groupby` kwarg to break down by thread and/or task.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The line 79 in file src/fluid.jl costs 57/264 samples, which is the following line of code:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"i2, j2 = mod1(i - ei[1], m), mod1(j - ei[2], n)","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"The line 80 in file src/fluid.jl costs 51/264 samples, which is the following line of code:","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"if barrier[i2, j2]","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"and most of the time is spent on the checkbounds function.","category":"page"},{"location":"chap2/julia-fluid/","page":"Project: Fluid dynamics","title":"Project: Fluid dynamics","text":"Could we remove the boundary check? Please refer to the Julia Performance Tips for more information.","category":"page"},{"location":"chap3/factorization/#Matrix-factorization","page":"Matrix factorization","title":"Matrix factorization","text":"","category":"section"},{"location":"chap3/factorization/#Special-matrices","page":"Matrix factorization","title":"Special matrices","text":"","category":"section"},{"location":"chap3/factorization/#QR-factorization","page":"Matrix factorization","title":"QR factorization","text":"","category":"section"},{"location":"chap3/factorization/#Example:-Solving-linear-equations","page":"Matrix factorization","title":"Example: Solving linear equations","text":"","category":"section"},{"location":"chap3/factorization/#Eigenvalue-and-eigenvector","page":"Matrix factorization","title":"Eigenvalue and eigenvector","text":"","category":"section"},{"location":"chap3/factorization/#Example:-Least-square-fitting","page":"Matrix factorization","title":"Example: Least square fitting","text":"","category":"section"},{"location":"chap3/factorization/#Singular-value-decomposition","page":"Matrix factorization","title":"Singular value decomposition","text":"","category":"section"},{"location":"chap3/factorization/#Example:-Principal-component-analysis","page":"Matrix factorization","title":"Example: Principal component analysis","text":"","category":"section"},{"location":"chap4/combinatorial/#Combinatorial-Optimization","page":"Combinatorial Optimization","title":"Combinatorial Optimization","text":"","category":"section"},{"location":"chap4/optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"chap5/montecarlo/#Markov-Chain-Monte-Carlo","page":"Markov Chain Monte Carlo","title":"Markov Chain Monte Carlo","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"using Plots\nusing LinearAlgebra\nusing Test\nusing Luxor\n\nts = collect(0.0:0.5:10.0)\n\nys = [2.9, 2.7, 4.8, 5.3, 7.1, 7.6, 7.7, 7.6, 9.4, 9.0, 9.6, 10.0, 10.2, 9.7, 8.3, 8.4, 9.0, 8.3, 6.6, 6.7, 4.1]\n\nscatter(ts, ys; label=\"\", xlabel=\"t\", ylabel=\"y\", ylim=(0, 10.5))","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A2 = [ones(length(ts)) ts ts.^2]\nA2inv = pinv(A2)\nx2 = pinv(A2) * ys\nnorm(A2 * x2 - ys)^2\n\nlet\n\tplt = scatter(ts, ys; xlabel=\"t\", ylabel=\"y\", ylim=(0, 10.5), label=\"data\")\n\ttt = 0:0.1:10\n\tplot!(plt, tt, map(t->x2[1] + x2[2]*t + x2[3] * t^2, tt); label=\"fitted\")\nend","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"pinv(A2)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"cond(A2)\n\nopnorm(A2) * opnorm(pinv(A2))\n\nmaximum(svd(A2).S)/minimum(svd(A2).S)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"let\n\tp = 12345678\n\tq = 1\n\tp - sqrt(p^2 + q)\nend\n\nlet # more accurate\n\tp = 12345678\n\tq = 1\n\tq/(p + sqrt(p^2 + q))\nend","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"rectQ = Matrix(qr(A2).Q)\n\nqr(A2).R\n\nrectQ * qr(A2).R ≈ A2","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"struct HouseholderMatrix{T} <: AbstractArray{T, 2}\n\tv::Vector{T}\n\tβ::T\nend","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Base.size(A::HouseholderMatrix) = (length(A.v), length(A.v))\n\nBase.size(A::HouseholderMatrix, i::Int) = i == 1 || i == 2 ? length(A.v) : 1\n\n# some other methods to avoid ambiguity error\n\nBase.inv(A::HouseholderMatrix) = A\n\nBase.adjoint(A::HouseholderMatrix) = A\n\ninv(A2' * A2) * A2'\n\nA2' * A2\n\nA2' * ys\n\nrectQ' * rectQ\n\n@testset \"householder property\" begin\n\tv = randn(3)\n\tβ = 2/norm(v, 2)^2\n\tH = I - β * v * v'\n\t# symmetric\n\t@test H' ≈ H\n\t# reflexive\n\t@test H^2 ≈ I\n\t# orthogonal\n\t@test H' * H ≈ I\nend","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"# the `mul!` interfaces can take two extra factors.\nfunction left_mul!(B, A::HouseholderMatrix)\n\tB .-= (A.β .* A.v) * (A.v' * B)\n\treturn B\nend\n\n# the `mul!` interfaces can take two extra factors.\nfunction right_mul!(A, B::HouseholderMatrix)\n\tA .= A .- (A * (B.β .* B.v)) * B.v'\n\treturn A\nend\n\nBase.getindex(A::HouseholderMatrix, i::Int, j::Int) = A.β * A.v[i] * conj(A.v[j])","category":"page"},{"location":"chap3/qr/#Review:-Solving-linear-equations","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Given Ain mathbbR^ntimes n and b in mathbbR^n, find x in mathbbR^n s.t.","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Ax = b","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"LU factorization with Gaussian Elimination (with Pivoting)\nSensitivity analysis: Condition number\nComputing matrix inverse with Guass-Jordan Elimination","category":"page"},{"location":"chap3/qr/#Linear-Least-Square-Problem","page":"Review: Solving linear equations","title":"Linear Least Square Problem","text":"","category":"section"},{"location":"chap3/qr/#Data-Fitting","page":"Review: Solving linear equations","title":"Data Fitting","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Given m data points (t_i y_i), we wish to find the n-vector x of parameters that gives the \"best fit\" to the data by the model function f(t x), with","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"f mathbbR^n+1 rightarrow mathbbR","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"min_xsum_i=1^m (y_i - f(t_i x))^2","category":"page"},{"location":"chap3/qr/#Example","page":"Review: Solving linear equations","title":"Example","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"f(x) = x_0 + x_1 t + x_2 t^2","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Ax = left(beginmatrix\n1  t_1  t_1^2\n1  t_2  t_2^2\n1  t_3  t_3^2\n1  t_4  t_4^2\n1  t_5  t_5^2\nvdots  vdots  vdots\nendmatrixright)\nleft(beginmatrix x_1  x_2  x_3endmatrixright) approx\nleft(beginmatrixy_1 y_2 y_3  y_4  y_5vdotsendmatrixright) = b","category":"page"},{"location":"chap3/qr/#Normal-Equations","page":"Review: Solving linear equations","title":"Normal Equations","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"The goal: minimize Ax - b_2^2","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A^T Ax = A^T b","category":"page"},{"location":"chap3/qr/#Pseudo-Inverse","page":"Review: Solving linear equations","title":"Pseudo-Inverse","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A^+ = (A^T A)^-1A^T","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"x = A^+ b","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Pseudoinverse","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"The julia version","category":"page"},{"location":"chap3/qr/#Example-2","page":"Review: Solving linear equations","title":"Example","text":"","category":"section"},{"location":"chap3/qr/#The-geometric-interpretation","page":"Review: Solving linear equations","title":"The geometric interpretation","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"The residual is b-Ax","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A^T(b - Ax) = 0","category":"page"},{"location":"chap3/qr/#Solving-Normal-Equations-with-Cholesky-decomposition","page":"Review: Solving linear equations","title":"Solving Normal Equations with Cholesky decomposition","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Step 1: Rectangular → Square","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A^TAx = A^T b","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Step 2: Square → Triangular","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A^T A = LL^T","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Step 3: Solve the triangular linear equation \"\"\"","category":"page"},{"location":"chap3/qr/#Issue:-The-Condition-Squaring-Effect","page":"Review: Solving linear equations","title":"Issue: The Condition-Squaring Effect","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"The conditioning of a square linear system Ax = b depends only on the matrix, while the conditioning of a least squares problem Ax approx b depends on both A and b.","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A = left(beginmatrix1  1 epsilon  0  0  epsilon endmatrixright)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"The definition of thin matrix condition number","category":"page"},{"location":"chap3/qr/#The-algorithm-matters","page":"Review: Solving linear equations","title":"The algorithm matters","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"x^2 - 2px - q","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Algorithm 1:","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"p - sqrtp^2 + q","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Algorithm 2:","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"fracqp+sqrtp^2+q","category":"page"},{"location":"chap3/qr/#Orthogonal-Transformations","page":"Review: Solving linear equations","title":"Orthogonal Transformations","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A = QR","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Rx = Q^Tb","category":"page"},{"location":"chap3/qr/#Gist-of-QR-factoriaztion-by-Householder-reflection.","page":"Review: Solving linear equations","title":"Gist of QR factoriaztion by Householder reflection.","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Let H_k be an orthogonal matrix, i.e. H_k^T H_k = I","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"H_n ldots H_2H_1 A = R","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Q = H_1^T H_2 ^Tldots H_n^T","category":"page"},{"location":"chap3/qr/#Review-of-Elimentary-Elimination-Matrix","page":"Review: Solving linear equations","title":"Review of Elimentary Elimination Matrix","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"M_k = I_n  - tau e_k^T","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"tau = left(0 ldots 0 tau_k+1ldotstau_nright)^T  tau_i = fracv_iv_k","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Keys:","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Gaussian elimination is a recursive algorithm.","category":"page"},{"location":"chap3/qr/#Householder-reflection","page":"Review: Solving linear equations","title":"Householder reflection","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Let v in mathbbR^m be nonzero, An m-by-m matrix P of the form","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"P = 1-beta vv^T beta = frac2v^Tv","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"is a Householder reflection.","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"the picture of householder reflection","category":"page"},{"location":"chap3/qr/#Properties-of-Householder-reflection","page":"Review: Solving linear equations","title":"Properties of Householder reflection","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Householder reflection is symmetric and orthogonal.","category":"page"},{"location":"chap3/qr/#Project-a-vector-to-e_1","page":"Review: Solving linear equations","title":"Project a vector to e_1","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"P x = beta e_1","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"v = x pm x_2 e_1","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"function householder_matrix(v::AbstractVector{T}) where T\n\tv = copy(v)\n\tv[1] -= norm(v, 2)\n\treturn HouseholderMatrix(v, 2/norm(v, 2)^2)\nend\n\nlet\n\tA = Float64[1 2 2; 4 4 2; 4 6 4]\n\thm = householder_matrix(view(A,:,1))\n\thm * A\nend","category":"page"},{"location":"chap3/qr/#Triangular-Least-Squares-Problems","page":"Review: Solving linear equations","title":"Triangular Least Squares Problems","text":"","category":"section"},{"location":"chap3/qr/#QR-Factoriaztion","page":"Review: Solving linear equations","title":"QR Factoriaztion","text":"","category":"section"},{"location":"chap3/qr/#Givens-Rotations","page":"Review: Solving linear equations","title":"Givens Rotations","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"function draw_vectors(initial_vector, final_vector, angle)\n\t@drawsvg begin\n\t\torigin()\n\t\tcircle(0, 0, 100, :stroke)\n\t\tsetcolor(\"gray\")\n\t\ta, b = initial_vector\n\t\tLuxor.arrow(Point(0, 0), Point(a, -b) * 100)\n\t\tsetcolor(\"black\")\n\t\tc, d = final_vector\n\t\tLuxor.arrow(Point(0, 0), Point(c, -d) * 100)\n\t\tLuxor.text(\"θ = $angle\", 0, 50; valign=:center, halign=:center)\n\tend 600 400\nend","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"@bind angle Slider(0:0.03:2*3.14; show_value=true)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"G = left(beginmatrix\ncostheta  -sintheta\nsintheta  costheta\nendmatrixright)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"rotation_matrix(angle) = [cos(angle) -sin(angle); sin(angle) cos(angle)]\n\nlet\n\tinitial_vector = [1.0, 0.0]\n\tfinal_vector = rotation_matrix(angle) * initial_vector\n\t@info final_vector\n\tdraw_vectors(initial_vector, final_vector, angle)\nend","category":"page"},{"location":"chap3/qr/#Eliminating-the-y-element","page":"Review: Solving linear equations","title":"Eliminating the y element","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"atan(0.1, 0.5)\n\nlet\n\tinitial_vector = randn(2)\n\tangle = atan(initial_vector[2], initial_vector[1])\n\tfinal_vector = rotation_matrix(-angle) * initial_vector\n\tdraw_vectors(initial_vector, final_vector, -angle)\nend","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"left(\nbeginmatrix\n1  0  0  0  0\n0  c  0  s  0\n0  0  1  0  0\n0  -s  0  c  0\n0  0  0  0  1\nendmatrix\nright)\nleft(\nbeginmatrix\na_1a_2a_3a_4a_5\nendmatrix\nright)=\nleft(\nbeginmatrix\na_1alphaa_30a_5\nendmatrix\nright)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"where s = sin(theta) and c = cos(theta).","category":"page"},{"location":"chap3/qr/#Givens-QR-Factorization","page":"Review: Solving linear equations","title":"Givens QR Factorization","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"struct GivensMatrix{T} <: AbstractArray{T, 2}\n\tc::T\n\ts::T\n\ti::Int\n\tj::Int\n\tn::Int\nend\n\nBase.size(g::GivensMatrix) = (g.n, g.n)\n\nBase.size(g::GivensMatrix, i::Int) = i == 1 || i == 2 ? g.n : 1\n\nfunction elementary_elimination_matrix_1(A::AbstractMatrix{T}) where T\n\tn = size(A, 1)\n\t# create Elementary Elimination Matrices\n\tM = Matrix{Float64}(I, n, n)\n\tfor i=2:n\n\t\tM[i, 1] =  -A[i, 1] ./ A[1, 1]\n\tend\n\treturn M\nend\n\nfunction lufact_naive_recur!(L, A::AbstractMatrix{T}) where T\n\tn = size(A, 1)\n\tif n == 1\n\t\treturn L, A\n\telse\n\t\t# eliminate the first column\n\t\tm = elementary_elimination_matrix_1(A)\n\t\tL .= L * inv(m)\n\t\tA .= m * A\n\t\t# recurse\n\t\tlufact_naive_recur!(view(L, 2:n, 2:n), view(A, 2:n, 2:n))\n\tend\n\treturn L, A\nend\n\nlet\n\tA = [1 2 2; 4 4 2; 4 6 4]\n\tL = Matrix{Float64}(I, 3, 3)\n\tR = copy(A)\n\tlufact_naive_recur!(L, R)\n\tL * R ≈ A\nend\n\nfunction givens(A, i, j)\n\tx, y = A[i, 1], A[j, 1]\n\tnorm = sqrt(x^2 + y^2)\n\tc = x/norm\n\ts = y/norm\n\treturn GivensMatrix(c, s, i, j, size(A, 1))\nend\n\nfunction left_mul!(A::AbstractMatrix, givens::GivensMatrix)\n\tfor col in 1:size(A, 2)\n\t\tvi, vj = A[givens.i, col], A[givens.j, col]\n\t\tA[givens.i, col] = vi * givens.c + vj * givens.s\n\t\tA[givens.j, col] = -vi * givens.s + vj * givens.c\n\tend\n\treturn A\nend\n\nfunction right_mul!(A::AbstractMatrix, givens::GivensMatrix)\n\tfor row in 1:size(A, 1)\n\t\tvi, vj = A[row, givens.i], A[row, givens.j]\n\t\tA[row, givens.i] = vi * givens.c + vj * givens.s\n\t\tA[row, givens.j] = -vi * givens.s + vj * givens.c\n\tend\n\treturn A\nend\n\nfunction householder_qr!(Q::AbstractMatrix{T}, a::AbstractMatrix{T}) where T\n\tm, n = size(a)\n\t@assert size(Q, 2) == m\n\tif m == 1\n\t\treturn Q, a\n\telse\n\t\t# apply householder matrix\n\t\tH = householder_matrix(view(a, :, 1))\n\t\tleft_mul!(a, H)\n\t\t# update Q matrix\n\t\tright_mul!(Q, H')\n\t\t# recurse\n\t\thouseholder_qr!(view(Q, 1:m, 2:m), view(a, 2:m, 2:n))\n\tend\n\treturn Q, a\nend\n\n@testset \"householder QR\" begin\n\tA = randn(3, 3)\n\tQ = Matrix{Float64}(I, 3, 3)\n\tR = copy(A)\n\thouseholder_qr!(Q, R)\n\t@info R\n\t@test Q * R ≈ A\n\t@test Q' * Q ≈ I\nend\n\nlet\n\tA = randn(3, 3)\n\tg = givens(A, 2, 3)\n\tleft_mul!(copy(A), g)\nend\n\nfunction givens_qr!(Q::AbstractMatrix, A::AbstractMatrix)\n\tm, n = size(A)\n\tif m == 1\n\t\treturn Q, A\n\telse\n\t\tfor k = m:-1:2\n\t\t\tg = givens(A, k-1, k)\n\t\t\tleft_mul!(A, g)\n\t\t\tright_mul!(Q, g)\n\t\tend\n\t\tgivens_qr!(view(Q, :, 2:m), view(A, 2:m, 2:n))\n\t\treturn Q, A\n\tend\nend\n\n@testset \"givens QR\" begin\n\tn = 3\n\tA = randn(n, n)\n\tR = copy(A)\n\tQ, R = givens_qr!(Matrix{Float64}(I, n, n), R)\n\t@test Q * R ≈ A\n\t@test Q * Q' ≈ I\n\t@info R\nend","category":"page"},{"location":"chap3/qr/#Gram-Schmidt-Orthogonalization","page":"Review: Solving linear equations","title":"Gram-Schmidt Orthogonalization","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"q_k = left(a_k - sum_i=1^k-1 r_ikq_iright)r_kk","category":"page"},{"location":"chap3/qr/#Algorithm:-Classical-Gram-Schmidt-Orthogonalization","page":"Review: Solving linear equations","title":"Algorithm: Classical Gram-Schmidt Orthogonalization","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"function classical_gram_schmidt(A::AbstractMatrix{T}) where T\n\tm, n = size(A)\n\tQ = zeros(T, m, n)\n\tR = zeros(T, n, n)\n\tR[1, 1] = norm(view(A, :, 1))\n\tQ[:, 1] .= view(A, :, 1) ./ R[1, 1]\n\tfor k = 2:n\n\t\tQ[:, k] .= view(A, :, k)\n\t\t# project z to span(A[:, 1:k-1])⊥\n\t\tfor j = 1:k-1\n\t\t\tR[j, k] = view(Q, :, j)' * view(A, :, k)\n\t\t\tQ[:, k] .-= view(Q, :, j) .* R[j, k]\n\t\tend\n\t\t# normalize the k-th column\n\t\tR[k, k] = norm(view(Q, :, k))\n\t\tQ[:, k] ./= R[k, k]\n\tend\n\treturn Q, R\nend\n\n@testset \"classical GS\" begin\n\tn = 10\n\tA = randn(n, n)\n\tQ, R = classical_gram_schmidt(A)\n\t@test Q * R ≈ A\n\t@test Q * Q' ≈ I\n\t@info R\nend","category":"page"},{"location":"chap3/qr/#Algorithm:-Modified-Gram-Schmidt-Orthogonalization","page":"Review: Solving linear equations","title":"Algorithm: Modified Gram-Schmidt Orthogonalization","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"function modified_gram_schmidt!(A::AbstractMatrix{T}) where T\n\tm, n = size(A)\n\tQ = zeros(T, m, n)\n\tR = zeros(T, n, n)\n\tfor k = 1:n\n\t\tR[k, k] = norm(view(A, :, k))\n\t\tQ[:, k] .= view(A, :, k) ./ R[k, k]\n\t\tfor j = k+1:n\n\t\t\tR[k, j] = view(Q, :, k)' * view(A, :, j)\n\t\t\tA[:, j] .-= view(Q, :, k) .* R[k, j]\n\t\tend\n\tend\n\treturn Q, R\nend\n\n@testset \"modified GS\" begin\n\tn = 10\n\tA = randn(n, n)\n\tQ, R = modified_gram_schmidt!(copy(A))\n\t@test Q * R ≈ A\n\t@test Q * Q' ≈ I\n\t@info R\nend\n\nlet\n\tn = 100\n\tA = randn(n, n)\n\tQ1, R1 = classical_gram_schmidt(A)\n\tQ2, R2 = modified_gram_schmidt!(copy(A))\n\t@info norm(Q1' * Q1 - I)\n\t@info norm(Q2' * Q2 - I)\nend","category":"page"},{"location":"chap3/qr/#Eigenvalue/Singular-value-decomposition-problem","page":"Review: Solving linear equations","title":"Eigenvalue/Singular value decomposition problem","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Ax = lambda x","category":"page"},{"location":"chap3/qr/#Power-method","page":"Review: Solving linear equations","title":"Power method","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"matsize = 10\n\nA10 = randn(matsize, matsize); A10 += A10'\n\neigen(A10).values\n\nvmax = eigen(A10).vectors[:,end]\n\nlet\n\tx = normalize!(randn(matsize))\n\tfor i=1:20\n\t\tx = A10 * x\n\t\tnormalize!(x)\n\tend\n\t1-abs2(x' * vmax)\nend","category":"page"},{"location":"chap3/qr/#Rayleigh-Quotient-Iteration","page":"Review: Solving linear equations","title":"Rayleigh Quotient Iteration","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"let\n\tx = normalize!(randn(matsize))\n\tU = eigen(A10).vectors\n\tfor k=1:5\n\t\tsigma = x' * A10 * x\n\t\ty = (A10 - sigma * I) \\ x\n\t\tx = normalize!(y)\n\tend\n\t(x' * U)'\nend","category":"page"},{"location":"chap3/qr/#Symmetric-QR-decomposition","page":"Review: Solving linear equations","title":"Symmetric QR decomposition","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"function householder_trid!(Q, a)\n\tm, n = size(a)\n\t@assert m==n && size(Q, 2) == n\n\tif m == 2\n\t\treturn Q, a\n\telse\n\t\t# apply householder matrix\n\t\tH = householder_matrix(view(a, 2:n, 1))\n\t\tleft_mul!(view(a, 2:n, :), H)\n\t\tright_mul!(view(a, :, 2:n), H')\n\t\t# update Q matrix\n\t\tright_mul!(view(Q, :, 2:n), H')\n\t\t# recurse\n\t\thouseholder_trid!(view(Q, :, 2:n), view(a, 2:m, 2:n))\n\tend\n\treturn Q, a\nend\n\n@testset \"householder tridiagonal\" begin\n\tn = 5\n\ta = randn(n, n)\n\ta = a + a'\n\tQ = Matrix{Float64}(I, n, n)\n\tQ, T = householder_trid!(Q, copy(a))\n\t@test Q * T * Q' ≈ a\nend","category":"page"},{"location":"chap3/qr/#The-SVD-algorithm","page":"Review: Solving linear equations","title":"The SVD algorithm","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A = U S V^T","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Form C = A^T A,\nUse the symmetric QR algorithm to compute V_1^T C V_1 = rm diag(sigma_i^2),\nApply QR with column pivoting to AV_1 obtaining U^T(AV_1)Pi = R.","category":"page"},{"location":"chap3/qr/#Assignments","page":"Review: Solving linear equations","title":"Assignments","text":"","category":"section"},{"location":"chap3/qr/#1.-Review","page":"Review: Solving linear equations","title":"1. Review","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Suppose that you are computing the QR factorization of the matrix","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"A = left(beginmatrix\n1  1  1\n1  2  4\n1  3  9\n1  4  16\nendmatrixright)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"by Householder transformations.","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Problems:\nHow many Householder transformations are required?\nWhat does the first column of A become as a result of applying the first Householder transformation?\nWhat does the first column of A become as a result of applying the second Householder transformation?\nHow many Givens rotations would be required to computing the QR factoriazation of A?","category":"page"},{"location":"chap3/qr/#2.-Coding","page":"Review: Solving linear equations","title":"2. Coding","text":"","category":"section"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Computing the QR decomposition of a symmetric triangular matrix with Givens rotation. Try to minimize the computing time and estimate the number of FLOPS.","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"For example, if the input matrix size is T in mathbbR^5times 5","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"T = left(beginmatrix\nt_11  t_12  0  0  0\nt_21  t_22  t_23  0  0\n0  t_32  t_33  t_34  0\n0  0  t_43  t_44  t_45\n0  0  0  t_54  t_55\nendmatrixright)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"where t_ij = t_ji.","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"In your algorithm, you should first apply Givens rotation on row 1 and 2.","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"G(t_11 t_21) T = left(beginmatrix\nt_11  t_12  t_13  0  0\n0  t_22  t_23  0  0\n0  t_32  t_33  t_34  0\n0  0  t_43  t_44  t_45\n0  0  0  t_54  t_55\nendmatrixright)","category":"page"},{"location":"chap3/qr/","page":"Review: Solving linear equations","title":"Review: Solving linear equations","text":"Then apply G(t_22 t_32) et al.","category":"page"},{"location":"#Scientific-Computing-for-Physicists","page":"Home","title":"Scientific Computing for Physicists","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Who-should-read-this-book?","page":"Home","title":"Who should read this book?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I am a book for those who aim to become professional scientific computing programmers. Before reading me, please make sure","category":"page"},{"location":"","page":"Home","title":"Home","text":"the problem you are trying to solve runs more than 10min,\nyou want to become a tool builder rather than tools user, and you are happy with writing the tool with the Julia programming language.","category":"page"}]
}
