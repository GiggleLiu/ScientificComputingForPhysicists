var documenterSearchIndex = {"docs":
[{"location":"chap2/performance/#Understanding-Performance","page":"Understanding Performance","title":"Understanding Performance","text":"","category":"section"},{"location":"chap2/performance/#Array","page":"Understanding Performance","title":"Array","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Initializing an array in Julia is simple. You can initialize an array with different types of elements.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"zero_vector = zeros(3) # zero vector\ndirect_matrix = [5 2 1; 1 4 5; 2 4 9] # explicit\nrand_vector = randn(Float32, 3, 3) # random normal distribution\nstep_vector = collect(1:3)  # collect from a range\nuninitialized_vector = Vector{Int}(undef, 3) # uninitialized vector of size 3","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Julia array is fast. In memory, it is a contiguous block if the element type is bitstype - having a fixed size in memory.\nisbitstype(Int)\nisbitstype(Complex{Float64})   # complex number has a fixed size\nsizeof(Complex{Float64})\nisbitstype(typeof(('a', 2, false)))  # tuple has a fixed size\nsizeof(typeof(('a', 2, false)))\nisbitstype(typeof(randn(3)))   # array does not have a fixed size\nsizeof(typeof(randn(3)))  # an array of array may cause slow indexing.\nJulia array memory layout is column-major. Looping over the first index is faster than looping over the last index.\nfunction mysum_col(A::AbstractMatrix)\n    s = zero(eltype(A)) # zero of the element type of A\n    for j in 1:size(A, 2) # loop over the second index\n        for i in 1:size(A, 1)  # loop over the first index\n            s += A[i, j]\n        end\n    end\n    return s\nend\nfunction mysum_row(A::AbstractMatrix)\n    s = zero(eltype(A)) # zero of the element type of A\n    for i in 1:size(A, 1)  # loop over the first index\n       for j in 1:size(A, 2) # loop over the second index\n            s += A[i, j]\n        end\n    end\n    return s\nend\nFor small scale matrix, their performance is similar since the matrix can be cached well. However, for large scale matrix, the column-major layout is much faster due to the cache locality.\njulia> using BenchmarkTools\n\njulia> A = rand(10000, 10000);\n\njulia> @btime mysum_col($A)\n  85.885 ms (0 allocations: 0 bytes)\n4.999830721534851e7\n\njulia> @btime mysum_row($A)\n  189.794 ms (0 allocations: 0 bytes)\n4.9998307215344414e7\nJulia array indexing starts from 1. It is different from C, Python, and R, which start from 0. 😞\nA = [1, 2, 3]\nA[1]     # the first element\nA[end]   # the last element\nA[1:2]   # the first two elements\nA[2:-1:1] # the first two elements in the reversed order\nB = [1 2 3; 4 5 6; 7 8 9];\nB[1:2]   # the first two elements, returns B[1,1] and B[2,1] since B is column-major\nB[1:2, 1:2] # returns a submatrix","category":"page"},{"location":"chap2/performance/#Broadcasting","page":"Understanding Performance","title":"Broadcasting","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Julia has a powerful broadcasting mechanism. It is a way to apply a function to each element of an array. The broadcasting is done by adding a dot . before the function name.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"x = 0:0.1:2π\ny = sin.(x) .+ cos.(3 .* x);","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"using Plots  # for high-quality plots, we suggest using `Makie.jl`\nPlots.plot(x, y; label=\"sin(x) + cos(3x)\")","category":"page"},{"location":"chap2/performance/#Loop-fusion","page":"Understanding Performance","title":"Loop fusion","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"The broadcasting is very efficient due to loop fusion. In the above example, only one loop is needed to calculate sin and cos for each element of x and only one array is allocated to store the result.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Loop fused:","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"julia> using BenchmarkTools\njulia> @benchmark sin.($x) .+ cos.(3 .* $x);\nBenchmarkTools.Trial: 10000 samples with 107 evaluations.\n Range (min … max):  775.308 ns …  2.984 μs  ┊ GC (min … max): 0.00% … 62.53%\n Time  (median):     781.159 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   798.606 ns ± 78.472 ns  ┊ GC (mean ± σ):  0.28% ±  2.36%\n\n  ▅█▄    ▁ ▃▂ ▃▄▁      ▁                                       ▁\n  ███▆▆▇██▇██▆███▇▆▆▆▆▇██▆▆▅▆▅▅▅▆▅▇▆▅▅▅▄▅▄▅▆▅▅▅▄▄▄▅▅▅▄▄▄▄▃▄▅▅▆ █\n  775 ns        Histogram: log(frequency) by time       995 ns <\n\n Memory estimate: 576 bytes, allocs estimate: 1.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Loop not fused","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"julia> @benchmark sin.($x) + cos.(3 * $x);\nBenchmarkTools.Trial: 10000 samples with 107 evaluations.\n Range (min … max):  778.430 ns …  2.714 μs  ┊ GC (min … max): 0.00% … 66.36%\n Time  (median):     802.570 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   809.210 ns ± 66.113 ns  ┊ GC (mean ± σ):  0.26% ±  2.30%\n\n   ▃        ▅█▇▄        ▂   ▄▄                                 ▂\n  ███▄▁▁▁▃▄█████▇▆▇▇▇█▅███▆███▇▄▅▃▅▇▇▇▆▅▆▅▅▅▅▆▆▅▅▄▅▄▃▄▄▄▃▄▅▄▄▆ █\n  778 ns        Histogram: log(frequency) by time       900 ns <\n\n Memory estimate: 576 bytes, allocs estimate: 1.","category":"page"},{"location":"chap2/performance/#When-shapes-do-not-match","page":"Understanding Performance","title":"When shapes do not match","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"A = [1 2 3; 4 5 6]\nB = [1 2 3]\nA .+ B   # B is broadcasted to match the size of A","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"B is a (column) vector, which means its shape is (3, 1). The broadcasting is done by repeating the vector to match the shape of A.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"With this trick, we can easily evaluate a function on a meshgrid.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"a = sin.(x) + cos.(3 * x);\nb = cos.(x);\nmesh = a' .* b # a has shape (1, length(x)), b has shape (length(x), 1)","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"heatmap(mesh)","category":"page"},{"location":"chap2/performance/#Unwanted-broadcasting","page":"Understanding Performance","title":"Unwanted broadcasting","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Consider we have a vector, and we want to scale it with factors 1, 2, 3 and store the results in to a vector, i.e. we will get a vector of vectors. The following code will not work as expected.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"[3,2,1,0] .* (1:3)","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Note a range is an iterable object. The broadcasting operation works on any iterable object, hence it tries to broadcast over the elements of the vector. A shape mismatch error is raised, which is unwanted.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"In this case, we can use Ref to protect the vector from broadcasting.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Ref([3,2,1,0]) .* (1:3)","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"We can see the vector is treated as a whole.","category":"page"},{"location":"chap2/performance/#Example:-create-a-meshgrid-for-triangular-lattice","page":"Understanding Performance","title":"Example: create a meshgrid for triangular lattice","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"b1 = [1, 0]\nb2 = [0.5, sqrt(3)/2]\nn = 5\nmesh1 = [i * b1 + j * b2 for i in 1:n, j in 1:n]  # list comprehension\nmesh2= (1:n) .* Ref(b1) .+ (1:n)' .* Ref(b2)  # broadcasting","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"scatter(vec(getindex.(mesh2, 1)), vec(getindex.(mesh2, 2)), label=\"mesh2\", ratio=1, markersize=5)","category":"page"},{"location":"chap2/performance/#Case-study:-Image-processing","page":"Understanding Performance","title":"Case study: Image processing","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Download an image from the internet:","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"url = \"https://avatars.githubusercontent.com/u/8445510?v=4\"\ntarget_path = tempname() * \".png\"\ndownload(url, target_path)","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Load the image with Images.jl:","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"#using Images\n#img = load(target_path)\nnothing","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Quiz:","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"How to invert the color of the image?","category":"page"},{"location":"chap2/performance/#Array-element-type-and-performance","page":"Understanding Performance","title":"Array element type and performance","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Any type vector is flexible. You can add any element into it.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"vany = Any[]  # same as vany = []\ntypeof(vany)\npush!(vany, \"a\")\npush!(vany, 1)","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Fixed typed vector is more restrictive.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"vfloat64 = Float64[]\nvfloat64 |> typeof\npush!(vfloat64, \"a\")","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"The performance of the vector with a fixed type is much better than the vector with any type.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"julia> biganyv = collect(Any, 1:2:20000);\n\njulia> @benchmark for i=1:length($biganyv)\n    $biganyv[i] += 1\nend\nBenchmarkTools.Trial: 10000 samples with 1 evaluation.\n Range (min … max):  117.833 μs …  1.090 ms  ┊ GC (min … max): 0.00% … 71.28%\n Time  (median):     124.458 μs              ┊ GC (median):    0.00%\n Time  (mean ± σ):   128.512 μs ± 39.121 μs  ┊ GC (mean ± σ):  1.55% ±  4.49%\n\n  ▁   ▃▇█▅▂▂▅▆▄▂▃▄▃▃▄▄▄▃▂▂▂▂▁▁▁▁▁▁                             ▂\n  █▆▄▄█████████████████████████████████▇█▇▇▇█▇▇▇▆▆▄▆▆▆▅▅▅▅▅▅▂▄ █\n  118 μs        Histogram: log(frequency) by time       155 μs <\n\n Memory estimate: 156.25 KiB, allocs estimate: 10000.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"julia> bigfloatv = collect(Float64, 1:2:20000);\n\njulia> @benchmark for i=1:length($bigfloatv)\n    $bigfloatv[i] += 1\nend\nBenchmarkTools.Trial: 10000 samples with 40 evaluations.\n Range (min … max):  908.325 ns …  2.020 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     936.475 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   955.204 ns ± 69.933 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▃   ▇█  ▂▅▁  ▁     ▂                                         ▁\n  █▄▃▃██▇▆███▇▆█▆█▇▄▆█▇▆▆▆█▇▇▆▇▇▇▇▆▅▅▆▆▆▅▅▅▅▃▄▅▄▅▄▄▃▄▄▄▄▄▄▅▅▄▆ █\n  908 ns        Histogram: log(frequency) by time      1.24 μs <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"We can see that the performance of the vector with a fixed type can be 100 times faster than the vector with any type.","category":"page"},{"location":"chap2/performance/#Benchmark-and-profile","page":"Understanding Performance","title":"Benchmark and profile","text":"","category":"section"},{"location":"chap2/performance/#How-to-measure-the-performance-of-your-CPU?","page":"Understanding Performance","title":"How to measure the performance of your CPU?","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"The performance of a CPU is measured by the number of floating point operations per second (FLOPS) it can perform. The floating point operations include addition, subtraction, multiplication and division. The FLOPS can be related to multiple factors, such as the clock frequency, the number of cores, the number of instructions per cycle, and the number of floating point units. A simple way to measure the FLOPS is to benchmarking the speed of matrix multiplication.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"julia> using BenchmarkTools\n\njulia> A, B = rand(1000, 1000), rand(1000, 1000);\n\njulia> @btime $A * $B;\n  12.122 ms (2 allocations: 7.63 MiB)","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"The number of FLOPS in a ntimes ntimes n matrix multiplication is 2n^3. The FLOPS can be calculated as: 2 times 1000^3  (12122 times 10^-3) = 165rm GFLOPS.","category":"page"},{"location":"chap2/performance/#Profiling","page":"Understanding Performance","title":"Profiling","text":"","category":"section"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Profiling is a way to measure the performance of your code. It can help you to identify the bottleneck of your code and optimize it. The Profile module in Julia provides a set of tools to profile your code.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"We can start the profiler by","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"julia> using Profile\n\njulia> Profile.init(n = 10^7, delay = 0.01) # set the number of samples and the delay between samples","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"Then you can profile your code by running it.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"julia> @profile A * B","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"To view the profile result, you can use the Profile.print() function.","category":"page"},{"location":"chap2/performance/","page":"Understanding Performance","title":"Understanding Performance","text":"julia> Profile.print(; format=:flat, mincount=10)","category":"page"},{"location":"chap1/git/#Maintainability-Version-Control","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Maintaining a software project is not easy, especially when it comes to multiple developers working on the same piece of code. When adding a new feature to the project, maintainers may encounter the following problems:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Multiple developers modify the same file at the same time, works can not be merged easily.\nNew code breaks an existing feature, downstream users are affected.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"The solution to the above problems is version-control. Among all version control software, git is the most popular one.","category":"page"},{"location":"chap1/git/#Create-a-git-repository","page":"Maintainability - Version Control","title":"Create a git repository","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"A git repository, also known as a repo, is basically a directory where your project lives and git keeps track of your file's history. To get started, you start with a terminal and type","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"cd path/to/working/directory\ngit init\necho \"Hello, World\" > README.md\ngit add -A\ngit commit -m 'this is my initial commit'\ngit status","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: changes the directory to the working directory, which can be either an existing directory or a new directory.\nLine 2: initializes a git repository in the working directory. A .git directory is created in the working directory, which contains all the necessary metadata for the repo.\nLine 3: creates a file README.md with the content Hello, World. The file README.md is a markdown file, which is a lightweight markup language with plain-text-formatting syntax. You can learn more about markdown from the markdown tutorial. This line can be omitted if the working directory already contains files.\nLine 4: line add files to the staging area (area that caches changes that to be committed).\nLine 5: commits the changes to the repository, which will create a snapshot of your current work.\nLine 6: shows the status of the working directory, staging area, and repository. If the above commands are executed correctly, the output should be nothing to commit, working tree clean.","category":"page"},{"location":"chap1/git/#Track-the-changes-checkout,-diff,-log","page":"Maintainability - Version Control","title":"Track the changes - checkout, diff, log","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Git enables developers to track changes in their codebase. Continuing the previous example, we can analyze the repository with the following commands:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"echo \"Bye Bye, World\" > README.md\ngit diff\ngit add -A\ngit commit -m 'a second commit'\ngit log\ngit checkout HEAD~1\ngit checkout main","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: makes changes to the file README.md.\nLine 2: shows the changes made to the file README.md.\nLine 3-4: adds the changes to the staging area and commits the changes to the repository.\nLine 5: shows the history of commits. The output should be something like this:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"commit 02cd535b6d78fca1713784c61eec86e67ce9010c (HEAD -> main)\nAuthor: GiggleLiu <cacate0129@gmail.com>\nDate:   Mon Feb 5 14:34:20 2024 +0800\n\n    a second commit\n\ncommit 570e390759617a7021b0e069a3fbe612841b3e50\nAuthor: GiggleLiu <cacate0129@gmail.com>\nDate:   Mon Feb 5 14:23:41 2024 +0800\n\n    this is my initial commit","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 6: Checkout the previous snapshot. Note HEAD is your current snapshot and HEAD~n is the nth snapshot counting back from the current snapshot.\nLine 7: Return to the main branch, which points to the latest snapshot. We will discuss more about branch later in this tutorial.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"You can use git reset to reset the current HEAD to the specified snapshot, which can be useful when you committed something bad by accident.","category":"page"},{"location":"chap1/git/#Work-on-cloud-remotes","page":"Maintainability - Version Control","title":"Work on cloud - remotes","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"A server to store git repository, or remote in git terminology, is required for the collaboration purpose. Remote repositories can be hosted on git hosting services like GitHub, GitLab, or Bitbucket. After creating a new empty repository (no README files) on a git hosting service (How to create a new github repo?), a URL for cloning the repo will show up, which that usually starts with git or https. Let us denote this URL as <url> and continue the previous example:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git remote add origin <url>\ngit remote -v\ngit push origin main","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: add a remote repository, where origin is a tag for the added remote.\nLine 2: shows the URL of all remotes, including the origin remote we just added.\nLine 3: push commits to the main branch of the remote repository origin. This command sometimes could fail due to another commit pushed to the remote earlier, where the commit may from another machine or another person. To resolve the issue, you can use git pull origin main to fetch the latest snapshot on the remote. git pull may also fail, because the remote commit may be incompatible with the local commit, e.g. the same file has been changed. In this worst case, you need to merge two commits manually (link).","category":"page"},{"location":"chap1/git/#Develop-features-safely-branches","page":"Maintainability - Version Control","title":"Develop features safely - branches","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"So far, we worked with a single branch main. A branch in git is a lightweight pointer to a specific commit. Working on a single branch is dangerous due to the following reasons:","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"No usable code. Developers usually develop features based on the current main branch, so the main branch is expected to always usable. However, working on a single branch can easily break this rule.\nHard to resolve conflicts. when multiple developers modify the same file at the same time, works can not be merged easily. Multiple branches can make the feature development process independent of each other, which can avoid conflicts.\nHard to discard a feature. For some experimental features, you may want to discard it after testing. A commit on the main branch can not be easily reverted.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Understanding the branches is extremely useful when, multiple developers are working on different features.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout -b me/feature\necho \"Hello, World - Version 2\" > README.md\ngit add -A\ngit commit -m 'this is my feature'\ngit push origin me/feature","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Line 1: create and switch to the new branch me/feature. Here, we use the branch name me/feature to indicate that this branch is for the feature developed by me, which is a matter of convention.\nLine 2-5: makes some changes to the file README.md and commits the changes to the repository. Finally, the changes are pushed to the remote repository origin. The remote branch me/feature is created automatically.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"While developing a feature, you or another developer may want to develop another feature based on the current main branch. You can create another branch other/feature and develop the feature there.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout main\ngit checkout -b other/feature\necho \"Bye Bye, World - Version 2\" > feature.md\ngit add -A\ngit commit -m 'this is another feature'\ngit push origin other/feature","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"In the above example, we created a new branch other/feature based on the main branch, and made some changes to the file feature.md.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Finally, when the feature is ready, you can merge the feature branch to the main branch.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"git checkout main\ngit merge me/feature\ngit push origin main","category":"page"},{"location":"chap1/git/#Working-with-others-issues-and-pull-requests","page":"Maintainability - Version Control","title":"Working with others - issues and pull requests","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"When working with others, you may want to propose changes to a repository and discuss them with others. This is where issues and pull requests come in. Issues and pull requests are features of git hosting services like GitHub and GitLab.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"Issue is relatively simple, it is a way to report a bug or request a feature.\nPull request (resource: how to create a pull request) is a way to propose changes to a repository and discuss them with others. It is also a way to merge code from source branch to target branch. The source branch can be a branch in the same repository or a branch in a forked repository - a copy of the repository in your account. Forking a repository is needed when you want to propose changes to a repository that you do not have write access to.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"note: Should I make a pull requests or push directly to main branch?\nTo update the main branch, one should use pull requests as much as possible, even if you have write access to the repository. It is a good practice to discuss the changes with others before merging them to the main branch. A pull request also makes the changes more traceable, which is useful when you want to revert the changes.","category":"page"},{"location":"chap1/git/#Git-cheat-sheet","page":"Maintainability - Version Control","title":"Git cheat sheet","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"It is not possible to cover all the feature of git. We will list a few useful commands and resources for git learning.","category":"page"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"# global config\ngit config  # Get and set repository or global options\n\n# initialize a repo\ngit init    # Create an empty Git repo or reinitialize an existing one\ngit clone   # Clone repository into new directory\n\n# info\ngit status  # Show the working tree status\ngit log     # Show commit logs\ngit diff    # Show changes between commits, commit and working tree, etc\n\n# work on a branch\ngit add     # Add file contents to the index\ngit rm      # Remove files from the working tree and from the index\ngit commit  # Record changes to the repository\ngit reset   # Reset current HEAD to the specified state\n\n# branch manipulation\ngit checkout # Switch branches or restore working tree files\ngit branch  # List, create, or delete branches\ngit merge   # Join two or more development histories together\n\n# remote synchronization\ngit remote  # Manage set of tracked repositories\ngit pull  # Fetch from and integrate with another repo or a local branch\ngit fetch   # Download objects and refs from another repository\ngit push    # Update remote refs along with associated objects","category":"page"},{"location":"chap1/git/#Resources","page":"Maintainability - Version Control","title":"Resources","text":"","category":"section"},{"location":"chap1/git/","page":"Maintainability - Version Control","title":"Maintainability - Version Control","text":"The Official GitHub Training Manual\nMIT online course missing semester.","category":"page"},{"location":"chap1/ci/#Correctness-Unit-Tests","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"In terms of scientific computing, accuracy of your result is most certainly more important than anything else. To ensure the correctness of the code, we employ two methods: Unit Testing and CI/CD.","category":"page"},{"location":"chap1/ci/#Unit-Test","page":"Correctness - Unit Tests","title":"Unit Test","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"Unit tests are typically automated tests written and run by software developers to ensure that a section of an application (known as the \"unit\") meets its design and behaves as intended. Unit tests are composed of a series of individual test cases, each of which verifies the correctness by using assertions. If all assertions are true, the test case passes; otherwise, it fails. The unit tests are run automatically whenever the code is changed, ensuring that the code is always in a working state. In Julia, there exists a helpful module called Test to help you do unit testing.","category":"page"},{"location":"chap1/ci/#Automate-your-workflow-CI/CD","page":"Correctness - Unit Tests","title":"Automate your workflow - CI/CD","text":"","category":"section"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"CI/CD, which stands for continuous integration and continuous delivery/deployment, aims to streamline and accelerate the software development lifecycle. CI/CD are often integrated with git hosting services, e.g. Github Actions. Typical CI/CD pipelines include the following steps:","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"Automatically build, test and merge the code changes whenever a developer commits code to the repository.\nAutomatically deploy the code or documentation to a cloud service.","category":"page"},{"location":"chap1/ci/","page":"Correctness - Unit Tests","title":"Correctness - Unit Tests","text":"The CI/CD pipeline is a powerful tool to ensure the correctness of the code and the reproducibility of the results. It is also a good practice to use CI/CD to automate the workflow, especially when you are working with a team.","category":"page"},{"location":"chap1/opensource_scientist/#Becoming-an-Open-Source-Developer","page":"Becoming an Open-Source Developer","title":"Becoming an Open-Source Developer","text":"","category":"section"},{"location":"chap1/opensource_scientist/","page":"Becoming an Open-Source Developer","title":"Becoming an Open-Source Developer","text":"This section focuses on understanding the open source workflow, which is the foundation of scientific computing. Along the way, we will introduce to you our recommended tools for accomplishing each task. ","category":"page"},{"location":"chap2/julia-setup/#Setup-Julia","page":"Setup Julia","title":"Setup Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julia is a high-level, high-performance, dynamic programming language. From the designing stage, Julia is intended to address the needs of high-performance numerical analysis and computational science, without the typical need of separate compilation to be fast, while also being effective for general-purpose programming, web use or as a specification language. Julia is also a free and open-source language, with a large community and a rich ecosystem.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"We will devlve deeper into Julia later in the chapter. For now, we will just install Julia and setup the environment.","category":"page"},{"location":"chap2/julia-setup/#Step-1:-Installing-Julia","page":"Setup Julia","title":"Step 1: Installing Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"For Linux/Mac users, please open a terminal and type the following command to install Julia with juliaup. Juliaup is a tool to manage Julia versions and installations. It allows you to install multiple versions of Julia and switch between them easily.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"curl -fsSL https://install.julialang.org | sh # Linux and macOS","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"For Windows users, please open execute the following command in a cmd,","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"winget install julia -s msstore # Windows","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You can also install Juliaup directly from Windows Store.","category":"page"},{"location":"chap2/julia-setup/#For-users-suffering-from-the-slow-download-speed","page":"Setup Julia","title":"For users suffering from the slow download speed","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Network connectivity can be an issue for some users, especially for those who are in China. You may need to specify another server for installing Juliaup and Julia packages. To do so, execute the following command in your terminal before running the script above.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Linux and macOS","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"export JULIAUP_SERVER=https://mirror.nju.edu.cn/julia-releases/ # Linux & macOS\nexport JULIA_PKG_SERVER=https://mirrors.nju.edu.cn/julia","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Windows","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"$env:JULIAUP_SERVER=\"https://mirror.nju.edu.cn/julia-releases/\" # Windows\n$env:JULIA_PKG_SERVER=\"https://mirrors.nju.edu.cn/julia\"","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"An alternative approach is downloading the corresponding Julia binary from the Nanjing university mirror website. After installing the binary, please set the Julia binary path properly if you want to start a Julia REPL from a terminal, check this manual page to learn more.","category":"page"},{"location":"chap2/julia-setup/#Installing-Julia","page":"Setup Julia","title":"Installing Julia","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To verify that Julia is installed, please open a new terminal and run the following command in your terminal.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"It should start a Julia REPL(Read-Eval-Print-Loop) session like this","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"<!– (Image: REPL Session) –>","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"If you wish to install a specific version of Julia, please refer to the documentation.","category":"page"},{"location":"chap2/julia-setup/#Step-2:-Package-Management","page":"Setup Julia","title":"Step 2: Package Management","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julia has a mature eco-system for scientific computing.\nPkg is the built-in package manager for Julia.\nTo enter the package manager, press ] in the REPL.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"(Image: PackageMangement)","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"The environment is indicated by the (@v1.9).\nTo add a package, type add <package name>.\nTo exit the package manager press backspace key\nRead More","category":"page"},{"location":"chap2/julia-setup/#Step-3.-Configure-the-startup-file","page":"Setup Julia","title":"Step 3. Configure the startup file","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"First create a new file ~/.julia/config/startup.jl by executing the following commands ","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"mkdir -r ~/.julia/config touch ~/.julia/config/startup.jl","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You could open the file with your favourite editor and add the following content","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"try\n    using Revise\ncatch e\n    @warn \"fail to load Revise.\"\nend","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"The contents in the startup file is executed immediately after you open a new Julia session.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Then you need to install Revise, which is an Julia package that can greatly improve the using experience of Julia. To install Revise, open Julia REPL and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia> using Pkg; Pkg.add(\"Revise\")","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"If you don't know about startup.jl and where to find it, here is a good place for further information. ","category":"page"},{"location":"chap2/julia-setup/#More-Packages","page":"Setup Julia","title":"More Packages","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"You may find more Julia packages here.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"As a final step, please verify your Julia configuration by openning a Julia REPL and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"julia> versioninfo()\nJulia Version 1.9.2\nCommit e4ee485e909 (2023-07-05 09:39 UTC)\nPlatform Info:\n  OS: macOS (arm64-apple-darwin22.4.0)\n  CPU: 10 × Apple M2 Pro\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, apple-m1)\n  Threads: 1 on 6 virtual cores\nEnvironment:\n  JULIA_NUM_THREADS = 1\n  JULIA_PROJECT = @.\n  JULIA_PKG_SERVER = http://cn-southeast.pkg.juliacn.com/ ","category":"page"},{"location":"chap2/julia-setup/#Step-4.-Download-an-editor:-VSCode","page":"Setup Julia","title":"Step 4. Download an editor: VSCode","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Install VSCode by downloading the correct binary for your platform from here. Open VSCode and open the Extensions tab on the left side-bar of the window, search Julia and install the most popular extension: julia-vscode","category":"page"},{"location":"chap2/julia-setup/#The-four-modes-of-Julia-REPL","page":"Setup Julia","title":"The four modes of Julia REPL","text":"","category":"section"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"A Julia REPL has four modes,","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Julian mode is the default mode that can interpret your Julia code.\nShell mode is the mode that you can run shell commands. Press ; in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"shell> date\nSun Nov  6 10:50:21 PM CST 2022","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the <kbd>Backspace</kbd> key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Package mode is the mode that you can manage packages. Press ] in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"(@v1.8) pkg> st\nStatus `~/.julia/environments/v1.8/Project.toml`\n  [295af30f] Revise v3.4.0","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the <kbd>Backspace</kbd> key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"Help mode is the mode that you can access the docstrings of functions. Press ? in the Julian mode and type","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"help> sum\n... docstring for sum ...","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"To return to the Julian mode, type the <kbd>Backspace</kbd> key.","category":"page"},{"location":"chap2/julia-setup/","page":"Setup Julia","title":"Setup Julia","text":"read more...","category":"page"},{"location":"chap2/julia-visualization/","page":"-","title":"-","text":"using GLMakie # All functionality is defined in Makie and every backend re-exports Makie\n\nBase.@kwdef mutable struct Lorenz\n    dt::Float64 = 0.01\n    σ::Float64 = 10\n    ρ::Float64 = 28\n    β::Float64 = 8/3\n    x::Float64 = 1\n    y::Float64 = 1\n    z::Float64 = 1\nend\n\nfunction step!(l::Lorenz)\n    dx = l.σ * (l.y - l.x)\n    dy = l.x * (l.ρ - l.z) - l.y\n    dz = l.x * l.y - l.β * l.z\n    l.x += l.dt * dx\n    l.y += l.dt * dy\n    l.z += l.dt * dz\n    Point3f(l.x, l.y, l.z)\nend\n\nattractor = Lorenz()\n\npoints = Observable(Point3f[]) # Signal that can be used to update plots efficiently\ncolors = Observable(Int[])\n\nset_theme!(theme_black())\n\nfig, ax, l = lines(points, color = colors,\n    colormap = :inferno, transparency = true, \n    axis = (; type = Axis3, protrusions = (0, 0, 0, 0), \n              viewmode = :fit, limits = (-30, 30, -30, 30, 0, 50)))\n\nrecord(fig, \"lorenz.mp4\", 1:120) do frame\n    for i in 1:50\n        # update arrays inplace\n        push!(points[], step!(attractor))\n        push!(colors[], frame)\n    end\n    ax.azimuth[] = 1.7pi + 0.3 * sin(2pi * frame / 120) # set the view angle of the axis\n    notify(points); notify(colors) # tell points and colors that their value has been updated\n    l.colorrange = (0, frame) # update plot attribute directly\nend","category":"page"},{"location":"chap1/terminal/#Get-a-Terminal!","page":"Get a Terminal!","title":"Get a Terminal!","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"You need to get a working terminal to follow the instructions in this book, because every cool guy needs a terminal.","category":"page"},{"location":"chap1/terminal/#Linux-operating-system","page":"Get a Terminal!","title":"Linux operating system","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Using Linux is the most straight-forward way to get a terminal. Just like Windows, IOS, and macOS, Linux is an operating system. In fact, Android, one of the most popular platforms on the planet, is powered by the Linux operating system. It is free to use, open source, widely used on clusters and good at automating your works. Linux kernel and Linux distribution are different concepts.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Linux kernel is started by Linus Torvalds in 1991.\nA Linux distribution is an operating system made from a software collection that includes the Linux kernel and, often, a package management system.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Linux distribution used in this course is Ubuntu.","category":"page"},{"location":"chap1/terminal/#Shell-(or-Terminal)","page":"Get a Terminal!","title":"Shell (or Terminal)","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Although you can use a graphical user interface (GUI) to interact with your Linux distribution, you will find that the command line interface (CLI) is more efficient and powerful. The CLI is also known as the shell or terminal.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The shell is a program that takes commands from the keyboard and gives them to the operating system to perform. Zsh and Bash are two popular shell interpreters used in the Linux operating systems.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Bash is the default shell on most Linux distributions.\nZsh (with oh-my-zsh extension) is an extended version of the shell, with a more powerful command-line editing and completion system. It includes features like spelling correction and tab-completion, and it also supports plugins and themes.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"In Ubuntu, one can use Ctrl + Alt + T to open a shell. In a shell, we use","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"man command_name to get help information related to a command,\nCTRL-C to break a program and\nCTRL-D to exit a shell or an REPL.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The following is a short list of bash commands that will be used frequently in this book.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"man     # an interface to the system reference manuals\n\nls      # list directory contents\ncd      # change directory\nmkdir   # make directories\nrm      # remove files or directories\npwd     # print name of current/working directory\n\necho    # display a line of text\ncat     # concatenate files and print on the standard output\n\nalias   # create an alias for a command\n\nlscpu   # display information about the CPU architecture\nlsmem   # list the ranges of available memory with their online status\n\ntop     # display Linux processes\nssh     # the OpenSSH remote login client\nvim     # Vi IMproved, a programmer's text editor\ngit     # the stupid content tracker\n\ntar     # an archiving utility","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Git Resources","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"MIT Open course: Missing semester\nGet started with the Linux command line and the Shell","category":"page"},{"location":"chap1/terminal/#Editor-in-terminal-Vim","page":"Get a Terminal!","title":"Editor in terminal - Vim","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"To edit files in the terminal, you can use Vim - the default text editor in most Linux distributions. Vim has three primary modes, each tailored for specific tasks. The primary modes include","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Normal Mode, where users can navigate through the file and perform tasks like deleting lines or copying text; One can enter the normal mode by typing ESC;\nInsert Mode, where users can insert text as in conventional text editors; One can enter the insert mode by typing i in the normal mode;\nCommand Mode, where users input commands for tasks like saving files or searching; One can enter the command mode by typing : in the normal mode.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"A few commands are listed below to get you started with Vim.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"i       # input\n:w      # write\n:q      # quit\n:q!     # force quit without saving\n\nu       # undo\nCTRL-R  # redo","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"All the commands must be executed in the normal mode (press ESC if not). To learn more about Vim, please check this lecture.","category":"page"},{"location":"chap1/terminal/#Connect-to-the-remote-SSH","page":"Get a Terminal!","title":"Connect to the remote - SSH","text":"","category":"section"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"The Secure Shell (SSH) protocol is a method for securely sending commands to a computer over an unsecured network. SSH uses cryptography to authenticate and encrypt connections between devices. It is widely used to:","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"push code to a remote git repository,\nlog into a remote machine and execute commands.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"With a host name (the IP of the target machine to login) and a user name, one can use the following command to login,","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh <username>@<hostname>","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"where <username> is the user's account name and <hostname> is the host name or IP of the target machine. You will get logged in after inputting the password.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Tips to make your life easier","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"It will be tedious to type the host name and user name everytime you want to login to the remote machine. You can setup the ~/.ssh/config file to make your life easier. The following is an example of the ~/.ssh/config file.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Host amat5315\n  HostName <hostname>\n  User <username>","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"where amat5315 is the alias of the host. After setting up the ~/.ssh/config, you can login to the remote machine by typing","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh amat5315","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"If you want to avoid typing the password everytime you login, you can use the command ","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh-keygen","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"to generate a pair of public and private keys, which will be stored in the ~/.ssh folder on the local machine. After setting up the keys, you can copy the public key to the remote machine by typing","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"ssh-copy-id amat5315","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"Try connecting to the remote machine again, you will find that you don't need to type the password anymore.","category":"page"},{"location":"chap1/terminal/","page":"Get a Terminal!","title":"Get a Terminal!","text":"note: How does an SSH key pair work?\nThe SSH key pair is a pair of asymmetric keys, one is the public key and the other is the private key. In the above example, the public key is uploaded to the remote machine and the private key is stored on the local machine. The public key can be shared with anyone, but the private key must be kept secret.To connect to a server, the server needs to know that you are the one who with the right to access it. To do so, the server will need to check if you have the private key that corresponds to the public key stored on the server. If you have the private key, you will be granted access to the server.The secret of the SSH key pair is that the public key can be used to encrypt a message that can only be decrypted by the private key, i.e. the public key is more like a lock and the private key is the key to unlock the lock. This is the foundation of the SSH protocol. So server can send you a message encrypted by your public key, and only you can decrypt it with your private key. This is how the server knows that you are the one who has the private key without actually sending the private key to the server.","category":"page"},{"location":"chap2/release/#My-First-Package","page":"My First Package","title":"My First Package","text":"","category":"section"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"One of the most important features of Julia is its package manager. It allows one to create, manage, and publish his own packages. In this section, we will learn how to create a package and publish it to the Julia registry.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Julia package manager can install the correct version of a package and its dependencies because it knows the exact versions of all the packages that are compatible with each other. This information was stored in the General registry - a central GitHub repository of metadata about all registered Julia packages.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Everyone can register a package in the General registry. To do so, you need to:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Create a package.\nSpecify the dependency of your package in the Project.toml file, like which version of a package your package depends on.\nDevelop the package by writing the source code, tests, and documentation.\nOpen-source the package by pushing the package to a public repository on GitHub. GitHub Actions can be used to automate the process of testing, building the documentation, and tagging a release so that other developers can contribute to the package easily.\nRegister the package in the General registry by creating a pull request to the General registry.","category":"page"},{"location":"chap2/release/#Create-a-package","page":"My First Package","title":"Create a package","text":"","category":"section"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"We use PkgTemplate. Open a Julia REPL and type the following commands to initialize a new package named MyFirstPackage:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"julia> using PkgTemplates\n\njulia> tpl = Template(;\n    user=\"GiggleLiu\",\n    authors=\"GiggleLiu\",\n    julia=v\"1.10\",\n    plugins=[\n        License(; name=\"MIT\"),\n        Git(; ssh=true),\n        GitHubActions(; x86=true),\n        Codecov(),\n        Documenter{GitHubActions}(),\n    ],\n)\n\njulia> tpl(\"MyFirstPackage\")","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"where the username \"GiggleLiu\" should be replaced with your GitHub username. Many plugins are used in the above example:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"License: to choose a license for the package. Here we use the MIT license, which is a permissive free software license. Popular licenses include:\nMIT: a permissive free software license, featured with a short and simple permissive license with conditions only requiring preservation of copyright and license notices.\nApache2: a permissive free software license, featured with a contributor license agreement and a patent grant.\nGPL: a copyleft free software license, featured with a strong copyleft license that requires derived works to be available under the same license.\nGit: to initialize a Git repository for the package. Here we use the SSH protocol for Git for convenience. Using two-factor authentication (2FA) can make your GitHub account more secure.\nGitHubActions: to enable continuous integration (CI) with GitHub Actions.\nCodecov: to enable code coverage tracking with Codecov. It is a tool that helps you to measure the test coverage of your code. A package with high test coverage is more reliable.\nDocumenter: to enable documentation building and deployment with Documenter.jl and GitHub pages.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"After running the above commands, a new directory named MyFirstPackage will be created in the folder ~/.julia/dev/ - the default location for Julia packages.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"note: What makes a good package name?\nFor a package that is intended to be registered in the General registry, it is recommended to use a name that follows the Julia package naming guidelines. Although the same registry may not have two packages with the same name, a package use the UUID rather than the name as its unique identifier, because name may not be unique when multiple registries are used together.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"The file structure of the package is as follows:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"tree .   \n.\n├── .git\n│   ...\n├── .github\n│   ├── dependabot.yml\n│   └── workflows\n│       ├── CI.yml\n│       ├── CompatHelper.yml\n│       └── TagBot.yml\n├── .gitignore\n├── LICENSE\n├── Manifest.toml\n├── Project.toml\n├── README.md\n├── docs\n│   ├── Manifest.toml\n│   ├── Project.toml\n│   ├── make.jl\n│   └── src\n│       └── index.md\n├── src\n│   └── MyFirstPackage.jl\n└── test\n    └── runtests.jl","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":".git and .gitignore: the files that are used by Git. The .gitingore file contains the files that should be ignored by Git. By default, the .gitignore file contains the following lines:\n*.jl.*.cov\n*.jl.cov\n*.jl.mem\n/Manifest.toml\n/docs/Manifest.toml\n/docs/build/\n.github: the folder that contains the GitHub Actions configuration files.\nLICENSE: the file that contains the license of the package. The MIT license is used in this package.\nREADME.md: the manual that shows up in the GitHub repository of the package, which contains the description of the package.\nProject.toml: the file that contains the metadata of the package, including the name, UUID, version, dependencies and compatibility of the package.\nManifest.toml: the file that contains the exact versions of all the packages that are compatible with each other. It is usually automatically resolved from the Project.toml file, and it is not recommended pushing it to the remote repository.\ndocs: the folder that contains the documentation of the package. It has its own Project.toml and Manifest.toml files, which are used to manage the documentation environment. The make.jl file is used to build the documentation and the src folder contains the source code of the documentation.\nsrc: the folder that contains the source code of the package.\ntest: the folder that contains the test code of the package, which contains the main test file runtests.jl.","category":"page"},{"location":"chap2/release/#Specify-the-dependency","page":"My First Package","title":"Specify the dependency","text":"","category":"section"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"The file that contains the metadata of the package, including the name, UUID, version, dependencies and compatibility of the package. To add a new dependency, you can use the following command in the package path:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"$ cd ~/.julia/dev/MyFirstPackage\n\n$ julia --project","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"This will open a Julia REPL in the package environment. To check the package environment, you can type the following commands in the package mode (press ]) of the REPL:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> st\nProject MyFirstPackage v1.0.0-DEV\nStatus `~/.julia/dev/MyFirstPackage/Project.toml` (empty project)","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"After that, you can add a new dependency by typing:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> add OMEinsum\n\n(MyFirstPackage) pkg> st\nProject MyFirstPackage v1.0.0-DEV\nStatus `~/.julia/dev/MyFirstPackage/Project.toml`\n  [ebe7aa44] OMEinsum v0.8.1","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Press backspace to exit the package mode and then type","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"julia> using OMEinsum","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"The dependency is added correctly if no error is thrown.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Type ; to enter the shell mode and then type","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"shell> cat Project.toml\nname = \"MyFirstPackage\"\nuuid = \"594718ca-da39-4ff3-a299-6d8961b2aa49\"\nauthors = [\"GiggleLiu\"]\nversion = \"1.0.0-DEV\"\n\n[deps]\nOMEinsum = \"ebe7aa44-baf0-506c-a96f-8464559b3922\"\n\n[compat]\njulia = \"1.10\"\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"You will see that the dependency OMEinsum is added to the [deps] section of the Project.toml file.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"We also need to specify which version of OMEinsum is compatible with the current package. To do so, you need to edit the [compat] section of the Project.toml file with your favorite editor.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"[compat]\njulia = \"1.10\"\nOMEinsum = \"0.8\"","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Here, we have used the most widely used dependency version specifier =, which means matching the first nonzero component of the version number. For example:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"1 matches 1.0.0, 1.1.0, 1.1.1, but not 2.0.0.\n0.8 matches 0.8.0, 0.8.1, 0.8.2, but not 0.9.0 or 0.7.0.\n1.2 matches 1.2.0, 1.3.1, but not 1.2.0 or 2.0.0.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"The validity of specifying compatibility is based on the consensus among the developers:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"whenever an exported function is changed in a package, the first nonzero component of the version number should be increased.\nversion number starts with 0 is considered as a development version, and it is not stable.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Please check the Julia documentation about package compatibility for advanced usage.","category":"page"},{"location":"chap2/release/#Develop-the-package","page":"My First Package","title":"Develop the package","text":"","category":"section"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Developers develop packages in the package environment. The package development process includes:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Edit the source code of the package","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"The source code of the package is located in the src folder of the package path.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Let us add a simple function to the package. The source code of the package is as follows:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"File: src/MyFirstPackage.jl","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"module MyFirstPackage\n# import the OMEinsum package (not really used in this example)\nusing OMEinsum\n\n# export `greet` as a public function\nexport greet\n\n\"\"\"\n    greet(name::String)\n\nReturn a greeting message to the input `name`.\n\"\"\"\nfunction greet(name::String)\n    # `$` is used to interpolate the variable `name` into the string\n    return \"Hello, $(name)!\"\nend\n\n# this function is not exported\nfunction private_sum(v::AbstractVector{<:Real})\n    # we implement the sum function by using the `@ein_str` macro\n    # from the OMEinsum package\n    return ein\"i->\"(v)\nend\n\nend","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"To use this function, you can type the following commands in the package environment:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"julia> using MyFirstPackage\n\njulia> MyFirstPackage.greet(\"Julia\")\n\"Hello, Julia!\"","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Write tests for the package","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"We always need to write tests for the package. The test code of the package is located in the test folder of the package path.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"File: test/runtests.jl","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"using Test\nusing MyFirstPackage\n\n@testset \"greet\" begin\n    @test greet(\"Julia\") == \"Hello, Julia!\"\nend\n\n@testset \"private sum\" begin\n    # because we have not exported the `private_sum` function,\n    # we need to use the full path to call it\n    @test MyFirstPackage.private_sum([1, 2, 3]) == 6\n    @test MyFirstPackage.private_sum(Int[]) == 0\nend","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"To run the tests, you can use the following command in the package environment:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"(MyFirstPackage) pkg> test\n  ... \n  [8e850b90] libblastrampoline_jll v5.8.0+1\nPrecompiling project...\n  1 dependency successfully precompiled in 1 seconds. 21 already precompiled.\n     Testing Running tests...\nTest Summary:  | Pass  Total  Time\nMyFirstPackage |    1      1  0.0s\nTest Summary: | Pass  Total  Time\nprivate sum   |    2      2  0.3s\n     Testing MyFirstPackage tests passed","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Cheers! All tests passed.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Write documentation for the package","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"The documentation is built with Documenter.jl. The build script is docs/make.jl. To build the documentation, you can use the following command in the package path:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"$ cd docs\n$ julia --project make.jl","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Instantiate the documentation environment if necessary. For seamless debugging of documentation, it is highly recommended using the LiveServer.jl package.","category":"page"},{"location":"chap2/release/#Open-source-the-package","page":"My First Package","title":"Open-source the package","text":"","category":"section"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"To open-source the package, you need to push the package to a public repository on GitHub.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"First create a GitHub repository with the same as the name of the package. In this example, the repository name should be GiggleLiu/MyFirstPackage.jl. To check the remote repository of the package, you can use the following command in the package path:\n$ git remote -v\norigin\tgit@github.com:GiggleLiu/MyFirstPackage.jl.git (fetch)\norigin\tgit@github.com:GiggleLiu/MyFirstPackage.jl.git (push)\nThen push the package to the remote repository:\n$ git add -A\n$ git commit -m \"Initial commit\"\n$ git push\nAfter that, you need to check if all your GitHub Actions are passing. You can check the status of the GitHub Actions from the badge in the README.md file of the package repository. The configuration of GitHub Actions is located in the .github/workflows folder of the package path. Its file structure is as follows:\n.github\n├── dependabot.yml\n└── workflows\n    ├── CI.yml\n    ├── CompatHelper.yml\n    └── TagBot.yml\nThe CI.yml file contains the configuration for the CI of the package, which is used to automate the process of\nTesting the package after a pull request is opened, or the main branch is updated. This process can be automated with the julia-runtest action.\nBuilding the documentation after the main branch is updated. Please check the Documenter documentation for more information.\nThe TagBot.yml file contains the configuration for the TagBot, which is used to automate the process of tagging a release after a pull request is merged.\nThe CompatHelper.yml file contains the configuration for the CompatHelper, which is used to automate the process of updating the [compat] section of the Project.toml file after a pull request is merged.\nConfiguring GitHub Actions is a bit complicated. For beginners, it is a good practise to mimic the configuration of another package, e.g. OMEinsum.jl.","category":"page"},{"location":"chap2/release/#Register-the-package","page":"My First Package","title":"Register the package","text":"","category":"section"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Package registration is the process of adding the package to the General registry. To do so, you need to create a pull request to the General registry and wait for the pull request to be reviewed and merged. This process can be automated by the Julia registrator. If the pull request meets all guidelines, your pull request will be merged after a few days. Then, your package is available to the public. ","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"A good practice is to tag a release after the pull request is merged so that your package version update can be reflected in your GitHub repository. This process can be automated by the TagBot.","category":"page"},{"location":"chap2/release/#Case-study:-The-file-structure-of-[OMEinsum.jl](https://github.com/under-Peter/OMEinsum.jl)","page":"My First Package","title":"Case study: The file structure of OMEinsum.jl","text":"","category":"section"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"(Image: )","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"OMEinsum.jl is a package for tensor contraction. The badges in the README.md file of the package repository are the following:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"build/passing: the tests executed by GitHub Actions are passing.\ncodecov/89%: the code coverage is 89%, meaning that 89% of the code is covered by tests.\ndocs/dev: the documentation is built and deployed with GitHub pages.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Now, let's take a look at the file structure of the package by running the following command in the package path (~/.julia/dev/OMEinsum):","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"$ tree . -L 1 -a\n.\n├── .git\n├── .github\n├── .gitignore\n├── LICENSE\n├── Project.toml\n├── README.md\n├── benchmark\n├── docs\n├── examples\n├── ext\n├── ome-logo.png\n├── src\n└── test","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"File: Project.toml","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"name = \"OMEinsum\"\nuuid = \"ebe7aa44-baf0-506c-a96f-8464559b3922\"\nauthors = [\"Andreas Peter <andreas.peter.ch@gmail.com>\"]\nversion = \"0.8.1\"\n\n[deps]\nAbstractTrees = \"1520ce14-60c1-5f80-bbc7-55ef81b5835c\"\nBatchedRoutines = \"a9ab73d0-e05c-5df1-8fde-d6a4645b8d8e\"\nChainRulesCore = \"d360d2e6-b24c-11e9-a2a3-2a2ae2dbcce4\"\nCombinatorics = \"861a8166-3701-5b0c-9a16-15d98fcdc6aa\"\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\nMacroTools = \"1914dd2f-81c6-5fcd-8719-6d5c9610ff09\"\nOMEinsumContractionOrders = \"6f22d1fd-8eed-4bb7-9776-e7d684900715\"\nTupleTools = \"9d95972d-f1c8-5527-a6e0-b4b365fa01f6\"\n\n[weakdeps]\nCUDA = \"052768ef-5323-5732-b1bb-66c8b64840ba\"\n\n[extensions]\nCUDAExt = \"CUDA\"\n\n[compat]\nAbstractTrees = \"0.3, 0.4\"\nBatchedRoutines = \"0.2\"\nCUDA = \"4, 5\"\nChainRulesCore = \"1\"\nCombinatorics = \"1.0\"\nMacroTools = \"0.5\"\nOMEinsumContractionOrders = \"0.8\"\nTupleTools = \"1.2, 1.3\"\njulia = \"1\"\n\n[extras]\nDocumenter = \"e30172f5-a6a5-5a46-863b-614d45cd2de4\"\nDoubleFloats = \"497a8b3b-efae-58df-a0af-a86822472b78\"\nForwardDiff = \"f6369f11-7733-5829-9624-2563aa707210\"\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\nPolynomials = \"f27b6e38-b328-58d1-80ce-0feddd5e7a45\"\nProgressMeter = \"92933f4c-e287-5a05-a399-4b506db050ca\"\nRandom = \"9a3f8284-a2c9-5f02-9a11-845980a1fd5c\"\nSymEngine = \"123dc426-2d89-5057-bbad-38513e3affd8\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\nTropicalNumbers = \"b3a74e9c-7526-4576-a4eb-79c0d4c32334\"\nZygote = \"e88e6eb3-aa80-5325-afca-941959d7151f\"\n\n[targets]\ntest = [\"Test\", \"Documenter\", \"LinearAlgebra\", \"ProgressMeter\", \"SymEngine\", \"Random\", \"Zygote\", \"DoubleFloats\", \"TropicalNumbers\", \"ForwardDiff\", \"Polynomials\", \"CUDA\"]","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"It contains the following more sections:","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"[weakdeps] and [extensions]: the sections that specify the extensions of the package, which is related with the files in the ext folder. A package \"extension\" is a module that is automatically loaded when a specified set of other packages (its \"extension dependencies\") are loaded in the current Julia session. As a using case, consider you want to add the CUDA support to your package, but you don't want to force all users to install CUDA package if they don't need it, then adding CUDA as a weak dependency and move this feature ext folder is a good choice. Please check the Julia documentation about package extensions for more information.\n[extras] and [targets]: the section that specifies the extra dependencies of the package that used to test the package. One can also specify the extra dependencies for the test environment in the test folder of the package path.","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Quiz: ","category":"page"},{"location":"chap2/release/","page":"My First Package","title":"My First Package","text":"Is ChainRulesCore at version 1.2 compatible with OMEinsum?\nIf ChainRulesCore at version 2.0 is released, what should be done to make OMEinsum compatible with the new version of ChainRulesCore? Which GitHub Action is used to automate this process?\nIf an author of OMEinsum fixed a bug, what should be done to make the new version of OMEinsum available to the public?\nIf an author of OMEinsum changed an exported function, what should be done to make the new version of OMEinsum available to the public?","category":"page"},{"location":"chap2/julia-type/#Types-and-Multiple-dispatch","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"","category":"section"},{"location":"chap2/julia-type/#Julia-Types","page":"Types and Multiple-dispatch","title":"Julia Types","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Julia has rich type system, which is not limited to the primitive types that supported by the hardware. The type system is the key to the multiple dispatch feature of Julia.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"As an example, let us consider the type for complex numbers.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Complex{Float64}","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where Float64 is the type parameter of Complex. Type parameters are a part of a type, without which the type is not fully specified. A fully specified type is called a concrete type, which has a fixed memory layout and can be instantiated in memory. For example, the Complex{Float64} consists of two fields of type Float64, which are the real and imaginary parts of the complex number.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fieldnames(Complex{Float64})\nfieldtypes(Complex{Float64})","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Extending the example, we can define the type for a matrix of complex numbers.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Array{Complex{Float64}, 2}","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Array type has two type parameters, the first one is the element type and the second one is the dimension of the array.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"One can get the type of value with typeof function.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"typeof(1+2im)\ntypeof(randn(Complex{Float64}, 2, 2))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Then, what the type of a type?","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"typeof(Complex{Float64})","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There is a very special type: Tuple, which is different from regular types in the following ways:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Tuple types may have any number of parameters.\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore Tuple{Any} is considered an abstract type, and tuple types are only concrete if their parameters are.\nTuples do not have field names; fields are only accessed by index.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"tp = (1, 2.0, 'c')\ntypeof(tp)\ntp[2]","category":"page"},{"location":"chap2/julia-type/#Multiple-dispatch","page":"Types and Multiple-dispatch","title":"Multiple dispatch","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch is a feature of some programming languages in which a function or method can be dynamically dispatched based on the run-time type. The dispatch is the process of selecting the method to invoke based on the type of the arguments.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We first define of an abstract type AbstractAnimal with the keyword abstract type:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"abstract type AbstractAnimal{L} end","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where the type parameter L stands for the number of legs. Defining the number of legs as a type parameter or a field of a concrete type is a design choice. Providing more information in the type system can help the compiler to optimize the code, but it can also make the compiler generate more code.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Abstract types can have subtypes. In the following we define a concrete subtype type Dog with 4 legs, which is a subtype of AbstractAnimal{4}.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Dog <: AbstractAnimal{4}\n\tcolor::String\nend","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where <: is the symbol for sybtyping， A <: B means A is a subtype of B. Concrete types can have fields, which are the data members of the type. However, they can not have subtypes.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Similarly, we define a Cat with 4 legs, a Cock with 2 legs and a Human with 2 legs.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Cat <: AbstractAnimal{4}\n\tcolor::String\nend\n\nstruct Cock <: AbstractAnimal{2}\n\tgender::Bool\nend\n\nstruct Human{FT <: Real} <: AbstractAnimal{2}\n\theight::FT\n\tfunction Human(height::T) where T <: Real\n\t\tif height <= 0 || height > 300\n\t\t\terror(\"The tall of a Human being must be in range 0~300, got $(height)\")\n\t\tend\n\t\treturn new{T}(height)\n\tend\nend","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Here, the Human type has its own constructor. The new function is the default constructor.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define a fall back method fight on the abstract type AbstractAnimal","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(a::AbstractAnimal, b::AbstractAnimal) = \"draw\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where :: is a type assertion. This function will be invoked if two subtypes of AbstractAnimal are fed into the function fight and no more explicit methods are defined.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define many more explicit methods with the same name.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(dog::Dog, cat::Cat) = \"win\"\nfight(hum::Human, a::AbstractAnimal) = \"win\"\nfight(hum::Human, a::Union{Dog, Cat}) = \"loss\"\nfight(hum::AbstractAnimal, a::Human) = \"loss\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"where Union{Dog, Cat} is a union type. It is a type that can be either Dog or Cat. Union types are not concrete since they do not have a fixed memory layout, meanwhile, they can not be subtyped! Here, we defined 5 methods for the function fight. However, defining too many methods for the same function can be dangerous. You need to be careful about the ambiguity error!","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(Human(170), Human(180))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"It makes sense because we claim Human wins any other animals, but we also claim any animal losses to Human. When it comes to two Humans, the two functions are equally valid. To resolve the ambiguity, we can define a new method for the function fight as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(hum::Human{T}, hum2::Human{T}) where T<:Real = hum.height > hum2.height ? \"win\" : \"loss\"","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Now, we can test the function fight with different combinations of animals.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fight(Cock(true), Cat(\"red\"))\nfight(Dog(\"blue\"), Cat(\"white\"))\nfight(Human(180), Cat(\"white\"))\nfight(Human(170), Human(180))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Quiz: How many method instances are generated for fight so far?","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> methodinstances(fight)","category":"page"},{"location":"chap2/julia-type/#Example:-Julia-number-system","page":"Types and Multiple-dispatch","title":"Example: Julia number system","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The Julia type system is a tree, and Any is the root of type tree, i.e. it is a super type of any other type. The Number type is the root type of Julia number system, which is also a subtype of Any.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Number <: Any","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The type tree rooted on Number looks like:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Number\n├─ Base.MultiplicativeInverses.MultiplicativeInverse{T}\n│  ├─ Base.MultiplicativeInverses.SignedMultiplicativeInverse{T<:Signed}\n│  └─ Base.MultiplicativeInverses.UnsignedMultiplicativeInverse{T<:Unsigned}\n├─ Complex{T<:Real}\n├─ Real\n│  ├─ AbstractFloat\n│  │  ├─ BigFloat\n│  │  ├─ Float16\n│  │  ├─ Float32\n│  │  └─ Float64\n│  ├─ AbstractIrrational\n...","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There are utilities to analyze the type tree:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"using InteractiveUtils # hide\nsubtypes(Number)\nsupertype(Float64)\nAbstractFloat <: Real","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The leaf nodes of the type tree are called concrete types. They are the types that can be instantiated in memory. Among the concrete types, there are primitive types and composite types. Primitive types are built into the language, such as Int64, Float64, Bool, and Char, while composite types are built on top of primitive types, such as Dict, Complex and the user-defined types.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The list of primitive types","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end","category":"page"},{"location":"chap2/julia-type/#Extending-the-number-system-a-comparison-with-object-oriented-programming","page":"Types and Multiple-dispatch","title":"Extending the number system - a comparison with object-oriented programming","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Extending the number system in Julia is much easier than in object-oriented languages like Python. In the following example, we show how to implement addition operation of a user defined class in Python (feel free to skip if you do not know Python).","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class X:\n  def __init__(self, num):\n    self.num = num\n\n  def __add__(self, other_obj):\n    return X(self.num+other_obj.num)\n\n  def __radd__(self, other_obj):\n    return X(other_obj.num + self.num)\n\n  def __str__(self):\n    return \"X = \" + str(self.num)\n\nclass Y:\n  def __init__(self, num):\n    self.num = num\n\n  def __radd__(self, other_obj):\n    return Y(self.num+other_obj.num)\n\n  def __str__(self):\n    return \"Y = \" + str(self.num)\n\nprint(X(3) + Y(5))\n\nprint(Y(3) + X(5))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Here, we implemented the addition operation of two classes X and Y. The __add__ method is called when the + operator is used with the object on the left-hand side, while the __radd__ method is called when the object is on the right-hand side. The output is as follows:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"X = 8\nX = 8","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"It turns out the __radd__ method of Y is not called at all. This is because the __radd__ method is only called when the object on the left-hand side does not have the __add__ method by some artifical rules.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Implement addition in Julian style is much easier. We can define the addition operation of two types X and Y as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct X{T} <: Number\n\tnum::T\nend\n\nstruct Y{T} <: Number\n\tnum::T\nend\n\nBase.:(+)(a::X, b::Y) = X(a.num + b.num);\n\nBase.:(+)(a::Y, b::X) = X(a.num + b.num);\n\nBase.:(+)(a::X, b::X) = X(a.num + b.num);\n\nBase.:(+)(a::Y, b::Y) = Y(a.num + b.num);","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch seems to be more expressive than object-oriented programming.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Now, supposed you want to extend this method to a new type Z. In python, he needs to define a new class Z as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class Z:\n  def __init__(self, num):\n    self.num = num\n\n  def __add__(self, other_obj):\n    return Z(self.num+other_obj.num)\n\n  def __radd__(self, other_obj):\n    return Z(other_obj.num + self.num)\n\n  def __str__(self):\n    return \"Z = \" + str(self.num)\n\nprint(X(3) + Z(5))\n\nprint(Z(3) + X(5))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The output is as follows:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"X = 8\nZ = 8","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"No matter how hard you try, you can not make the __add__ method of Z to be called when the object is on the left-hand side. In Julia, this is not a problem at all. We can define the addition operation of Z as follows.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"struct Z{T} <: Number\n    num::T\nend\nBase.:(+)(a::X, b::Z) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::X) = Z(a.num + b.num);\nBase.:(+)(a::Y, b::Z) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::Y) = Z(a.num + b.num);\nBase.:(+)(a::Z, b::Z) = Z(a.num + b.num);\nX(3) + Y(5)\nY(3) + X(5)\nX(3) + Z(5)\nZ(3) + Y(5)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"There is a deeper reason why multiple dispatch is more expressive than object-oriented programming. The Julia function space is exponentially large! If a function f has k parameters, and the module has t types, there can be t^k methods for the function f:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"f(x::T1, y::T2, z::T3...)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Exponential function space allows us to specify the behavior of a function in a very fine-grained way. However, in an object-oriented language like Python, the function space is only linear to the number of classes.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"class T1:\n    def f(self, y, z, ...):\n        self.num = num\n","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The behavior of method f is completely determined by the first argument self, which means object-oriented programming is equivalent to single dispatch.","category":"page"},{"location":"chap2/julia-type/#Example:-Computing-Fibonacci-number-at-compile-time","page":"Types and Multiple-dispatch","title":"Example: Computing Fibonacci number at compile time","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"The Fibonacci number has a recursive definition:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"using BenchmarkTools\nfib(x::Int) = x <= 2 ? 1 : fib(x-1) + fib(x-2)\naddup(x::Int, y::Int) = x + y","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> @btime fib(40)\n  278.066 ms (0 allocations: 0 bytes)\n102334155","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Oops, it is really slow. There is definitely a better way to calculate the Fibonacci number, but let us stick to this recursive implementation for now.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"If you know the Julia type system, you can implement the Fibonacci number in a zero cost way. The trick is to use the type system to calculate the Fibonacci number at compile time. There is a type Val defined in the Base module, which is just a type with a type parameter. The type parameter can be a number:","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Val(3.0)","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"We can define the addition operation of Val as the addition of the type parameters.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"addup(::Val{x}, ::Val{y}) where {x, y} = Val(x + y)\naddup(Val(5), Val(7))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Finally, we can define the Fibonacci number in a zero cost way.","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"fib(::Val{x}) where x = x <= 2 ? Val(1) : addup(fib(Val(x-1)), fib(Val(x-2)))","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"julia> @btime fib(Val(40))\n  0.792 ns (0 allocations: 0 bytes)\nVal{102334155}()","category":"page"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Wow, it computes in no time! However, this trick is not recommended in the Julia performance tips. This implementation simply transfers the run-time computation to the compile time. On the other hand, we find the compiling time of the function fib is much shorter than the run-time. The recursive form turns out to be optimized away by the Julia compiler. But still, it is not recommended to abuse the type system.","category":"page"},{"location":"chap2/julia-type/#Summary","page":"Types and Multiple-dispatch","title":"Summary","text":"","category":"section"},{"location":"chap2/julia-type/","page":"Types and Multiple-dispatch","title":"Types and Multiple-dispatch","text":"Multiple dispatch is a feature of some programming languages in which a function or method can be dynamically dispatched based on the run-time type.\nJulia's multiple dispatch provides exponential large function space, which allows extending the number system easily.","category":"page"},{"location":"chap2/julia-why/#Why-Julia?","page":"Why Julia?","title":"Why Julia?","text":"","category":"section"},{"location":"chap2/julia-why/#What-is-Julia-programming-language?","page":"Why Julia?","title":"What is Julia programming language?","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Julia is a modern, open-source, high performance programming language for technical computing. It was born in 2012 in MIT, now is maintained by JuliaHub Inc. located in Boston, US.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike MatLab, Julia is open-source. Julia source code is maintained on GitHub repo JuliaLang/julia, and it open-source LICENSE is MIT. Julia packages can be found on JuliaHub, most of them are open-source.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike Python, Julia is designed for high performance (arXiv:1209.5145). It is a dynamic programming language, but it is as fast as C/C++. The following figure shows the computing time of multiple programming languages normalized to C/C++.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"/assets/images/benchmark.png\" alt=\"image\" width=\"600\" height=\"auto\">","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Unlike C/C++ and Fortran, Julia is easy to use and is becoming a trend in scientific computing. Julia uses the just-int-time (JIT) technique to achieve high performance, which does not have the problem of platform dependency. Many famous scientists and engineers have switched to Julia from other programming languages.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Steven G. Johnson, creater of FFTW, switched from C++ to Julia years ago.\nAnders Sandvik, creater of Stochastic Series Expansion (SSE) quantum Monte Carlo method, switched from Fortran to Julia recently.\nCourse link: Computational Physics\nMiles Stoudenmire, creater of ITensor, switched from C++ to Julia years ago.\nJutho Haegeman, Chris Rackauckas and more.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"note: Should I switch to Julia?\nBefore switching to Julia, please make sure:the problem you are trying to solve runs more than 10min.\nyou are not satisfied by any existing tools.","category":"page"},{"location":"chap2/julia-why/#My-first-program:-Factorial","page":"Why Julia?","title":"My first program: Factorial","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Before we start, please make sure you have the needed packages installed. Type ] in the Julia REPL to enter the package manager, and then type","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"pkg> add BenchmarkTools, MethodAnalysis","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Go back to the REPL by pressing Backspace.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> function jlfactorial(n)\n           x = 1\n           for i in 1:n\n               x = x * i\n           end\n           return x\n       end\njlfactorial (generic function with 1 method)","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To make sure the performance is measured correctly, we use the @btime macro in the BenchmarkTools package to measure the performance of the function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @btime jlfactorial(x) setup=(x=5)\n2.208 ns (0 allocations: 0 bytes)\n120","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"CPU clock cycle is ~0.3ns, so it takes only a few clock cycles to compute the factorial of 5. Julia is really fast!","category":"page"},{"location":"chap2/julia-why/#Compare-with-the-speed-of-C-program","page":"Why Julia?","title":"Compare with the speed of C program","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To measure the performance of the C program, we can utilize the benchmark utilities in Julia. Benchmarking C program with Julia is accurate because Julia has perfect interoperability with C, which allows zero-cost calling of C functions.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In the following example, we first write a C program to calculate the factorial of a number. The file is named demo.c, and the content is as follows:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"$ cat demo.c\n#include <stddef.h>\nint c_factorial(size_t n) {\n\tint s = 1;\n\tfor (size_t i=1; i<=n; i++) {\n\t\ts *= i;\n\t}\n\treturn s;\n}","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To execute a C program in Julia, one needs to compile it to a shared library.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"$ gcc demo.c -fPIC -O3 -shared -o demo.so","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"To call the function in Julia, one can use the @ccall macro in the Libdl package (learn more). Please open a Julia REPL and execute the following code:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using Libdl\n\njulia> c_factorial(x) = Libdl.@ccall \"./demo.so\".c_factorial(x::Csize_t)::Int","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The benchmark result is as follows:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using BenchmarkTools\n\njulia> @benchmark c_factorial(5)\nBenchmarkTools.Trial: 10000 samples with 1000 evaluations.\n Range (min … max):  7.333 ns … 47.375 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     7.458 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   7.764 ns ±  1.620 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ██▅  ▃▁ ▂▂                         ▁▁▁                     ▂\n  ███▆▄██▆███▅▅▆▆▆▅▆▅▄▅▆▅▅▇▆▆▄▅▅▇█▇▆▆█████▅▃▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▃ █\n  7.33 ns      Histogram: log(frequency) by time     12.6 ns <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Although the C program requires the type of variables to be manually declared, its performance is very good. The computing time is only 7.33 ns.","category":"page"},{"location":"chap2/julia-why/#Compare-with-the-speed-of-Python-program","page":"Why Julia?","title":"Compare with the speed of Python program","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"We use the timeit module in ipython to measure the performance of the Python program.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In [5]: def factorial(n):\n...:        x = 1\n...:        for i in range(1, n+1):\n...:            x = x * i\n...:        return x\n...:\n\nIn [6]: factorial(5)\nOut[6]: 120\n\nIn [7]: timeit factorial(5)\n144 ns ± 0.379 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\n\nIn [8]: factorial(100)\nOut[8]: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"One can also use the PyCall package to call the Python function in Julia.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The computing time of the Python program is 144 ns, which is 20 times slower than the C program and 70 times slower than the Julia program. On the other hand, the python program is more flexible since its integer type is not limited by the machine word size.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> typemax(Int)\n9223372036854775807\n\njulia> jlfactorial(100)\n0","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The reason why python is slow and flexible are the same. In python the type of a variable is not declared when it is defined, and it can be changed at any time. This is why the integer type becomes an arbitrary precision integer type when the number is too large. If a variable does not have a fixed type, the program can not preallocate memory for it due to the lack of size information. Then a dynamic typed language has to use a tuple (type, *data) to represent an object, where type is the type of the object and *data is the pointer to the data. Pointing to a random memory location is slow, because it violates the principle of data locality. Lacking of data locality causes the frequent cache miss - failure to find the data in the L1, L2, or L3 cache. Loading data from the main memory is slow, because of the long latency of reading the main memory.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"/assets/images/data.png\" alt=\"image\" width=\"300\" height=\"auto\">","category":"page"},{"location":"chap2/julia-why/#Combining-Python-and-C/C?","page":"Why Julia?","title":"Combining Python and C/C++?","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"From the maintainer's perspective, it is hard to maintain a program written in both Python and C/C++:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"It makes the build configuration files complicated.\nLearning two programming languages is hard for new contributors.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Using python as glue is not as powerful as it looks, the following problem can not be solved by this approach:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Monte Carlo simulation.\nBranching and bound algorithms.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"<img src=\"/assets/images/pythonc.png\" alt=\"image\" width=\"400\" height=\"auto\"/>","category":"page"},{"location":"chap2/julia-why/#Key-ingredients-of-Julia's-performance:-Just-in-time-(JIT)-compilation","page":"Why Julia?","title":"Key ingredients of Julia's performance: Just in time (JIT) compilation","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"JIT compilation: compile the method to a method instance when a method is called for the first time;\nMultiple dispatch: invoke the correct method instance according to the type of multiple arguments;","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"(Image: )","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Given a user defined Julia function, the Julia compiler will generate a binary for it at the first called. This binary is called a method instance, and it is generated based on the input types of the function. The method instance is then stored in the method table, and it will be called when the function is called with the same input types. The method instance is generated by the LLVM compiler, and it is optimized for the input types. The method instance is a binary, and it is as fast as a C/C++ program.","category":"page"},{"location":"chap2/julia-why/#Step-1:-Infer-the-types","page":"Why Julia?","title":"Step 1: Infer the types","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Knowing the types of the variables is key to generate a fast binary. Given the input types, the Julia compiler can infer the types of the variables in the function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"If all the types are inferred, the function is called type stable. One can use the @code_warntype macro to check if the function is type stable. For example, the jlfactorial function with integer input is type stable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_warntype jlfactorial(10)\nMethodInstance for jlfactorial(::Int64)\n  from jlfactorial(n) @ Main REPL[4]:1\nArguments\n  #self#::Core.Const(jlfactorial)\n  n::Int64\nLocals\n  @_3::Union{Nothing, Tuple{Int64, Int64}}\n  x::Int64\n  i::Int64\nBody::Int64\n1 ─       (x = 1)\n│   %2  = (1:n)::Core.PartialStruct(UnitRange{Int64}, Any[Core.Const(1), Int64])\n│         (@_3 = Base.iterate(%2))\n│   %4  = (@_3 === nothing)::Bool\n│   %5  = Base.not_int(%4)::Bool\n└──       goto #4 if not %5\n2 ┄ %7  = @_3::Tuple{Int64, Int64}\n│         (i = Core.getfield(%7, 1))\n│   %9  = Core.getfield(%7, 2)::Int64\n│         (x = x * i)\n│         (@_3 = Base.iterate(%2, %9))\n│   %12 = (@_3 === nothing)::Bool\n│   %13 = Base.not_int(%12)::Bool\n└──       goto #4 if not %13\n3 ─       goto #2\n4 ┄       return x","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"If the types are not inferred, the function is called type unstable. For example, the badcode function is type unstable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> badcode(x) = x > 3 ? 1.0 : 3\n\njulia> @code_warntype badcode(4)\nMethodInstance for badcode(::Int64)\n  from badcode(x) @ Main REPL[9]:1\nArguments\n  #self#::Core.Const(badcode)\n  x::Int64\nBody::Union{Float64, Int64}\n1 ─ %1 = (x > 3)::Bool\n└──      goto #3 if not %1\n2 ─      return 1.0\n3 ─      return 3","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In this example, the output type Union{Float64, Int64} means the return type is either Float64 or Int64. The function is type unstable because the return type is not fixed. Type unstable code is slow. In the following example, the badcode function is ~10 times slower than its type stable version stable:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> x = rand(1:10, 1000);\n\njulia> @benchmark badcode.($x)\nBenchmarkTools.Trial: 10000 samples with 8 evaluations.\n Range (min … max):  2.927 μs … 195.198 μs  ┊ GC (min … max):  0.00% … 96.52%\n Time  (median):     3.698 μs               ┊ GC (median):     0.00%\n Time  (mean ± σ):   4.257 μs ±   7.894 μs  ┊ GC (mean ± σ):  12.43% ±  6.54%\n\n                 ▁▅█▅▃▂                                        \n  ▁▃▅▇▇▇▅▃▂▂▂▃▄▆▇███████▇▇▅▄▄▃▃▃▃▃▃▂▂▃▂▂▂▂▁▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▃\n  2.93 μs         Histogram: frequency by time        5.44 μs <\n\n Memory estimate: 26.72 KiB, allocs estimate: 696.\n\njulia> stable(x) = x > 3 ? 1.0 : 3.0\nstable (generic function with 1 method)\n\njulia> @benchmark stable.($x)\nBenchmarkTools.Trial: 10000 samples with 334 evaluations.\n Range (min … max):  213.820 ns … 25.350 μs  ┊ GC (min … max):  0.00% … 98.02%\n Time  (median):     662.551 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   947.978 ns ±  1.187 μs  ┊ GC (mean ± σ):  29.30% ± 21.05%\n\n  ▂▃▅██▇▅▄▃▂▁                                                  ▂\n  ████████████▇▅▅▄▄▁▁▁▁▁▁▁▁▁▁▁▁▁▃▅▆▇██████▇▇▇▆█▇▇▇▇▇▇▇▇▆▇▆▆▆▇▇ █\n  214 ns        Histogram: log(frequency) by time      6.32 μs <\n\n Memory estimate: 7.94 KiB, allocs estimate: 1.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In the above example:","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"\".\" is the broadcasting operator, it applies the function to each element of the array.\n\"$\" is the interpolation operator, it is used to interpolate a variable into an expression. In a benchmark, it can be used to avoid the overhead of variable initialization.","category":"page"},{"location":"chap2/julia-why/#Step-2:-Generates-the-LLVM-intermediate-representation","page":"Why Julia?","title":"Step 2: Generates the LLVM intermediate representation","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"LLVM is a set of compiler and toolchain technologies that can be used to develop a front end for any programming language and a back end for any instruction set architecture. LLVM is the backend of multiple languages, including Julia, Rust, Swift and Kotlin.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"In Julia, one can use the @code_llvm macro to show the LLVM intermediate representation of a function.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_llvm jlfactorial(10)\n\nor any instruction set architecture. LLVM is the backend of multiple languages, including Julia, Rust, Swift and Kotlin.\n\n\n\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:1 within `jlfactorial`\ndefine i64 @julia_jlfactorial_3677(i64 signext %0) #0 {\ntop:\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:3 within `jlfactorial`\n; ┌ @ range.jl:5 within `Colon`\n; │┌ @ range.jl:403 within `UnitRange`\n; ││┌ @ range.jl:414 within `unitrange_last`\n     %1 = call i64 @llvm.smax.i64(i64 %0, i64 0)\n; └└└\n; ┌ @ range.jl:897 within `iterate`\n; │┌ @ range.jl:672 within `isempty`\n; ││┌ @ operators.jl:378 within `>`\n; │││┌ @ int.jl:83 within `<`\n      %2 = icmp slt i64 %0, 1\n; └└└└\n  br i1 %2, label %L32, label %L17.preheader\n\nL17.preheader:                                    ; preds = %top\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n  %min.iters.check = icmp ult i64 %1, 2\n  br i1 %min.iters.check, label %scalar.ph, label %vector.ph\n\nvector.ph:                                        ; preds = %L17.preheader\n  %n.vec = and i64 %1, 9223372036854775806\n  %ind.end = or i64 %1, 1\n  br label %vector.body\n\nvector.body:                                      ; preds = %vector.body, %vector.ph\n  %index = phi i64 [ 0, %vector.ph ], [ %induction12, %vector.body ]\n  %vec.phi = phi i64 [ 1, %vector.ph ], [ %3, %vector.body ]\n  %vec.phi11 = phi i64 [ 1, %vector.ph ], [ %4, %vector.body ]\n  %offset.idx = or i64 %index, 1\n  %induction12 = add i64 %index, 2\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; ┌ @ int.jl:88 within `*`\n   %3 = mul i64 %vec.phi, %offset.idx\n   %4 = mul i64 %vec.phi11, %induction12\n   %5 = icmp eq i64 %induction12, %n.vec\n   br i1 %5, label %middle.block, label %vector.body\n\nmiddle.block:                                     ; preds = %vector.body\n; └\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n  %bin.rdx = mul i64 %4, %3\n  %cmp.n = icmp eq i64 %1, %n.vec\n  br i1 %cmp.n, label %L32, label %scalar.ph\n\nscalar.ph:                                        ; preds = %middle.block, %L17.preheader\n  %bc.resume.val = phi i64 [ %ind.end, %middle.block ], [ 1, %L17.preheader ]\n  %bc.merge.rdx = phi i64 [ %bin.rdx, %middle.block ], [ 1, %L17.preheader ]\n  br label %L17\n\nL17:                                              ; preds = %L17, %scalar.ph\n  %value_phi4 = phi i64 [ %7, %L17 ], [ %bc.resume.val, %scalar.ph ]\n  %value_phi6 = phi i64 [ %6, %L17 ], [ %bc.merge.rdx, %scalar.ph ]\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; ┌ @ int.jl:88 within `*`\n   %6 = mul i64 %value_phi6, %value_phi4\n; └\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n; ┌ @ range.jl:901 within `iterate`\n; │┌ @ promotion.jl:521 within `==`\n    %.not = icmp eq i64 %value_phi4, %1\n; │└\n   %7 = add nuw i64 %value_phi4, 1\n; └\n  br i1 %.not, label %L32, label %L17\n\nL32:                                              ; preds = %L17, %middle.block, %top\n  %value_phi10 = phi i64 [ 1, %top ], [ %bin.rdx, %middle.block ], [ %6, %L17 ]\n;  @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n  ret i64 %value_phi10\n}","category":"page"},{"location":"chap2/julia-why/#Step-3:-Compiles-to-binary-code","page":"Why Julia?","title":"Step 3: Compiles to binary code","text":"","category":"section"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"The LLVM intermediate representation is then compiled to binary code by the LLVM compiler. The binary code can be printed by the @code_native macro.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> @code_native jlfactorial(10)\n\t.section\t__TEXT,__text,regular,pure_instructions\n\t.build_version macos, 14, 0\n\t.globl\t_julia_jlfactorial_3726         ; -- Begin function julia_jlfactorial_3726\n\t.p2align\t2\n_julia_jlfactorial_3726:                ; @julia_jlfactorial_3726\n; ┌ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:1 within `jlfactorial`\n; %bb.0:                                ; %top\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:3 within `jlfactorial`\n; │┌ @ range.jl:5 within `Colon`\n; ││┌ @ range.jl:403 within `UnitRange`\n; │││┌ @ range.jl:414 within `unitrange_last`\n\tcmp\tx0, #0\n\tcsel\tx9, x0, xzr, gt\n; │└└└\n\tcmp\tx0, #1\n\tb.lt\tLBB0_3\n; %bb.1:                                ; %L17.preheader\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tcmp\tx9, #2\n\tb.hs\tLBB0_4\n; %bb.2:\n\tmov\tw8, #1\n\tmov\tw0, #1\n\tb\tLBB0_7\nLBB0_3:\n\tmov\tw0, #1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n\tret\nLBB0_4:                                 ; %vector.ph\n\tmov\tx12, #0\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tand\tx10, x9, #0x7ffffffffffffffe\n\torr\tx8, x9, #0x1\n\tmov\tw11, #1\n\tmov\tw13, #1\nLBB0_5:                                 ; %vector.body\n                                        ; =>This Inner Loop Header: Depth=1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmadd\tx11, x11, x12, x11\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tadd\tx14, x12, #2\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmul\tx13, x13, x14\n\tmov\tx12, x14\n\tcmp\tx10, x14\n\tb.ne\tLBB0_5\n; %bb.6:                                ; %middle.block\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n\tmul\tx0, x13, x11\n\tcmp\tx9, x10\n\tb.eq\tLBB0_9\nLBB0_7:                                 ; %L17.preheader15\n\tadd\tx9, x9, #1\nLBB0_8:                                 ; %L17\n                                        ; =>This Inner Loop Header: Depth=1\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:4 within `jlfactorial`\n; │┌ @ int.jl:88 within `*`\n\tmul\tx0, x0, x8\n; │└\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:5 within `jlfactorial`\n; │┌ @ range.jl:901 within `iterate`\n\tadd\tx8, x8, #1\n; │└\n\tcmp\tx9, x8\n\tb.ne\tLBB0_8\nLBB0_9:                                 ; %L32\n; │ @ /Users/liujinguo/jcode/ModernScientificComputing2024/Lecture2/3.julia.jl#==#d2429055-58e9-4d84-894f-2e639723e078:6 within `jlfactorial`\n\tret\n; └\n                                        ; -- End function\n.subsections_via_symbols","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Single function definition may have multiple method instances.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> methods(jlfactorial)\n# 1 method for generic function \"jlfactorial\" from Main:\n [1] jlfactorial(n)\n     @ REPL[4]:1","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"Whenever the function is called with a new input type, the Julia compiler will generate a new method instance for the function. The method instance is then stored in the method table, and can be analyzed by the MethodAnalysis package.","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"julia> using MethodAnalysis\n\njulia> methodinstances(jlfactorial)\n1-element Vector{Core.MethodInstance}:\n MethodInstance for jlfactorial(::Int64)\n\njulia> jlfactorial(UInt32(5))\n120\n\njulia> methodinstances(jlfactorial)\n2-element Vector{Core.MethodInstance}:\n MethodInstance for jlfactorial(::Int64)\n MethodInstance for jlfactorial(::UInt32)","category":"page"},{"location":"chap2/julia-why/","page":"Why Julia?","title":"Why Julia?","text":"When a function is called with multiple arguments, the Julia compiler will invoke the correct method instance according to the type of the arguments. This is called multiple dispatch.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ScientificComputingForPhysicists","category":"page"},{"location":"#ScientificComputingForPhysicists","page":"Home","title":"ScientificComputingForPhysicists","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Who-should-read-this-book?","page":"Home","title":"Who should read this book?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I am a book for those who aim to become professional scientific computing programmers. Before reading me, please make sure","category":"page"},{"location":"","page":"Home","title":"Home","text":"the problem you are trying to solve runs more than 10min,\nyou want to become a tool builder rather than tools user, and you are happy with writing the tool with the Julia programming language.","category":"page"}]
}
