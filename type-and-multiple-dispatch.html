<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Yu-Sheng Zhao" />
  <meta name="author" content="Yi-Dai Zhang" />
  <meta name="author" content="Jin-Guo Liu" />
  <title>Type and Multiple-dispatch - Scientific Computing for Physicist</title>
  <link rel="shortcut icon" type="image/png" href="/favicon.png"/>
  <link rel="stylesheet" href="/style.css"/>
    <script src="/mousetrap.min.js"></script>
    <style>
  @font-face {
    font-family: JuliaMono-Regular;
    src: url("/JuliaMono-Regular.woff2");
  }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <link rel="stylesheet" href="/github.min.css">
<script src="/highlight.min.js"></script>
<script src="/julia.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
    document.querySelectorAll('pre').forEach((el) => {
        if (!el.classList.contains('output')) {
            hljs.highlightElement(el);
        }
    });
});
</script>
 
</head>
<body>
<script>
function click_next() {
  var next = document.getElementById('nav-next');
  next.firstElementChild.nextElementSibling.click();
}
function click_prev() {
  var prev = document.getElementById('nav-prev');
  prev.firstElementChild.click();
}
Mousetrap.bind('right', click_next);
Mousetrap.bind('h', click_prev);
Mousetrap.bind('left', click_prev);
Mousetrap.bind('l', click_next);
</script>

<div class="books-container">
<aside class="books-menu">
<input type="checkbox" id="menu">
<label for="menu">☰</label>
<div class="books-title">
<a href="/">Scientific Computing for Physicist</a>
</div><br />
<span class="books-subtitle">
with Julia programming language
</span>
<div class="books-menu-content">
<li><a class="menu-level-1" href="/open-source-dev-toolchains"><b>1</b> Becoming an Open-Source De..</a></li>
<li><a class="menu-level-2" href="/terminal"><b>1.1</b> Get a Terminal!</a></li>
<li><a class="menu-level-2" href="/version-control"><b>1.2</b> Maintainability - Versio..</a></li>
<li><a class="menu-level-2" href="/ci-cd"><b>1.3</b> Correctness - Unit Tests</a></li>
<li><a class="menu-level-1" href="/julia"><b>2</b> Julia</a></li>
<li><a class="menu-level-2" href="/setup"><b>2.1</b> Setup Julia</a></li>
<li><a class="menu-level-2" href="/whyjulia"><b>2.2</b> Why Julia is fast?</a></li>
<li><a class="menu-level-2" href="/type-and-multiple-dispatch"><b>2.3</b> Type and Multiple-dispat..</a></li>
<li><a class="menu-level-2" href="/tuple-array-and-broadcasting"><b>2.4</b> Tuple, Array and broadca..</a></li>
<li><a class="menu-level-2" href="/publishing-package"><b>2.5</b> Publishing a Package</a></li>
<li><a class="menu-level-1" href="/appendix"><b></b> Appendix</a></li>
<li><a class="menu-level-1" href="/references"><b>3</b> References</a></li>
</div>
</aside>

<div class="books-content">
<h2 data-number="2.3" id="type-and-multiple-dispatch"><span class="header-section-number">2.3</span> Type and Multiple-dispatch</h2>
<h3 data-number="2.3.1" id="julia-types"><span class="header-section-number">2.3.1</span> Julia Types</h3>
<p>Julia has rich type system, which is not limited to the <strong>primitive types</strong> that supported by the hardware. The type system is the key to the <strong>multiple dispatch</strong> feature of Julia.</p>
<p>As an example, let us consider the type for complex numbers.</p>
<pre class="julia"><code>Complex{Float64}</code></pre>
<p>where <code>Float64</code> is the <strong>type parameter</strong> of <code>Complex</code>. Type parameters are a part of a type, without which the type is not fully specified. A fully specified type is called a <strong>concrete type</strong>, which has a fixed memory layout and can be instantiated in memory. For example, the <code>Complex{Float64}</code> consists of two fields of type <code>Float64</code>, which are the real and imaginary parts of the complex number.</p>
<pre class="julia"><code>julia&gt; fieldnames(Complex{Float64})
(:re, :im)

julia&gt; fieldtypes(Complex{Float64})
(Float64, Float64)</code></pre>
<p>Extending the example, we can define the type for a matrix of complex numbers.</p>
<pre class="julia"><code>Array{Complex{Float64}, 2}</code></pre>
<p><code>Array</code> type has two type parameters, the first one is the <strong>element type</strong> and the second one is the <strong>dimension</strong> of the array.</p>
<p>One can get the type of value with <code>typeof</code> function.</p>
<pre class="julia"><code>julia&gt; typeof(1+2im)

julia&gt; typeof(randn(Complex{Float64}, 2, 2))</code></pre>
<p>Then, what the type of a type?</p>
<pre class="julia"><code>julia&gt; typeof(Complex{Float64})
DataType</code></pre>
<h3 data-number="2.3.2" id="example-define-you-first-type"><span class="header-section-number">2.3.2</span> Example: define you first type</h3>
<p>We first define of an abstract type <code>AbstractAnimal</code> with the keyword <code>abstract type</code>:</p>
<pre class="julia"><code>julia&gt; abstract type AbstractAnimal{L} end</code></pre>
<p>where the type parameter <code>L</code> stands for the number of legs. Defining the number of legs as a type parameter or a field of a concrete type is a design choice. Providing more information in the type system can help the compiler to optimize the code, but it can also make the compiler generate more code.</p>
<p>Abstract types can have subtypes. In the following we define a concrete subtype type <code>Dog</code> with 4 legs, which is a subtype of <code>AbstractAnimal{4}</code>.</p>
<pre class="julia"><code>julia&gt; struct Dog &lt;: AbstractAnimal{4}
    color::String
end</code></pre>
<p>where <code>&lt;:</code> is the symbol for sybtyping， <code>A &lt;: B</code> means A is a subtype of B. Concrete types can have fields, which are the data members of the type. However, they can not have subtypes.</p>
<p>Similarly, we define a <code>Cat</code> with 4 legs, a <code>Cock</code> with 2 legs and a <code>Human</code> with 2 legs.</p>
<pre class="julia"><code>julia&gt; struct Cat &lt;: AbstractAnimal{4}
    color::String
end

julia&gt; struct Cock &lt;: AbstractAnimal{2}
    gender::Bool
end

julia&gt; struct Human{FT &lt;: Real} &lt;: AbstractAnimal{2}
    height::FT
    function Human(height::T) where T &lt;: Real
        if height &lt;= 0 || height &gt; 300
            error(&quot;The tall of a Human being must be in range 0~300, got $(height)&quot;)
        end
        return new{T}(height)
    end
end</code></pre>
<p>Here, the <code>Human</code> type has its own constructor. The <code>new</code> function is the default constructor.</p>
<p>We can define a <strong>fall back method</strong> <code>fight</code> on the abstract type <code>AbstractAnimal</code></p>
<pre class="julia"><code>julia&gt; fight(a::AbstractAnimal, b::AbstractAnimal) = &quot;draw&quot;</code></pre>
<p>where <code>::</code> is a type assertion. This function will be invoked if two subtypes of <code>AbstractAnimal</code> are fed into the function <code>fight</code> and no more <strong>explicit</strong> methods are defined.</p>
<p>We can define many more explicit methods with the same name.</p>
<pre class="julia"><code>julia&gt; fight(dog::Dog, cat::Cat) = &quot;win&quot;
fight (generic function with 2 methods)

julia&gt; fight(hum::Human, a::AbstractAnimal) = &quot;win&quot;
fight (generic function with 3 methods)

julia&gt; fight(hum::Human, a::Union{Dog, Cat}) = &quot;loss&quot;
fight (generic function with 4 methods)

julia&gt; fight(hum::AbstractAnimal, a::Human) = &quot;loss&quot;
fight (generic function with 5 methods)</code></pre>
<p>where <code>Union{Dog, Cat}</code> is a <strong>union type</strong>. It is a type that can be either <code>Dog</code> or <code>Cat</code>. <code>Union</code> types are not concrete since they do not have a fixed memory layout, meanwhile, they can not be subtyped! Here, we defined 5 methods for the function <code>fight</code>. However, defining too many methods for the same function can be dangerous. You need to be careful about the ambiguity error!</p>
<pre class="julia"><code>julia&gt; fight(Human(170), Human(180))
ERROR: MethodError: fight(::Human{Int64}, ::Human{Int64}) is ambiguous.

Candidates:
  fight(hum::AbstractAnimal, a::Human)
    @ Main REPL[37]:1
  fight(hum::Human, a::AbstractAnimal)
    @ Main REPL[35]:1

Possible fix, define
  fight(::Human, ::Human)

Stacktrace:
 [1] top-level scope
   @ REPL[38]:1</code></pre>
<p>It makes sense because we claim <code>Human</code> wins any other animals, but we also claim any animal losses to <code>Human</code>. When it comes to two <code>Human</code>s, the two functions are equally valid. To resolve the ambiguity, we can define a new method for the function <code>fight</code> as follows.</p>
<pre class="julia"><code>julia&gt; fight(hum::Human{T}, hum2::Human{T}) where T&lt;:Real = hum.height &gt; hum2.height ? &quot;win&quot; : &quot;loss&quot;</code></pre>
<p>Now, we can test the function <code>fight</code> with different combinations of animals.</p>
<pre class="julia"><code>julia&gt; fight(Cock(true), Cat(&quot;red&quot;))
&quot;draw&quot;

julia&gt; fight(Dog(&quot;blue&quot;), Cat(&quot;white&quot;))
&quot;win&quot;

julia&gt; fight(Human(180), Cat(&quot;white&quot;))
&quot;loss&quot;

julia&gt; fight(Human(170), Human(180))
&quot;loss&quot;</code></pre>
<p>Quiz: How many method instances are generated for fight so far?</p>
<pre class="julia"><code>julia&gt; methodinstances(fight)</code></pre>
<h3 data-number="2.3.3" id="julia-number-system"><span class="header-section-number">2.3.3</span> Julia number system</h3>
<p>The type tree rooted on <code>Number</code> looks like:</p>
<pre class="julia"><code>Number
├─ Base.MultiplicativeInverses.MultiplicativeInverse{T}
│  ├─ Base.MultiplicativeInverses.SignedMultiplicativeInverse{T&lt;:Signed}
│  └─ Base.MultiplicativeInverses.UnsignedMultiplicativeInverse{T&lt;:Unsigned}
├─ Complex{T&lt;:Real}
├─ Real
│  ├─ AbstractFloat
│  │  ├─ BigFloat
│  │  ├─ Float16
│  │  ├─ Float32
│  │  └─ Float64
│  ├─ AbstractIrrational
...</code></pre>
<p>The Julia type system is a tree, and <code>Any</code> is the root of type tree, i.e. it is a super type of any other type. The <code>Number</code> type is the root type of julia number system, which is also a subtype of <code>Any</code>.</p>
<pre class="julia"><code>julia&gt; Number &lt;: Any</code></pre>
<p>There are utilities to analyze the type system:</p>
<pre class="julia"><code>julia&gt; subtypes(Number)
3-element Vector{Any}:
 Base.MultiplicativeInverses.MultiplicativeInverse
 Complex
 Real

julia&gt; supertype(Float64)
AbstractFloat

julia&gt; AbstractFloat &lt;: Real
true</code></pre>
<p>The leaf nodes of the type tree are called <strong>concrete types</strong>. They are the types that can be instantiated in memory. Among the concrete types, there are <strong>primitive types</strong> and <strong>composite types</strong>. Primitive types are built into the language, such as <code>Int64</code>, <code>Float64</code>, <code>Bool</code>, and <code>Char</code>, while are built on top of primitive types, such as <code>Dict</code>, <code>Complex</code> and the user-defined types.</p>
<p><strong>The list of primitive types</strong></p>
<pre class="bash"><code>primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end

primitive type Bool &lt;: Integer 8 end
primitive type Char &lt;: AbstractChar 32 end

primitive type Int8    &lt;: Signed   8 end
primitive type UInt8   &lt;: Unsigned 8 end
primitive type Int16   &lt;: Signed   16 end
primitive type UInt16  &lt;: Unsigned 16 end
primitive type Int32   &lt;: Signed   32 end
primitive type UInt32  &lt;: Unsigned 32 end
primitive type Int64   &lt;: Signed   64 end
primitive type UInt64  &lt;: Unsigned 64 end
primitive type Int128  &lt;: Signed   128 end
primitive type UInt128 &lt;: Unsigned 128 end</code></pre>
<h3 data-number="2.3.4" id="extending-the-number-system"><span class="header-section-number">2.3.4</span> Extending the number system</h3>
<p>Extending the number system in Julia is much easier than in object-oriented languages like Python. In the following example, we show how to implement addition operation of a user defined class in Python.</p>
<pre class="python"><code>class X:
  def __init__(self, num):
    self.num = num

  def __add__(self, other_obj):
    return X(self.num+other_obj.num)

  def __radd__(self, other_obj):
    return X(other_obj.num + self.num)

  def __str__(self):
    return &quot;X = &quot; + str(self.num)

class Y:
  def __init__(self, num):
    self.num = num

  def __radd__(self, other_obj):
    return Y(self.num+other_obj.num)

  def __str__(self):
    return &quot;Y = &quot; + str(self.num)

print(X(3) + Y(5))

print(Y(3) + X(5))</code></pre>
<p>Here, we implemented the addition operation of two classes <code>X</code> and <code>Y</code>. The <code>__add__</code> method is called when the <code>+</code> operator is used with the object on the left-hand side, while the <code>__radd__</code> method is called when the object is on the right-hand side. The output is as follows:</p>
<pre><code>X = 8
X = 8</code></pre>
<p>It turns out the <code>__radd__</code> method of <code>Y</code> is not called at all. This is because the <code>__radd__</code> method is only called when the object on the left-hand side does not have the <code>__add__</code> method by some artifical rules.</p>
<p>Implement addition in Julian style is much easier. We can define the addition operation of two types <code>X</code> and <code>Y</code> as follows.</p>
<pre class="julia"><code>julia&gt; struct X{T} &lt;: Number
    num::T
end

julia&gt; struct Y{T} &lt;: Number
    num::T
end

julia&gt; Base.:(+)(a::X, b::Y) = X(a.num + b.num);

julia&gt; Base.:(+)(a::Y, b::X) = X(a.num + b.num);

julia&gt; Base.:(+)(a::X, b::X) = X(a.num + b.num);

julia&gt; Base.:(+)(a::Y, b::Y) = Y(a.num + b.num);</code></pre>
<p>Multiple dispatch seems to be more expressive than object-oriented programming.</p>
<p>Now, supposed you want to extend this method to a new type <code>Z</code>. In python, he needs to define a new class <code>Z</code> as follows.</p>
<pre class="python"><code>class Z:
  def __init__(self, num):
    self.num = num

  def __add__(self, other_obj):
    return Z(self.num+other_obj.num)

  def __radd__(self, other_obj):
    return Z(other_obj.num + self.num)

  def __str__(self):
    return &quot;Z = &quot; + str(self.num)

print(X(3) + Z(5))

print(Z(3) + X(5))</code></pre>
<p>The output is as follows:</p>
<pre><code>X = 8
Z = 8</code></pre>
<p>No matter how hard you try, you can not make the <code>__add__</code> method of <code>Z</code> to be called when the object is on the left-hand side. In Julia, this is not a problem at all. We can define the addition operation of <code>Z</code> as follows.</p>
<pre class="julia"><code>julia&gt; struct Z{T} &lt;: Number
    num::T
end

julia&gt; Base.:(+)(a::X, b::Z) = Z(a.num + b.num);

julia&gt; Base.:(+)(a::Z, b::X) = Z(a.num + b.num);

julia&gt; Base.:(+)(a::Y, b::Z) = Z(a.num + b.num);

julia&gt; Base.:(+)(a::Z, b::Y) = Z(a.num + b.num);

julia&gt; Base.:(+)(a::Z, b::Z) = Z(a.num + b.num);

julia&gt; X(3) + Y(5)
X{Int64}(8)

julia&gt; Y(3) + X(5)
X{Int64}(8)

julia&gt; X(3) + Z(5)
Z{Int64}(8)

julia&gt; Z(3) + Y(5)
Z{Int64}(8)</code></pre>
<p>There is a deeper reason why multiple dispatch is more expressive than object-oriented programming. The Julia function space is exponentially large! If a function <span class="math inline">\(f\)</span> has <span class="math inline">\(k\)</span> parameters, and the module has <span class="math inline">\(t\)</span> types, there can be <span class="math inline">\(t^k\)</span> methods for the function <span class="math inline">\(f\)</span>.</p>
<pre class="jula"><code>f(x::T1, y::T2, z::T3...)</code></pre>
<p>However, in an object-oriented language like Python, the function space is only linear to the number of classes.</p>
<pre class="python"><code>class T1:
    def f(self, y, z, ...):
        self.num = num
</code></pre>
<h3 data-number="2.3.5" id="example-fibonacci-number"><span class="header-section-number">2.3.5</span> Example: Fibonacci number</h3>
<p>The Fibonacci number is defined as follows.</p>
<pre class="julia"><code>julia&gt; fib(x::Int) = x &lt;= 2 ? 1 : fib(x-1) + fib(x-2)
fib (generic function with 1 methods)

julia&gt; addup(x::Int, y::Int) = x + y
addup (generic function with 1 methods)

julia&gt; @btime fib(40)
  278.066 ms (0 allocations: 0 bytes)
102334155</code></pre>
<p>Oops, it is really slow. There is definitely a better way to calculate the Fibonacci number, but let us stick to the current implementation for now.</p>
<p>If you know the Julia type system, you can implement the Fibonacci number in a zero cost way. The trick is to use the type system to calculate the Fibonacci number at compile time. There is a type <code>Val</code> defined in the <code>Base</code> module, which is just a type with a type parameter. The type parameter can be a number:</p>
<pre class="julia"><code>julia&gt; Val(3.0)
Val{3.0}()</code></pre>
<p>We can define the addition operation of <code>Val</code> as the addition of the type parameters.</p>
<pre class="julia"><code>julia&gt; addup(::Val{x}, ::Val{y}) where {x, y} = Val(x + y)
addup (generic function with 2 methods)

julia&gt; addup(Val(5), Val(7))
Val{12}()</code></pre>
<p>Finally, we can define the Fibonacci number in a zero cost way.</p>
<pre class="julia"><code>julia&gt; fib(::Val{x}) where x = x &lt;= 2 ? Val(1) : addup(fib(Val(x-1)), fib(Val(x-2)))
fib (generic function with 2 methods)


julia&gt; @btime fib(Val(40))
  0.792 ns (0 allocations: 0 bytes)
Val{102334155}()</code></pre>
<p>Wow, it is really fast! However, this trick is not recommended. It is not a good practice to abuse the type system. You simply transfer the run-time to compile time, which violates the <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">Performance Tips</a>. On the other hand, we find the compiling time of the function <code>fib</code> is much shorter than the run-time. This is because the function <code>fib</code> is a <strong>recursive function</strong>. The compiler can not optimize the recursive function very well.</p>
<h3 data-number="2.3.6" id="summary"><span class="header-section-number">2.3.6</span> Summary</h3>
<ul>
<li><em>Multiple dispatch</em> is a feature of some programming languages in which a function or method can be dynamically dispatched based on the <strong>run-time</strong> type.</li>
<li>Julia’s mutiple dispatch provides exponential abstraction power comparing with an object-oriented language.</li>
<li>By carefully designed type system, we can program in an exponentially large function space.</li>
</ul>


<div class="bottom-nav">
    <p id="nav-prev" style="text-align: left;">
        <a class="menu-level-2" href="/whyjulia"><b>2.2</b> Why Julia is fast?</a> <kbd>←</kbd>
        <span id="nav-next" style="float: right;">
            <kbd>→</kbd> <a class="menu-level-2" href="/tuple-array-and-broadcasting"><b>2.4</b> Tuple, Array and broadca..</a>
        </span>
    </p>
</div>


<div class="license">
    <br/>
  <br/>
  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
    Yu-Sheng Zhao, Yi-Dai Zhang, Jin-Guo Liu
</div>
</div>
</div>
</body>
</html>